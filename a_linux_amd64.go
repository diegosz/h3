// Code generated by 'ccgo -pkgname ch3 -trace-translation-units -export-externs X -export-defines D -export-fields F -export-structs S -export-typedefs T -Isrc/h3lib/include src/h3lib/lib/algos.c src/h3lib/lib/baseCells.c src/h3lib/lib/bbox.c src/h3lib/lib/coordijk.c src/h3lib/lib/directedEdge.c src/h3lib/lib/faceijk.c src/h3lib/lib/h3Assert.c src/h3lib/lib/h3Index.c src/h3lib/lib/isfinite.c src/h3lib/lib/iterators.c src/h3lib/lib/latLng.c src/h3lib/lib/linkedGeo.c src/h3lib/lib/localij.c src/h3lib/lib/mathExtensions.c src/h3lib/lib/polyfill.c src/h3lib/lib/polygon.c src/h3lib/lib/vec2d.c src/h3lib/lib/vec3d.c src/h3lib/lib/vertex.c src/h3lib/lib/vertexGraph.c', DO NOT EDIT.

package ch3

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

const (
	DALGOS_H                      = 0                                               // algos.h:21:1:
	DALLOC_H                      = 0                                               // alloc.h:25:1:
	DBASECELLS_H                  = 0                                               // baseCells.h:21:1:
	DBBOX_H                       = 0                                               // bbox.h:21:1:
	DBIG_ENDIAN                   = 4321                                            // endian.h:28:1:
	DBUFSIZ                       = 8192                                            // stdio.h:99:1:
	DBYTE_ORDER                   = 1234                                            // endian.h:30:1:
	DCONSTANTS_H                  = 0                                               // constants.h:21:1:
	DCOORDIJK_H                   = 0                                               // coordijk.h:31:1:
	DDBL_DECIMAL_DIG              = 17                                              // float.h:220:1:
	DDBL_DIG                      = 15                                              // float.h:54:1:
	DDBL_HAS_SUBNORM              = 1                                               // float.h:228:1:
	DDBL_MANT_DIG                 = 53                                              // float.h:40:1:
	DDBL_MAX_10_EXP               = 308                                             // float.h:94:1:
	DDBL_MAX_EXP                  = 1024                                            // float.h:82:1:
	DDBL_MIN_10_EXP               = -307                                            // float.h:74:1:
	DDBL_MIN_EXP                  = -1021                                           // float.h:62:1:
	DDECIMAL_DIG                  = 21                                              // float.h:209:1:
	DDECLSPEC                     = 0                                               // h3api.h:49:1:
	DEARTH_RADIUS_KM              = 6371.007180918475                               // constants.h:67:1:
	DEOF                          = -1                                              // stdio.h:104:1:
	DEPSILON                      = 0.0000000000000001                              // constants.h:42:1:
	DEPSILON_DEG                  = .000000001                                      // latLng.h:31:1:
	DEPSILON_RAD                  = 0                                               // latLng.h:33:1:
	DEXIT_FAILURE                 = 1                                               // stdlib.h:92:1:
	DEXIT_SUCCESS                 = 0                                               // stdlib.h:93:1:
	DFACEIJK_H                    = 0                                               // faceijk.h:25:1:
	DFD_SETSIZE                   = 1024                                            // select.h:73:1:
	DFILENAME_MAX                 = 4096                                            // stdio_lim.h:27:1:
	DFLT_DECIMAL_DIG              = 9                                               // float.h:219:1:
	DFLT_DIG                      = 6                                               // float.h:53:1:
	DFLT_EPSILON                  = 0                                               // float.h:113:1:
	DFLT_EVAL_METHOD              = 0                                               // float.h:197:1:
	DFLT_HAS_SUBNORM              = 1                                               // float.h:227:1:
	DFLT_MANT_DIG                 = 24                                              // float.h:39:1:
	DFLT_MAX                      = 0                                               // float.h:104:1:
	DFLT_MAX_10_EXP               = 38                                              // float.h:93:1:
	DFLT_MAX_EXP                  = 128                                             // float.h:81:1:
	DFLT_MIN                      = 0                                               // float.h:121:1:
	DFLT_MIN_10_EXP               = -37                                             // float.h:73:1:
	DFLT_MIN_EXP                  = -125                                            // float.h:61:1:
	DFLT_RADIX                    = 2                                               // float.h:33:1:
	DFLT_ROUNDS                   = 1                                               // float.h:128:1:
	DFLT_TRUE_MIN                 = 0                                               // float.h:235:1:
	DFOPEN_MAX                    = 16                                              // stdio_lim.h:37:1:
	DFP_ILOGB0                    = -2147483648                                     // math.h:207:1:
	DFP_ILOGBNAN                  = -2147483648                                     // math.h:212:1:
	DFP_INFINITE                  = 1                                               // math.h:940:1:
	DFP_NAN                       = 0                                               // math.h:937:1:
	DFP_NORMAL                    = 4                                               // math.h:949:1:
	DFP_SUBNORMAL                 = 3                                               // math.h:946:1:
	DFP_ZERO                      = 2                                               // math.h:943:1:
	DGEOPOINT_H                   = 0                                               // latLng.h:21:1:
	DH3API_H                      = 0                                               // h3api.h:24:1:
	DH3ASSERT_H                   = 0                                               // h3Assert.h:42:1:
	DH3INDEX_H                    = 0                                               // h3Index.h:21:1:
	DH3_BC_OFFSET                 = 45                                              // h3Index.h:38:1:
	DH3_CELL_MODE                 = 1                                               // constants.h:90:1:
	DH3_DIRECTEDEDGE_MODE         = 2                                               // constants.h:91:1:
	DH3_EDGE_MODE                 = 3                                               // constants.h:92:1:
	DH3_INIT                      = 35184372088831                                  // h3Index.h:90:1:
	DH3_MAX_OFFSET                = 63                                              // h3Index.h:32:1:
	DH3_MODE_OFFSET               = 59                                              // h3Index.h:35:1:
	DH3_NULL                      = 0                                               // h3api.h:76:1:
	DH3_NUM_BITS                  = 64                                              // h3Index.h:29:1:
	DH3_PER_DIGIT_OFFSET          = 3                                               // h3Index.h:47:1:
	DH3_RESERVED_OFFSET           = 56                                              // h3Index.h:44:1:
	DH3_RES_MASK                  = 67553994410557440                               // h3Index.h:68:1:
	DH3_RES_MASK_NEGATIVE         = 18379190079298994175                            // h3Index.h:71:1:
	DH3_RES_OFFSET                = 52                                              // h3Index.h:41:1:
	DH3_VERSION_MAJOR             = 4                                               // h3api.h:117:1:
	DH3_VERSION_MINOR             = 1                                               // h3api.h:118:1:
	DH3_VERSION_PATCH             = 0                                               // h3api.h:119:1:
	DH3_VERTEX_MODE               = 4                                               // constants.h:93:1:
	DIJ                           = 1                                               // faceijk.h:54:1:
	DINT16_MAX                    = 32767                                           // stdint.h:122:1:
	DINT16_MIN                    = -32768                                          // stdint.h:117:1:
	DINT32_MAX                    = 2147483647                                      // stdint.h:123:1:
	DINT32_MIN                    = -2147483648                                     // stdint.h:118:1:
	DINT64_MAX                    = 9223372036854775807                             // stdint.h:124:1:
	DINT64_MIN                    = -9223372036854775808                            // stdint.h:119:1:
	DINT8_MAX                     = 127                                             // stdint.h:121:1:
	DINT8_MIN                     = -128                                            // stdint.h:116:1:
	DINTMAX_MAX                   = 9223372036854775807                             // stdint.h:199:1:
	DINTMAX_MIN                   = -9223372036854775808                            // stdint.h:197:1:
	DINTPTR_MAX                   = 9223372036854775807                             // stdint.h:187:1:
	DINTPTR_MIN                   = -9223372036854775808                            // stdint.h:186:1:
	DINT_FAST16_MAX               = 9223372036854775807                             // stdint.h:164:1:
	DINT_FAST16_MIN               = -9223372036854775808                            // stdint.h:154:1:
	DINT_FAST32_MAX               = 9223372036854775807                             // stdint.h:165:1:
	DINT_FAST32_MIN               = -9223372036854775808                            // stdint.h:155:1:
	DINT_FAST64_MAX               = 9223372036854775807                             // stdint.h:170:1:
	DINT_FAST64_MIN               = -9223372036854775808                            // stdint.h:160:1:
	DINT_FAST8_MAX                = 127                                             // stdint.h:162:1:
	DINT_FAST8_MIN                = -128                                            // stdint.h:152:1:
	DINT_LEAST16_MAX              = 32767                                           // stdint.h:140:1:
	DINT_LEAST16_MIN              = -32768                                          // stdint.h:135:1:
	DINT_LEAST32_MAX              = 2147483647                                      // stdint.h:141:1:
	DINT_LEAST32_MIN              = -2147483648                                     // stdint.h:136:1:
	DINT_LEAST64_MAX              = 9223372036854775807                             // stdint.h:142:1:
	DINT_LEAST64_MIN              = -9223372036854775808                            // stdint.h:137:1:
	DINT_LEAST8_MAX               = 127                                             // stdint.h:139:1:
	DINT_LEAST8_MIN               = -128                                            // stdint.h:134:1:
	DINVALID_BASE_CELL            = 127                                             // baseCells.h:38:1:
	DINVALID_FACE                 = -1                                              // faceijk.h:61:1:
	DINVALID_ROTATIONS            = -1                                              // baseCells.h:49:1:
	DINV_RES0_U_GNOMONIC          = 2.61803398874989588842                          // constants.h:73:1:
	DJK                           = 3                                               // faceijk.h:58:1:
	DKI                           = 2                                               // faceijk.h:56:1:
	DLDBL_DECIMAL_DIG             = 21                                              // float.h:221:1:
	DLDBL_DIG                     = 18                                              // float.h:55:1:
	DLDBL_EPSILON                 = 0                                               // float.h:115:1:
	DLDBL_HAS_SUBNORM             = 1                                               // float.h:229:1:
	DLDBL_MANT_DIG                = 64                                              // float.h:41:1:
	DLDBL_MAX                     = 0                                               // float.h:106:1:
	DLDBL_MAX_10_EXP              = 4932                                            // float.h:95:1:
	DLDBL_MAX_EXP                 = 16384                                           // float.h:83:1:
	DLDBL_MIN                     = 0                                               // float.h:123:1:
	DLDBL_MIN_10_EXP              = -4931                                           // float.h:75:1:
	DLDBL_MIN_EXP                 = -16381                                          // float.h:63:1:
	DLDBL_TRUE_MIN                = 0                                               // float.h:237:1:
	DLINKED_GEO_H                 = 0                                               // linkedGeo.h:21:1:
	DLITTLE_ENDIAN                = 1234                                            // endian.h:27:1:
	DL_ctermid                    = 9                                               // stdio_lim.h:30:1:
	DL_tmpnam                     = 20                                              // stdio_lim.h:25:1:
	DMATH_ERREXCEPT               = 2                                               // math.h:1036:1:
	DMATH_ERRNO                   = 1                                               // math.h:1035:1:
	DMAX_CELL_BNDRY_VERTS         = 10                                              // h3api.h:125:1:
	DMAX_FACE_COORD               = 2                                               // baseCells.h:46:1:
	DMAX_H3_RES                   = 15                                              // constants.h:76:1:
	DMAX_ONE_RING_SIZE            = 7                                               // algos.c:45:1:
	DM_180_PI                     = 57.29577951308232087679815481410517033240547    // constants.h:39:1:
	DM_1_PI                       = 0.31830988618379067154                          // math.h:1154:1:
	DM_2PI                        = 6.28318530717958647692528676655900576839433     // constants.h:34:1:
	DM_2_PI                       = 0.63661977236758134308                          // math.h:1155:1:
	DM_2_SQRTPI                   = 1.12837916709551257390                          // math.h:1156:1:
	DM_AP7_ROT_RADS               = 0.333473172251832115336090755351601070065900389 // constants.h:58:1:
	DM_COS_AP7_ROT                = 0.9449111825230680680167902                     // constants.h:64:1:
	DM_E                          = 2.7182818284590452354                           // math.h:1146:1:
	DM_LN10                       = 2.30258509299404568402                          // math.h:1150:1:
	DM_LN2                        = 0.69314718055994530942                          // math.h:1149:1:
	DM_LOG10E                     = 0.43429448190325182765                          // math.h:1148:1:
	DM_LOG2E                      = 1.4426950408889634074                           // math.h:1147:1:
	DM_ONESEVENTH                 = 0.14285714285714285714285714285714285           // constants.h:54:1:
	DM_ONETHIRD                   = 0.333333333333333333333333333333333333333       // constants.h:51:1:
	DM_PI                         = 3.14159265358979323846                          // math.h:1151:1:
	DM_PI_180                     = 0.0174532925199432957692369076848861271111      // constants.h:37:1:
	DM_PI_2                       = 1.57079632679489661923                          // math.h:1152:1:
	DM_PI_4                       = 0.78539816339744830962                          // math.h:1153:1:
	DM_RSIN60                     = 1.1547005383792515290182975610039149112953      // constants.h:48:1:
	DM_SIN60                      = 0                                               // constants.h:46:1:
	DM_SIN_AP7_ROT                = 0.3273268353539885718950318                     // constants.h:61:1:
	DM_SQRT1_2                    = 0.70710678118654752440                          // math.h:1158:1:
	DM_SQRT2                      = 1.41421356237309504880                          // math.h:1157:1:
	DM_SQRT3_2                    = 0.8660254037844386467637231707529361834714      // constants.h:44:1:
	DNUM_BASE_CELLS               = 122                                             // constants.h:81:1:
	DNUM_HEX_VERTS                = 6                                               // constants.h:83:1:
	DNUM_ICOSA_FACES              = 20                                              // constants.h:79:1:
	DNUM_PENTAGONS                = 12                                              // constants.h:87:1:
	DNUM_PENT_VERTS               = 5                                               // constants.h:85:1:
	DPDP_ENDIAN                   = 3412                                            // endian.h:29:1:
	DPOLYGON_H                    = 0                                               // polygon.h:21:1:
	DPOLYGON_TO_CELLS_BUFFER      = 12                                              // algos.c:46:1:
	DPTRDIFF_MAX                  = 9223372036854775807                             // stdint.h:210:1:
	DPTRDIFF_MIN                  = -9223372036854775808                            // stdint.h:209:1:
	DP_tmpdir                     = "/tmp"                                          // stdio.h:120:1:
	DRAND_MAX                     = 2147483647                                      // stdlib.h:87:1:
	DRES0_U_GNOMONIC              = 0.38196601125010500003                          // constants.h:72:1:
	DSEEK_CUR                     = 1                                               // stdio.h:110:1:
	DSEEK_END                     = 2                                               // stdio.h:111:1:
	DSEEK_SET                     = 0                                               // stdio.h:109:1:
	DSIG_ATOMIC_MAX               = 2147483647                                      // stdint.h:223:1:
	DSIG_ATOMIC_MIN               = -2147483648                                     // stdint.h:222:1:
	DSIZE_MAX                     = 18446744073709551615                            // stdint.h:227:1:
	DTMP_MAX                      = 238328                                          // stdio_lim.h:26:1:
	DUINT16_MAX                   = 65535                                           // stdint.h:128:1:
	DUINT32_MAX                   = 4294967295                                      // stdint.h:129:1:
	DUINT64_MAX                   = 18446744073709551615                            // stdint.h:130:1:
	DUINT8_MAX                    = 255                                             // stdint.h:127:1:
	DUINTMAX_MAX                  = 18446744073709551615                            // stdint.h:202:1:
	DUINTPTR_MAX                  = 18446744073709551615                            // stdint.h:188:1:
	DUINT_FAST16_MAX              = 18446744073709551615                            // stdint.h:175:1:
	DUINT_FAST32_MAX              = 18446744073709551615                            // stdint.h:176:1:
	DUINT_FAST64_MAX              = 18446744073709551615                            // stdint.h:181:1:
	DUINT_FAST8_MAX               = 255                                             // stdint.h:173:1:
	DUINT_LEAST16_MAX             = 65535                                           // stdint.h:146:1:
	DUINT_LEAST32_MAX             = 4294967295                                      // stdint.h:147:1:
	DUINT_LEAST64_MAX             = 18446744073709551615                            // stdint.h:148:1:
	DUINT_LEAST8_MAX              = 255                                             // stdint.h:145:1:
	DVEC2D_H                      = 0                                               // vec2d.h:21:1:
	DVERTEX_GRAPH_H               = 0                                               // vertexGraph.h:21:1:
	DWCHAR_MAX                    = 2147483647                                      // stdint.h:240:1:
	DWCHAR_MIN                    = -2147483648                                     // stdint.h:239:1:
	DWCONTINUED                   = 8                                               // waitflags.h:32:1:
	DWEXITED                      = 4                                               // waitflags.h:31:1:
	DWINT_MAX                     = 4294967295                                      // stdint.h:245:1:
	DWINT_MIN                     = 0                                               // stdint.h:244:1:
	DWNOHANG                      = 1                                               // waitflags.h:25:1:
	DWNOWAIT                      = 0x01000000                                      // waitflags.h:33:1:
	DWSTOPPED                     = 2                                               // waitflags.h:30:1:
	DWUNTRACED                    = 2                                               // waitflags.h:26:1:
	D_ALLOCA_H                    = 1                                               // alloca.h:19:1:
	D_ASSERT_H                    = 1                                               // assert.h:34:1:
	D_ASSERT_H_DECLS              = 0                                               // assert.h:65:1:
	D_ATFILE_SOURCE               = 1                                               // features.h:351:1:
	D_BITS_ATOMIC_WIDE_COUNTER_H  = 0                                               // atomic_wide_counter.h:20:1:
	D_BITS_BYTESWAP_H             = 1                                               // byteswap.h:24:1:
	D_BITS_ENDIANNESS_H           = 1                                               // endianness.h:2:1:
	D_BITS_ENDIAN_H               = 1                                               // endian.h:20:1:
	D_BITS_FLOATN_COMMON_H        = 0                                               // floatn-common.h:21:1:
	D_BITS_FLOATN_H               = 0                                               // floatn.h:20:1:
	D_BITS_LIBM_SIMD_DECL_STUBS_H = 1                                               // libm-simd-decl-stubs.h:34:1:
	D_BITS_PTHREADTYPES_ARCH_H    = 1                                               // pthreadtypes-arch.h:19:1:
	D_BITS_PTHREADTYPES_COMMON_H  = 1                                               // pthreadtypes.h:20:1:
	D_BITS_STDINT_INTN_H          = 1                                               // stdint-intn.h:20:1:
	D_BITS_STDINT_UINTN_H         = 1                                               // stdint-uintn.h:20:1:
	D_BITS_STDIO_LIM_H            = 1                                               // stdio_lim.h:19:1:
	D_BITS_TIME64_H               = 1                                               // time64.h:24:1:
	D_BITS_TYPESIZES_H            = 1                                               // typesizes.h:24:1:
	D_BITS_TYPES_H                = 1                                               // types.h:24:1:
	D_BITS_TYPES_LOCALE_T_H       = 1                                               // locale_t.h:20:1:
	D_BITS_TYPES___LOCALE_T_H     = 1                                               // __locale_t.h:20:1:
	D_BITS_UINTN_IDENTITY_H       = 1                                               // uintn-identity.h:24:1:
	D_BITS_WCHAR_H                = 1                                               // wchar.h:20:1:
	D_BSD_SIZE_T_                 = 0                                               // stddef.h:189:1:
	D_BSD_SIZE_T_DEFINED_         = 0                                               // stddef.h:192:1:
	D_DEFAULT_SOURCE              = 1                                               // features.h:236:1:
	D_ENDIAN_H                    = 1                                               // endian.h:19:1:
	D_FEATURES_H                  = 1                                               // features.h:19:1:
	D_FILE_OFFSET_BITS            = 64                                              // <builtin>:25:1:
	D_FLOAT_H___                  = 0                                               // float.h:29:1:
	D_GCC_SIZE_T                  = 0                                               // stddef.h:195:1:
	D_GCC_WCHAR_T                 = 0                                               // stddef.h:273:1:
	D_GCC_WRAP_STDINT_H           = 0                                               // stdint.h:13:1:
	D_IOFBF                       = 0                                               // stdio.h:93:1:
	D_IOLBF                       = 1                                               // stdio.h:94:1:
	D_IONBF                       = 2                                               // stdio.h:95:1:
	D_IO_EOF_SEEN                 = 0x0010                                          // struct_FILE.h:111:1:
	D_IO_ERR_SEEN                 = 0x0020                                          // struct_FILE.h:114:1:
	D_IO_USER_LOCK                = 0x8000                                          // struct_FILE.h:117:1:
	D_LP64                        = 1                                               // <predefined>:298:1:
	D_MATH_H                      = 1                                               // math.h:24:1:
	D_POSIX_C_SOURCE              = 200809                                          // features.h:290:1:
	D_POSIX_SOURCE                = 1                                               // features.h:288:1:
	D_RWLOCK_INTERNAL_H           = 0                                               // struct_rwlock.h:21:1:
	D_SIZET_                      = 0                                               // stddef.h:196:1:
	D_SIZE_T                      = 0                                               // stddef.h:183:1:
	D_SIZE_T_                     = 0                                               // stddef.h:188:1:
	D_SIZE_T_DECLARED             = 0                                               // stddef.h:193:1:
	D_SIZE_T_DEFINED              = 0                                               // stddef.h:191:1:
	D_SIZE_T_DEFINED_             = 0                                               // stddef.h:190:1:
	D_STDBOOL_H                   = 0                                               // stdbool.h:29:1:
	D_STDC_PREDEF_H               = 1                                               // <predefined>:169:1:
	D_STDINT_H                    = 1                                               // stdint.h:23:1:
	D_STDIO_H                     = 1                                               // stdio.h:24:1:
	D_STDLIB_H                    = 1                                               // stdlib.h:36:1:
	D_STRINGS_H                   = 1                                               // strings.h:19:1:
	D_STRING_H                    = 1                                               // string.h:23:1:
	D_STRUCT_TIMESPEC             = 1                                               // struct_timespec.h:3:1:
	D_SYS_CDEFS_H                 = 1                                               // cdefs.h:20:1:
	D_SYS_SELECT_H                = 1                                               // select.h:22:1:
	D_SYS_SIZE_T_H                = 0                                               // stddef.h:184:1:
	D_SYS_TYPES_H                 = 1                                               // types.h:23:1:
	D_THREAD_MUTEX_INTERNAL_H     = 1                                               // struct_mutex.h:20:1:
	D_THREAD_SHARED_TYPES_H       = 1                                               // thread-shared-types.h:20:1:
	D_T_SIZE                      = 0                                               // stddef.h:186:1:
	D_T_SIZE_                     = 0                                               // stddef.h:185:1:
	D_T_WCHAR                     = 0                                               // stddef.h:264:1:
	D_T_WCHAR_                    = 0                                               // stddef.h:263:1:
	D_VA_LIST_DEFINED             = 0                                               // stdio.h:53:1:
	D_WCHAR_T                     = 0                                               // stddef.h:262:1:
	D_WCHAR_T_                    = 0                                               // stddef.h:266:1:
	D_WCHAR_T_DECLARED            = 0                                               // stddef.h:274:1:
	D_WCHAR_T_DEFINED             = 0                                               // stddef.h:269:1:
	D_WCHAR_T_DEFINED_            = 0                                               // stddef.h:268:1:
	D_WCHAR_T_H                   = 0                                               // stddef.h:270:1:
	Dfalse                        = 0                                               // stdbool.h:39:1:
	Dlinux                        = 1                                               // <predefined>:244:1:
	Dmath_errhandling             = 3                                               // math.h:1048:1:
	Dtrue                         = 1                                               // stdbool.h:38:1:
	Dunix                         = 1                                               // <predefined>:185:1:
	DISFINITE_H                   = 0                                               // isfinite.h:3:1:
	DINT32_MAX_3                  = 715827882                                       // coordijk.c:33:1:
	DMATHEXTENSIONS_H             = 0                                               // mathExtensions.h:21:1:
	DH3VERTEX_H                   = 0                                               // vertex.h:21:1:
	DINVALID_VERTEX_NUM           = -1                                              // vertex.h:36:1:
	DMAX_BASE_CELL_FACES          = 5                                               // vertex.h:39:1:
	DPRIX16                       = "X"                                             // inttypes.h:135:1:
	DPRIX32                       = "X"                                             // inttypes.h:136:1:
	DPRIX8                        = "X"                                             // inttypes.h:134:1:
	DPRIXFAST8                    = "X"                                             // inttypes.h:144:1:
	DPRIXLEAST16                  = "X"                                             // inttypes.h:140:1:
	DPRIXLEAST32                  = "X"                                             // inttypes.h:141:1:
	DPRIXLEAST8                   = "X"                                             // inttypes.h:139:1:
	DPRId16                       = "d"                                             // inttypes.h:55:1:
	DPRId32                       = "d"                                             // inttypes.h:56:1:
	DPRId8                        = "d"                                             // inttypes.h:54:1:
	DPRIdFAST8                    = "d"                                             // inttypes.h:64:1:
	DPRIdLEAST16                  = "d"                                             // inttypes.h:60:1:
	DPRIdLEAST32                  = "d"                                             // inttypes.h:61:1:
	DPRIdLEAST8                   = "d"                                             // inttypes.h:59:1:
	DPRIi16                       = "i"                                             // inttypes.h:71:1:
	DPRIi32                       = "i"                                             // inttypes.h:72:1:
	DPRIi8                        = "i"                                             // inttypes.h:70:1:
	DPRIiFAST8                    = "i"                                             // inttypes.h:80:1:
	DPRIiLEAST16                  = "i"                                             // inttypes.h:76:1:
	DPRIiLEAST32                  = "i"                                             // inttypes.h:77:1:
	DPRIiLEAST8                   = "i"                                             // inttypes.h:75:1:
	DPRIo16                       = "o"                                             // inttypes.h:87:1:
	DPRIo32                       = "o"                                             // inttypes.h:88:1:
	DPRIo8                        = "o"                                             // inttypes.h:86:1:
	DPRIoFAST8                    = "o"                                             // inttypes.h:96:1:
	DPRIoLEAST16                  = "o"                                             // inttypes.h:92:1:
	DPRIoLEAST32                  = "o"                                             // inttypes.h:93:1:
	DPRIoLEAST8                   = "o"                                             // inttypes.h:91:1:
	DPRIu16                       = "u"                                             // inttypes.h:103:1:
	DPRIu32                       = "u"                                             // inttypes.h:104:1:
	DPRIu8                        = "u"                                             // inttypes.h:102:1:
	DPRIuFAST8                    = "u"                                             // inttypes.h:112:1:
	DPRIuLEAST16                  = "u"                                             // inttypes.h:108:1:
	DPRIuLEAST32                  = "u"                                             // inttypes.h:109:1:
	DPRIuLEAST8                   = "u"                                             // inttypes.h:107:1:
	DPRIx16                       = "x"                                             // inttypes.h:119:1:
	DPRIx32                       = "x"                                             // inttypes.h:120:1:
	DPRIx8                        = "x"                                             // inttypes.h:118:1:
	DPRIxFAST8                    = "x"                                             // inttypes.h:128:1:
	DPRIxLEAST16                  = "x"                                             // inttypes.h:124:1:
	DPRIxLEAST32                  = "x"                                             // inttypes.h:125:1:
	DPRIxLEAST8                   = "x"                                             // inttypes.h:123:1:
	DSCNd16                       = "hd"                                            // inttypes.h:172:1:
	DSCNd32                       = "d"                                             // inttypes.h:173:1:
	DSCNd8                        = "hhd"                                           // inttypes.h:171:1:
	DSCNdFAST8                    = "hhd"                                           // inttypes.h:181:1:
	DSCNdLEAST16                  = "hd"                                            // inttypes.h:177:1:
	DSCNdLEAST32                  = "d"                                             // inttypes.h:178:1:
	DSCNdLEAST8                   = "hhd"                                           // inttypes.h:176:1:
	DSCNi16                       = "hi"                                            // inttypes.h:188:1:
	DSCNi32                       = "i"                                             // inttypes.h:189:1:
	DSCNi8                        = "hhi"                                           // inttypes.h:187:1:
	DSCNiFAST8                    = "hhi"                                           // inttypes.h:197:1:
	DSCNiLEAST16                  = "hi"                                            // inttypes.h:193:1:
	DSCNiLEAST32                  = "i"                                             // inttypes.h:194:1:
	DSCNiLEAST8                   = "hhi"                                           // inttypes.h:192:1:
	DSCNo16                       = "ho"                                            // inttypes.h:220:1:
	DSCNo32                       = "o"                                             // inttypes.h:221:1:
	DSCNo8                        = "hho"                                           // inttypes.h:219:1:
	DSCNoFAST8                    = "hho"                                           // inttypes.h:229:1:
	DSCNoLEAST16                  = "ho"                                            // inttypes.h:225:1:
	DSCNoLEAST32                  = "o"                                             // inttypes.h:226:1:
	DSCNoLEAST8                   = "hho"                                           // inttypes.h:224:1:
	DSCNu16                       = "hu"                                            // inttypes.h:204:1:
	DSCNu32                       = "u"                                             // inttypes.h:205:1:
	DSCNu8                        = "hhu"                                           // inttypes.h:203:1:
	DSCNuFAST8                    = "hhu"                                           // inttypes.h:213:1:
	DSCNuLEAST16                  = "hu"                                            // inttypes.h:209:1:
	DSCNuLEAST32                  = "u"                                             // inttypes.h:210:1:
	DSCNuLEAST8                   = "hhu"                                           // inttypes.h:208:1:
	DSCNx16                       = "hx"                                            // inttypes.h:236:1:
	DSCNx32                       = "x"                                             // inttypes.h:237:1:
	DSCNx8                        = "hhx"                                           // inttypes.h:235:1:
	DSCNxFAST8                    = "hhx"                                           // inttypes.h:245:1:
	DSCNxLEAST16                  = "hx"                                            // inttypes.h:241:1:
	DSCNxLEAST32                  = "x"                                             // inttypes.h:242:1:
	DSCNxLEAST8                   = "hhx"                                           // inttypes.h:240:1:
	D_INTTYPES_H                  = 1                                               // inttypes.h:23:1:
	DM_RSQRT7                     = 0.37796447300922722721451653623418006081576     // faceijk.c:37:1:
	DM_SQRT7                      = 2.6457513110645905905016157536392604257102      // faceijk.c:36:1:
	DVEC3D_H                      = 0                                               // vec3d.h:21:1:
	DITERATORS_H                  = 0                                               // iterators.h:23:1:
	DCELL_SCALE_FACTOR            = 1.1                                             // polyfill.c:35:1:
	DCHILD_SCALE_FACTOR           = 1.4                                             // polyfill.c:40:1:
	DPOLYFILL_H                   = 0                                               // polyfill.h:21:1:
	DDIRECTION_INDEX_OFFSET       = 2                                               // vertex.c:32:1:
)

// Depending on the type of TG_ARG, call an appropriately suffixed
//    version of FUNC with arguments (including parentheses) ARGS.
//    Suffixed functions may not exist for long double if it has the same
//    format as double, or for other types with the same format as float,
//    double or long double.  The behavior is undefined if the argument
//    does not have a real floating type.  The definition may use a
//    conditional expression, so all suffixed versions of FUNC must
//    return the same type (FUNC may include a cast if necessary rather
//    than being a single identifier).

// ISO C99 defines some generic macros which work on any data type.

// All floating-point numbers can be put in one of these categories.
const ( /* math.h:934:1: */
	FP_NAN       = 0
	FP_INFINITE  = 1
	FP_ZERO      = 2
	FP_SUBNORMAL = 3
	FP_NORMAL    = 4
)

// * @brief H3 digit representing ijk+ axes direction.
// Values will be within the lowest 3 bits of an integer.
const ( /* coordijk.h:63:1: */
	//* H3 digit in center
	CENTER_DIGIT = 0
	//* H3 digit in k-axes direction
	K_AXES_DIGIT = 1
	//* H3 digit in j-axes direction
	J_AXES_DIGIT = 2
	//* H3 digit in j == k direction
	JK_AXES_DIGIT = 3 // 3
	//* H3 digit in i-axes direction
	I_AXES_DIGIT = 4
	//* H3 digit in i == k direction
	IK_AXES_DIGIT = 5 // 5
	//* H3 digit in i == j direction
	IJ_AXES_DIGIT = 6 // 6
	//* H3 digit in the invalid direction
	INVALID_DIGIT = 7
	// * Valid digits will be less than this value. Same value as INVALID_DIGIT.
	NUM_DIGITS = 7
	//* Child digit which is skipped for pentagons
	PENTAGON_SKIPPED_DIGIT = 1
)

// indexes for faceNeighbors table
//* IJ quadrant faceNeighbors table direction
//* KI quadrant faceNeighbors table direction
//* JK quadrant faceNeighbors table direction

//* Invalid face index

// * Digit representing overage type
const ( /* faceijk.h:64:1: */
	//* No overage (on original face)
	NO_OVERAGE = 0
	//* On face edge (only occurs on substrate grids)
	FACE_EDGE = 1
	//* Overage on new face interior
	NEW_FACE = 2
)

const ( /* h3api.h:81:1: */
	E_SUCCESS = 0 // Success (no error)
	E_FAILED  = 1 // The operation failed but a more specific error is not available
	E_DOMAIN  = 2 // Argument was outside of acceptable range (when a more
	// specific error code is not available)
	E_LATLNG_DOMAIN      = 3 // Latitude or longitude arguments were outside of acceptable range
	E_RES_DOMAIN         = 4 // Resolution argument was outside of acceptable range
	E_CELL_INVALID       = 5 // `H3Index` cell argument was not valid
	E_DIR_EDGE_INVALID   = 6 // `H3Index` directed edge argument was not valid
	E_UNDIR_EDGE_INVALID = 7 // `H3Index` undirected edge argument was not valid
	E_VERTEX_INVALID     = 8 // `H3Index` vertex argument was not valid
	E_PENTAGON           = 9 // Pentagon distortion was encountered which the algorithm
	// could not handle it
	E_DUPLICATE_INPUT = 10 // Duplicate input was encountered in the arguments
	// and the algorithm could not handle it
	E_NOT_NEIGHBORS  = 11 // `H3Index` cell arguments were not neighbors
	E_RES_MISMATCH   = 12 // `H3Index` cell arguments had incompatible resolutions
	E_MEMORY_ALLOC   = 13 // Necessary memory allocation failed
	E_MEMORY_BOUNDS  = 14 // Bounds of provided memory were not large enough
	E_OPTION_INVALID = 15
)

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright 2016-2017, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

//* epsilon of ~0.1mm in degrees
//* epsilon of ~0.1mm in radians

const ( /* latLng.h:35:1: */
	NORMALIZE_NONE = 0 // Do not normalize
	NORMALIZE_EAST = 1 // Normalize negative numbers to the east
	NORMALIZE_WEST = 2
)

// Macros for use with polygonAlgos.h
//* Macro: Init iteration vars for GeoLoop

//* Macro: Increment GeoLoop loop iteration, or break if done.

//* Macro: Whether a GeoLoop is empty

// *
// Values representing polyfill containment modes, to be used in
// the `flags` bit field.
const ( /* polygon.h:47:1: */
	CONTAINMENT_CENTER           = 0 ///< Cell center is contained in the shape
	CONTAINMENT_FULL             = 1 ///< Cell is fully contained in the shape
	CONTAINMENT_OVERLAPPING      = 2 ///< Cell overlaps the shape at any point
	CONTAINMENT_OVERLAPPING_BBOX = 3 ///< Cell bounding box overlaps shape
	CONTAINMENT_INVALID          = 4
)

type Tptrdiff_t = int64 /* <builtin>:3:26 */

type Tsize_t = uint64 /* <builtin>:9:23 */

type Twchar_t = int32 /* <builtin>:15:24 */

type T__int128_t = struct {
	Flo int64
	Fhi int64
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type T__uint128_t = struct {
	Flo uint64
	Fhi uint64
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type T__builtin_va_list = uintptr /* <builtin>:46:14 */
type T__float128 = float64        /* <builtin>:47:21 */

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file algos.c
// @brief   Hexagon grid algorithms

// Copyright 2016-2018, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file algos.h
// @brief   Hexagon grid algorithms

// Copyright 2016-2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Signal that all the definitions are present.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Preprocessor code to support renaming (prefixing) the public API.
// All public functions should be wrapped in H3_EXPORT so they can be
// renamed.

// Windows DLL requires attributes indicating what to export

// For uint64_t
// Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99: 7.18 Integer types <stdint.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These are defined by the user (or the compiler)
//    to specify the desired environment:
//
//    __STRICT_ANSI__	ISO Standard C.
//    _ISOC99_SOURCE	Extensions to ISO C89 from ISO C99.
//    _ISOC11_SOURCE	Extensions to ISO C99 from ISO C11.
//    _ISOC2X_SOURCE	Extensions to ISO C99 from ISO C2X.
//    __STDC_WANT_LIB_EXT2__
// 			Extensions to ISO C99 from TR 27431-2:2010.
//    __STDC_WANT_IEC_60559_BFP_EXT__
// 			Extensions to ISO C11 from TS 18661-1:2014.
//    __STDC_WANT_IEC_60559_FUNCS_EXT__
// 			Extensions to ISO C11 from TS 18661-4:2015.
//    __STDC_WANT_IEC_60559_TYPES_EXT__
// 			Extensions to ISO C11 from TS 18661-3:2015.
//    __STDC_WANT_IEC_60559_EXT__
// 			ISO C2X interfaces defined only in Annex F.
//
//    _POSIX_SOURCE	IEEE Std 1003.1.
//    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;
// 			if >=199309L, add IEEE Std 1003.1b-1993;
// 			if >=199506L, add IEEE Std 1003.1c-1995;
// 			if >=200112L, all of IEEE 1003.1-2004
// 			if >=200809L, all of IEEE 1003.1-2008
//    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if
// 			Single Unix conformance is wanted, to 600 for the
// 			sixth revision, to 700 for the seventh revision.
//    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.
//    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.
//    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.
//    _FILE_OFFSET_BITS=N	Select default filesystem interface.
//    _ATFILE_SOURCE	Additional *at interfaces.
//    _DYNAMIC_STACK_SIZE_SOURCE Select correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    _GNU_SOURCE		All of the above, plus GNU extensions.
//    _DEFAULT_SOURCE	The default set of features (taking precedence over
// 			__STRICT_ANSI__).
//
//    _FORTIFY_SOURCE	Add security hardening to many library functions.
// 			Set to 1 or 2; 2 performs stricter checks than 1.
//
//    _REENTRANT, _THREAD_SAFE
// 			Obsolete; equivalent to _POSIX_C_SOURCE=199506L.
//
//    The `-ansi' switch to the GNU C compiler, and standards conformance
//    options such as `-std=c99', define __STRICT_ANSI__.  If none of
//    these are defined, or if _DEFAULT_SOURCE is defined, the default is
//    to have _POSIX_SOURCE set to one and _POSIX_C_SOURCE set to
//    200809L, as well as enabling miscellaneous functions from BSD and
//    SVID.  If more than one of these are defined, they accumulate.  For
//    example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE together
//    give you ISO C, 1003.1, and 1003.2, but nothing else.
//
//    These are defined by this file and are used by the
//    header files to decide what to declare or define:
//
//    __GLIBC_USE (F)	Define things from feature set F.  This is defined
// 			to 1 or 0; the subsequent macros are either defined
// 			or undefined, and those tests should be moved to
// 			__GLIBC_USE.
//    __USE_ISOC11		Define ISO C11 things.
//    __USE_ISOC99		Define ISO C99 things.
//    __USE_ISOC95		Define ISO C90 AMD1 (C95) things.
//    __USE_ISOCXX11	Define ISO C++11 things.
//    __USE_POSIX		Define IEEE Std 1003.1 things.
//    __USE_POSIX2		Define IEEE Std 1003.2 things.
//    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.
//    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.
//    __USE_XOPEN		Define XPG things.
//    __USE_XOPEN_EXTENDED	Define X/Open Unix things.
//    __USE_UNIX98		Define Single Unix V2 things.
//    __USE_XOPEN2K        Define XPG6 things.
//    __USE_XOPEN2KXSI     Define XPG6 XSI things.
//    __USE_XOPEN2K8       Define XPG7 things.
//    __USE_XOPEN2K8XSI    Define XPG7 XSI things.
//    __USE_LARGEFILE	Define correct standard I/O things.
//    __USE_LARGEFILE64	Define LFS things with separate names.
//    __USE_FILE_OFFSET64	Define 64bit interface as default.
//    __USE_MISC		Define things from 4.3BSD or System V Unix.
//    __USE_ATFILE		Define *at interfaces and AT_* constants for them.
//    __USE_DYNAMIC_STACK_SIZE Define correct (but non compile-time constant)
// 			MINSIGSTKSZ, SIGSTKSZ and PTHREAD_STACK_MIN.
//    __USE_GNU		Define GNU extensions.
//    __USE_FORTIFY_LEVEL	Additional security measures used, according to level.
//
//    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are
//    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided
//    only for compatibility.  All new code should use the other symbols
//    to test for features.
//
//    All macros listed above as possibly being defined by this file are
//    explicitly undefined if they are not explicitly defined.
//    Feature-test macros that are not defined by the user or compiler
//    but are implied by the other feature-test macros defined (or by the
//    lack of any definitions) are defined by the file.
//
//    ISO C feature test macros depend on the definition of the macro
//    when an affected header is included, not when the first system
//    header is included, and so they are handled in
//    <bits/libc-header-start.h>, which does not have a multiple include
//    guard.  Feature test macros that can be handled from the first
//    system header included are handled here.

// Undefine everything, so we get a clean slate.

// Suppress kernel-name space pollution unless user expressedly asks
//    for it.

// Convenience macro to test the version of gcc.
//    Use like this:
//    #if __GNUC_PREREQ (2,8)
//    ... code requiring gcc 2.8 or later ...
//    #endif
//    Note: only works for GCC 2.0 and later, because __GNUC_MINOR__ was
//    added in 2.0.

// Similarly for clang.  Features added to GCC after version 4.2 may
//    or may not also be available in clang, and clang's definitions of
//    __GNUC(_MINOR)__ are fixed at 4 and 2 respectively.  Not all such
//    features can be queried via __has_extension/__has_feature.

// Whether to use feature set F.

// _BSD_SOURCE and _SVID_SOURCE are deprecated aliases for
//    _DEFAULT_SOURCE.  If _DEFAULT_SOURCE is present we do not
//    issue a warning; the expectation is that the source is being
//    transitioned to use the new macro.

// If _GNU_SOURCE was defined by the user, turn on all the other features.

// If nothing (other than _GNU_SOURCE and _DEFAULT_SOURCE) is defined,
//    define _DEFAULT_SOURCE.

// This is to enable the ISO C2X extension.

// This is to enable the ISO C11 extension.

// This is to enable the ISO C99 extension.

// This is to enable the ISO C90 Amendment 1:1995 extension.

// If none of the ANSI/POSIX macros are defined, or if _DEFAULT_SOURCE
//    is defined, use POSIX.1-2008 (or another version depending on
//    _XOPEN_SOURCE).

// Some C libraries once required _REENTRANT and/or _THREAD_SAFE to be
//    defined in all multithreaded code.  GNU libc has not required this
//    for many years.  We now treat them as compatibility synonyms for
//    _POSIX_C_SOURCE=199506L, which is the earliest level of POSIX with
//    comprehensive support for multithreaded code.  Using them never
//    lowers the selected level of POSIX conformance, only raises it.

// Features part to handle 64-bit time_t support.
//    Copyright (C) 2021-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We need to know the word size in order to check the time size.
// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// For others, time size is word size.

// The function 'gets' existed in C89, but is impossible to use
//    safely.  It has been removed from ISO C11 and ISO C++14.  Note: for
//    compatibility with various implementations of <cstdio>, this test
//    must consider only the value of __cplusplus when compiling C++.

// GNU formerly extended the scanf functions with modified format
//    specifiers %as, %aS, and %a[...] that allocate a buffer for the
//    input using malloc.  This extension conflicts with ISO C99, which
//    defines %a as a standalone format specifier that reads a floating-
//    point number; moreover, POSIX.1-2008 provides the same feature
//    using the modifier letter 'm' instead (%ms, %mS, %m[...]).
//
//    We now follow C99 unless GNU extensions are active and the compiler
//    is specifically in C89 or C++98 mode (strict or not).  For
//    instance, with GCC, -std=gnu11 will have C99-compliant scanf with
//    or without -D_GNU_SOURCE, but -std=c89 -D_GNU_SOURCE will have the
//    old extension.

// Get definitions of __STDC_* predefined macros, if the compiler has
//    not preincluded this header automatically.
// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This macro indicates that the installed library is the GNU C Library.
//    For historic reasons the value now is 6 and this will stay from now
//    on.  The use of this variable is deprecated.  Use __GLIBC__ and
//    __GLIBC_MINOR__ now (see below) when you want to test for a specific
//    GNU C library version and use the values in <gnu/lib-names.h> to get
//    the sonames of the shared libraries.

// Major and minor version number of the GNU C library package.  Use
//    these macros to test for features in specific releases.

// This is here only because every header file already includes this one.
// Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We are almost always included from features.h.

// The GNU libc does not support any K&R compilers or the traditional mode
//    of ISO C compilers anymore.  Check for some of the combinations not
//    supported anymore.

// Some user header file might have defined this before.

// Compilers that lack __has_attribute may object to
//        #if defined __has_attribute && __has_attribute (...)
//    even though they do not need to evaluate the right-hand side of the &&.
//    Similarly for __has_builtin, etc.

// All functions, except those with callbacks or those that
//    synchronize memory, are leaf functions.

// GCC can always grok prototypes.  For C++ programs we add throw()
//    to help it optimize the function calls.  But this only works with
//    gcc 2.8.x and egcs.  For gcc 3.4 and up we even mark C functions
//    as non-throwing using a function attribute since programs can use
//    the -fexceptions options for C code as well.

// These two macros are not used in glibc anymore.  They are kept here
//    only because some other projects expect the macros to be defined.

// For these things, GCC behaves the ANSI way normally,
//    and the non-ANSI way under -traditional.

// This is not a typedef so `const __ptr_t' does the right thing.

// C++ needs to know that types and declarations are C, not C++.

// Fortify support.

// Use __builtin_dynamic_object_size at _FORTIFY_SOURCE=3 when available.

// Compile time conditions to choose between the regular, _chk and _chk_warn
//    variants.  These conditions should get evaluated to constant and optimized
//    away.

// Length is known to be safe at compile time if the __L * __S <= __OBJSZ
//    condition can be folded to a constant and if it is true.  The -1 check is
//    redundant because since it implies that __glibc_safe_len_cond is true.

// Conversely, we know at compile time that the length is unsafe if the
//    __L * __S <= __OBJSZ condition can be folded to a constant and if it is
//    false.

// Fortify function f.  __f_alias, __f_chk and __f_chk_warn must be
//    declared.

// Fortify function f, where object size argument passed to f is the number of
//    elements and not total size.

// Support for flexible arrays.
//    Headers that should use flexible arrays only if they're "real"
//    (e.g. only if they won't affect sizeof()) should test
//    #if __glibc_c99_flexarr_available.

// __asm__ ("xyz") is used throughout the headers to rename functions
//    at the assembly language level.  This is wrapped by the __REDIRECT
//    macro, in order to support compilers that can do this some other
//    way.  When compilers don't support asm-names at all, we have to do
//    preprocessor tricks instead (which don't have exactly the right
//    semantics, but it's the best we can do).
//
//    Example:
//    int __REDIRECT(setpgrp, (__pid_t pid, __pid_t pgrp), setpgid);

//
// #elif __SOME_OTHER_COMPILER__
//
// # define __REDIRECT(name, proto, alias) name proto; 	_Pragma("let " #name " = " #alias)

// GCC and clang have various useful declarations that can be made with
//    the '__attribute__' syntax.  All of the ways we use this do fine if
//    they are omitted for compilers that don't understand it.

// At some point during the gcc 2.96 development the `malloc' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Tell the compiler which arguments to an allocation function
//    indicate the size of the allocation.

// Tell the compiler which argument to an allocation function
//    indicates the alignment of the allocation.

// At some point during the gcc 2.96 development the `pure' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// This declaration tells the compiler that the value is constant.

// At some point during the gcc 3.1 development the `used' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.

// Since version 3.2, gcc allows marking deprecated functions.

// Since version 4.5, gcc also allows one to specify the message printed
//    when a deprecated function is used.  clang claims to be gcc 4.2, but
//    may also support this feature.

// At some point during the gcc 2.8 development the `format_arg' attribute
//    for functions was introduced.  We don't want to use it unconditionally
//    (although this would be possible) since it generates warnings.
//    If several `format_arg' attributes are given for the same function, in
//    gcc-3.0 and older, all but the last one are ignored.  In newer gccs,
//    all designated arguments are considered.

// At some point during the gcc 2.97 development the `strfmon' format
//    attribute for functions was introduced.  We don't want to use it
//    unconditionally (although this would be possible) since it
//    generates warnings.

// The nonnull function attribute marks pointer parameters that
//    must not be NULL.  This has the name __nonnull in glibc,
//    and __attribute_nonnull__ in files shared with Gnulib to avoid
//    collision with a different __nonnull in DragonFlyBSD 5.9.

// The returns_nonnull function attribute marks the return type of the function
//    as always being non-null.

// If fortification mode, we warn about unused results of certain
//    function calls which can lead to problems.

// Forces a function to be always inlined.
// The Linux kernel defines __always_inline in stddef.h (283d7573), and
//    it conflicts with this definition.  Therefore undefine it first to
//    allow either header to be included first.

// Associate error messages with the source location of the call site rather
//    than with the source location inside the function.

// GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
//    inline semantics, unless -fgnu89-inline is used.  Using __GNUC_STDC_INLINE__
//    or __GNUC_GNU_INLINE is not a good enough check for gcc because gcc versions
//    older than 4.3 may define these macros and still not guarantee GNU inlining
//    semantics.
//
//    clang++ identifies itself as gcc-4.2, but has support for GNU inlining
//    semantics, that can be checked for by using the __GNUC_STDC_INLINE_ and
//    __GNUC_GNU_INLINE__ macro definitions.

// GCC 4.3 and above allow passing all anonymous arguments of an
//    __extern_always_inline function to some other vararg function.

// It is possible to compile containing GCC extensions even if GCC is
//    run in pedantic mode if the uses are carefully marked using the
//    `__extension__' keyword.  But this is not generally available before
//    version 2.8.

// __restrict is known in EGCS 1.2 and above, and in clang.
//    It works also in C++ mode (outside of arrays), but only when spelled
//    as '__restrict', not 'restrict'.

// ISO C99 also allows to declare arrays as non-overlapping.  The syntax is
//      array_name[restrict]
//    GCC 3.1 and clang support this.
//    This syntax is not usable in C++ mode.

// Describes a char array whose address can safely be passed as the first
//    argument to strncpy and strncat, as the char array is not necessarily
//    a NUL-terminated string.

// Undefine (also defined in libc-symbols.h).
// Copies attributes from the declaration or type referenced by
//    the argument.

// Gnulib avoids including these, as they don't work on non-glibc or
//    older glibc platforms.
// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// __glibc_macro_warning (MESSAGE) issues warning MESSAGE.  This is
//    intended for use in preprocessor macros.
//
//    Note: MESSAGE must be a _single_ string; concatenation of string
//    literals is not supported.

// Generic selection (ISO C11) is a C-only feature, available in GCC
//    since version 4.9.  Previous versions do not provide generic
//    selection, even though they might set __STDC_VERSION__ to 201112L,
//    when in -std=c11 mode.  Thus, we must check for !defined __GNUC__
//    when testing __STDC_VERSION__ for generic selection support.
//    On the other hand, Clang also defines __GNUC__, so a clang-specific
//    check is required to enable the use of generic selection.

// Designates a 1-based positional argument ref-index of pointer type
//    that can be used to access size-index elements of the pointed-to
//    array according to access mode, or at least one element when
//    size-index is not provided:
//      access (access-mode, <ref-index> [, <size-index>])
// For _FORTIFY_SOURCE == 3 we use __builtin_dynamic_object_size, which may
//    use the access attribute to get object sizes from function definition
//    arguments, so we can't use them on functions we fortify.  Drop the object
//    size hints for such functions.

// Designates dealloc as a function to call to deallocate objects
//    allocated by the declared function.

// Specify that a function such as setjmp or vfork may return
//    twice.

// If we don't have __REDIRECT, prototypes will be missing if
//    __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].

// Decide whether we can define 'extern inline' functions in headers.

// This is here only because every header file already includes this one.
//    Get the definitions of all the appropriate `__stub_FUNCTION' symbols.
//    <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub
//    that will always return failure (and set errno to ENOSYS).
// This file is automatically generated.
//    This file selects the right generated file of `__stub_FUNCTION' macros
//    based on the architecture being compiled for.

// This file is automatically generated.
//    It defines a symbol `__stub_FUNCTION' for each function
//    in the C library which is a stub, meaning it will fail
//    every time called, usually setting errno to ENOSYS.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.
// Bit size of the time_t type at glibc build time, x86-64 and x32 case.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// For others, time size is word size.

// Convenience types.
type T__u_char = uint8   /* types.h:31:23 */
type T__u_short = uint16 /* types.h:32:28 */
type T__u_int = uint32   /* types.h:33:22 */
type T__u_long = uint64  /* types.h:34:27 */

// Fixed-size types, underlying types depend on word size and compiler.
type T__int8_t = int8     /* types.h:37:21 */
type T__uint8_t = uint8   /* types.h:38:23 */
type T__int16_t = int16   /* types.h:39:26 */
type T__uint16_t = uint16 /* types.h:40:28 */
type T__int32_t = int32   /* types.h:41:20 */
type T__uint32_t = uint32 /* types.h:42:22 */
type T__int64_t = int64   /* types.h:44:25 */
type T__uint64_t = uint64 /* types.h:45:27 */

// Smallest types with at least a given width.
type T__int_least8_t = int8     /* types.h:52:18 */
type T__uint_least8_t = uint8   /* types.h:53:19 */
type T__int_least16_t = int16   /* types.h:54:19 */
type T__uint_least16_t = uint16 /* types.h:55:20 */
type T__int_least32_t = int32   /* types.h:56:19 */
type T__uint_least32_t = uint32 /* types.h:57:20 */
type T__int_least64_t = int64   /* types.h:58:19 */
type T__uint_least64_t = uint64 /* types.h:59:20 */

// quad_t is also 64 bits.
type T__quad_t = int64    /* types.h:63:18 */
type T__u_quad_t = uint64 /* types.h:64:27 */

// Largest integral types.
type T__intmax_t = int64   /* types.h:72:18 */
type T__uintmax_t = uint64 /* types.h:73:27 */

// The machine-dependent file <bits/typesizes.h> defines __*_T_TYPE
//    macros for each of the OS types we define below.  The definitions
//    of those macros must use the following macros for underlying types.
//    We define __S<SIZE>_TYPE and __U<SIZE>_TYPE for the signed and unsigned
//    variants of each of the following integer types on this machine.
//
// 	16		-- "natural" 16-bit type (always short)
// 	32		-- "natural" 32-bit type (always int)
// 	64		-- "natural" 64-bit type (long or long long)
// 	LONG32		-- 32-bit type, traditionally long
// 	QUAD		-- 64-bit type, traditionally long long
// 	WORD		-- natural type of __WORDSIZE bits (int or long)
// 	LONGWORD	-- type of __WORDSIZE bits, traditionally long
//
//    We distinguish WORD/LONGWORD, 32/LONG32, and 64/QUAD so that the
//    conventional uses of `long' or `long long' type modifiers match the
//    types we define, even when a less-adorned type would be the same size.
//    This matters for (somewhat) portably writing printf/scanf formats for
//    these types, where using the appropriate l or ll format modifiers can
//    make the typedefs and the formats match up across all GNU platforms.  If
//    we used `long' when it's 64 bits where `long long' is expected, then the
//    compiler would warn about the formats not matching the argument types,
//    and the programmer changing them to shut up the compiler would break the
//    program's portability.
//
//    Here we assume what is presently the case in all the GCC configurations
//    we support: long long is always 64 bits, long is always word/address size,
//    and int is always 32 bits.

// No need to mark the typedef with __extension__.
// bits/typesizes.h -- underlying types for *_t.  Linux/x86-64 version.
//    Copyright (C) 2012-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// See <bits/types.h> for the meaning of these macros.  This file exists so
//    that <bits/types.h> need not vary across different GNU platforms.

// X32 kernel interface is 64-bit.

// Tell the libc code that off_t and off64_t are actually the same type
//    for all ABI purposes, even if possibly expressed as different base types
//    for C type-checking purposes.

// Same for ino_t and ino64_t.

// And for __rlim_t and __rlim64_t.

// And for fsblkcnt_t, fsblkcnt64_t, fsfilcnt_t and fsfilcnt64_t.

// And for getitimer, setitimer and rusage

// Number of descriptors that can fit in an `fd_set'.

// bits/time64.h -- underlying types for __time64_t.  Generic version.
//    Copyright (C) 2018-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define __TIME64_T_TYPE so that it is always a 64-bit type.

// If we already have 64-bit time type then use it.

type T__dev_t = uint64                     /* types.h:145:25 */ // Type of device numbers.
type T__uid_t = uint32                     /* types.h:146:25 */ // Type of user identifications.
type T__gid_t = uint32                     /* types.h:147:25 */ // Type of group identifications.
type T__ino_t = uint64                     /* types.h:148:25 */ // Type of file serial numbers.
type T__ino64_t = uint64                   /* types.h:149:27 */ // Type of file serial numbers (LFS).
type T__mode_t = uint32                    /* types.h:150:26 */ // Type of file attribute bitmasks.
type T__nlink_t = uint64                   /* types.h:151:27 */ // Type of file link counts.
type T__off_t = int64                      /* types.h:152:25 */ // Type of file sizes and offsets.
type T__off64_t = int64                    /* types.h:153:27 */ // Type of file sizes and offsets (LFS).
type T__pid_t = int32                      /* types.h:154:25 */ // Type of process identifications.
type T__fsid_t = struct{ F__val [2]int32 } /* types.h:155:26 */ // Type of file system IDs.
type T__clock_t = int64                    /* types.h:156:27 */ // Type of CPU usage counts.
type T__rlim_t = uint64                    /* types.h:157:26 */ // Type for resource measurement.
type T__rlim64_t = uint64                  /* types.h:158:28 */ // Type for resource measurement (LFS).
type T__id_t = uint32                      /* types.h:159:24 */ // General type for IDs.
type T__time_t = int64                     /* types.h:160:26 */ // Seconds since the Epoch.
type T__useconds_t = uint32                /* types.h:161:30 */ // Count of microseconds.
type T__suseconds_t = int64                /* types.h:162:31 */ // Signed count of microseconds.
type T__suseconds64_t = int64              /* types.h:163:33 */

type T__daddr_t = int32 /* types.h:165:27 */ // The type of a disk address.
type T__key_t = int32   /* types.h:166:25 */ // Type of an IPC key.

// Clock ID used in clock and timer functions.
type T__clockid_t = int32 /* types.h:169:29 */

// Timer ID returned by `timer_create'.
type T__timer_t = uintptr /* types.h:172:12 */

// Type to represent block size.
type T__blksize_t = int64 /* types.h:175:29 */

// Types from the Large File Support interface.

// Type to count number of disk blocks.
type T__blkcnt_t = int64   /* types.h:180:28 */
type T__blkcnt64_t = int64 /* types.h:181:30 */

// Type to count file system blocks.
type T__fsblkcnt_t = uint64   /* types.h:184:30 */
type T__fsblkcnt64_t = uint64 /* types.h:185:32 */

// Type to count file system nodes.
type T__fsfilcnt_t = uint64   /* types.h:188:30 */
type T__fsfilcnt64_t = uint64 /* types.h:189:32 */

// Type of miscellaneous file system fields.
type T__fsword_t = int64 /* types.h:192:28 */

type T__ssize_t = int64 /* types.h:194:27 */ // Type of a byte count, or error.

// Signed long type used in system calls.
type T__syscall_slong_t = int64 /* types.h:197:33 */
// Unsigned long type used in system calls.
type T__syscall_ulong_t = uint64 /* types.h:199:33 */

// These few don't really vary by system, they always correspond
//
//	to one of the other defined types.
type T__loff_t = int64    /* types.h:203:19 */ // Type of file sizes and offsets (LFS).
type T__caddr_t = uintptr /* types.h:204:14 */

// Duplicates info from stdint.h but this is used in unistd.h.
type T__intptr_t = int64 /* types.h:207:25 */

// Duplicate info from sys/socket.h.
type T__socklen_t = uint32 /* types.h:210:23 */

// C99: An integer type that can be accessed as an atomic entity,
//
//	even in the presence of asynchronous interrupts.
//	It is not currently necessary for this to be machine-specific.
type T__sig_atomic_t = int32 /* types.h:215:13 */

// Seconds since the Epoch, visible to user code when time_t is too
//    narrow only for consistency with the old way of widening too-narrow
//    types.  User code should never use __time64_t.

// wchar_t type related definitions.
//    Copyright (C) 2000-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// The fallback definitions, for when __WCHAR_MAX__ or __WCHAR_MIN__
//    are not defined, give the right value and type as long as both int
//    and wchar_t are 32-bit types.  Adding L'\0' to a constant value
//    ensures that the type is correct; it is necessary to use (L'\0' +
//    0) rather than just L'\0' so that the type in C++ is the promoted
//    version of wchar_t rather than the distinct wchar_t type itself.
//    Because wchar_t in preprocessor #if expressions is treated as
//    intmax_t or uintmax_t, the expression (L'\0' - 1) would have the
//    wrong value for WCHAR_MAX in such expressions and so cannot be used
//    to define __WCHAR_MAX in the unsigned case.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Exact integral types.

// Signed.
// Define intN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tint8_t = int8   /* stdint-intn.h:24:18 */
type Tint16_t = int16 /* stdint-intn.h:25:19 */
type Tint32_t = int32 /* stdint-intn.h:26:19 */
type Tint64_t = int64 /* stdint-intn.h:27:19 */

// Unsigned.
// Define uintN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tuint8_t = uint8   /* stdint-uintn.h:24:19 */
type Tuint16_t = uint16 /* stdint-uintn.h:25:20 */
type Tuint32_t = uint32 /* stdint-uintn.h:26:20 */
type Tuint64_t = uint64 /* stdint-uintn.h:27:20 */

// Small types.

// Signed.
type Tint_least8_t = int8   /* stdint.h:43:24 */
type Tint_least16_t = int16 /* stdint.h:44:25 */
type Tint_least32_t = int32 /* stdint.h:45:25 */
type Tint_least64_t = int64 /* stdint.h:46:25 */

// Unsigned.
type Tuint_least8_t = uint8   /* stdint.h:49:25 */
type Tuint_least16_t = uint16 /* stdint.h:50:26 */
type Tuint_least32_t = uint32 /* stdint.h:51:26 */
type Tuint_least64_t = uint64 /* stdint.h:52:26 */

// Fast types.

// Signed.
type Tint_fast8_t = int8   /* stdint.h:58:22 */
type Tint_fast16_t = int64 /* stdint.h:60:19 */
type Tint_fast32_t = int64 /* stdint.h:61:19 */
type Tint_fast64_t = int64 /* stdint.h:62:19 */

// Unsigned.
type Tuint_fast8_t = uint8   /* stdint.h:71:24 */
type Tuint_fast16_t = uint64 /* stdint.h:73:27 */
type Tuint_fast32_t = uint64 /* stdint.h:74:27 */
type Tuint_fast64_t = uint64 /* stdint.h:75:27 */

// Types for `void *' pointers.
type Tintptr_t = int64   /* stdint.h:87:19 */
type Tuintptr_t = uint64 /* stdint.h:90:27 */

// Largest integral types.
type Tintmax_t = int64   /* stdint.h:101:21 */
type Tuintmax_t = uint64 /* stdint.h:102:22 */

// A null pointer constant.

// XPG requires a few symbols from <sys/wait.h> being defined.
// Definitions of flag bits for `waitpid' et al.
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Bits in the third argument to `waitpid'.

// Bits in the fourth argument to `waitid'.

// Definitions of status bits for `wait' et al.
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Everything extant so far uses these same bits.

// If WIFEXITED(STATUS), the low-order 8 bits of the status.

// If WIFSIGNALED(STATUS), the terminating signal.

// If WIFSTOPPED(STATUS), the signal that stopped the child.

// Nonzero if STATUS indicates normal termination.

// Nonzero if STATUS indicates termination by a signal.

// Nonzero if STATUS indicates the child is stopped.

// Nonzero if STATUS indicates the child continued after a stop.  We only
//    define this if <bits/waitflags.h> provides the WCONTINUED flag bit.

// Nonzero if STATUS indicates the child dumped core.

// Macros for constructing status values.

// Define the macros <sys/wait.h> also would define this way.

// _FloatN API tests for enablement.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the IEEE 754 binary128 format, and this
//    glibc includes corresponding *f128 interfaces for it.  The required
//    libgcc support was added some time after the basic compiler
//    support, for x86_64 and x86.

// Defined to 1 if __HAVE_FLOAT128 is 1 and the type is ABI-distinct
//    from the default float, double and long double types in this glibc.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for _Float64x, and this
//    glibc includes corresponding *f64x interfaces for it.

// Defined to 1 if __HAVE_FLOAT64X is 1 and _Float64x has the format
//    of long double.  Otherwise, if __HAVE_FLOAT64X is 1, _Float64x has
//    the format of _Float128, which must be different from that of long
//    double.

// Defined to concatenate the literal suffix to be used with _Float128
//    types, if __HAVE_FLOAT128 is 1.

// Defined to a complex binary128 type if __HAVE_FLOAT128 is 1.

// The remaining of this file provides support for older compilers.

// The type _Float128 exists only since GCC 7.0.

// __builtin_huge_valf128 doesn't exist before GCC 7.0.

// Older GCC has only a subset of built-in functions for _Float128 on
//    x86, and __builtin_infq is not usable in static initializers.
//    Converting a narrower sNaN to _Float128 produces a quiet NaN, so
//    attempts to use _Float128 sNaNs will not work properly with older
//    compilers.

// In math/math.h, __MATH_TG will expand signbit to __builtin_signbit*,
//    e.g.: __builtin_signbitf128, before GCC 6.  However, there has never
//    been a __builtin_signbitf128 in GCC and the type-generic builtin is
//    only available since GCC 6.

// Macros to control TS 18661-3 glibc features where the same
//    definitions are appropriate for all platforms.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Properties of long double type.  ldbl-96 version.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License  published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// long double is distinct from double, so there is nothing to
//    define here.

// This header should be included at the bottom of each bits/floatn.h.
//    It defines the following macros for each _FloatN and _FloatNx type,
//    where the same definitions, or definitions based only on the macros
//    in bits/floatn.h, are appropriate for all glibc configurations.

// Defined to 1 if the current compiler invocation provides a
//    floating-point type with the right format for this type, and this
//    glibc includes corresponding *fN or *fNx interfaces for it.

// Defined to 1 if the corresponding __HAVE_<type> macro is 1 and the
//    type is the first with its format in the sequence of (the default
//    choices for) float, double, long double, _Float16, _Float32,
//    _Float64, _Float128, _Float32x, _Float64x, _Float128x for this
//    glibc; that is, if functions present once per floating-point format
//    rather than once per type are present for this type.
//
//    All configurations supported by glibc have _Float32 the same format
//    as float, _Float64 and _Float32x the same format as double, the
//    _Float64x the same format as either long double or _Float128.  No
//    configurations support _Float128x or, as of GCC 7, have compiler
//    support for a type meeting the requirements for _Float128x.

// Defined to 1 if the corresponding _FloatN type is not binary compatible
//    with the corresponding ISO C type in the current compilation unit as
//    opposed to __HAVE_DISTINCT_FLOATN, which indicates the default types built
//    in glibc.

// Defined to 1 if any _FloatN or _FloatNx types that are not
//    ABI-distinct are however distinct types at the C language level (so
//    for the purposes of __builtin_types_compatible_p and _Generic).

// Defined to concatenate the literal suffix to be used with _FloatN
//    or _FloatNx types, if __HAVE_<type> is 1.  The corresponding
//    literal suffixes exist since GCC 7, for C only.

// Defined to a complex type if __HAVE_<type> is 1.

// The remaining of this file provides support for older compilers.

// If double, long double and _Float64 all have the same set of
//    values, TS 18661-3 requires the usual arithmetic conversions on
//    long double and _Float64 to produce _Float64.  For this to be the
//    case when building with a compiler without a distinct _Float64
//    type, _Float64 must be a typedef for long double, not for
//    double.

// Returned by `div'.
type Tdiv_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:63:5 */

// Returned by `ldiv'.
type Tldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:71:5 */

// Returned by `lldiv'.
type Tlldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:81:5 */

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX Standard: 2.6 Primitive System Data Types	<sys/types.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

type Tu_char = uint8     /* types.h:33:18 */
type Tu_short = uint16   /* types.h:34:19 */
type Tu_int = uint32     /* types.h:35:17 */
type Tu_long = uint64    /* types.h:36:18 */
type Tquad_t = int64     /* types.h:37:18 */
type Tu_quad_t = uint64  /* types.h:38:20 */
type Tfsid_t = T__fsid_t /* types.h:39:18 */
type Tloff_t = int64     /* types.h:42:18 */

type Tino_t = uint64 /* types.h:49:19 */

type Tdev_t = uint64 /* types.h:59:17 */

type Tgid_t = uint32 /* types.h:64:17 */

type Tmode_t = uint32 /* types.h:69:18 */

type Tnlink_t = uint64 /* types.h:74:19 */

type Tuid_t = uint32 /* types.h:79:17 */

type Toff_t = int64 /* types.h:87:19 */

type Tpid_t = int32 /* types.h:97:17 */

type Tid_t = uint32 /* types.h:103:16 */

type Tssize_t = int64 /* types.h:108:19 */

type Tdaddr_t = int32   /* types.h:114:19 */
type Tcaddr_t = uintptr /* types.h:115:19 */

type Tkey_t = int32 /* types.h:121:17 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `clock'.
type Tclock_t = int64 /* clock_t.h:7:19 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Clock ID used in clock and timer functions.
type Tclockid_t = int32 /* clockid_t.h:7:21 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Returned by `time'.
type Ttime_t = int64 /* time_t.h:10:18 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Timer ID returned by `timer_create'.
type Ttimer_t = uintptr /* timer_t.h:7:19 */

// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Old compatibility names for C types.
type Tulong = uint64  /* types.h:148:27 */
type Tushort = uint16 /* types.h:149:28 */
type Tuint = uint32   /* types.h:150:22 */

// These size-specific names are used by some of the inet code.

// Define intN_t types.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// These were defined by ISO C without the first `_'.
type Tu_int8_t = uint8   /* types.h:158:19 */
type Tu_int16_t = uint16 /* types.h:159:20 */
type Tu_int32_t = uint32 /* types.h:160:20 */
type Tu_int64_t = uint64 /* types.h:161:20 */

type Tregister_t = int32 /* types.h:164:13 */

// It also defines `fd_set' and the FD_* macros for `select'.
// `fd_set' type and related macros, and `select'/`pselect' declarations.
//    Copyright (C) 1996-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	POSIX 1003.1g: 6.2 Select from File Descriptor Sets <sys/select.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get definition of needed basic types.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get __FD_* definitions.
// Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// We don't use `memset' because this would require a prototype and
//    the array isn't too big.

// Get sigset_t.

type T__sigset_t = struct{ F__val [16]uint64 } /* __sigset_t.h:8:3 */

// A set of signals to be blocked, unblocked, or waited for.
type Tsigset_t = T__sigset_t /* sigset_t.h:7:20 */

// Get definition of timer specification structures.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// A time value that is accurate to the nearest
//
//	microsecond but also has a range of years.
type Stimeval = struct {
	Ftv_sec  int64
	Ftv_usec int64
} /* struct_timeval.h:8:1 */

// NB: Include guard matches what <linux/time.h> uses.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Endian macros for string.h functions
//    Copyright (C) 1992-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

// POSIX.1b structure for a time value.  This is like a `struct timeval' but
//
//	has nanoseconds instead of microseconds.
type Stimespec = struct {
	Ftv_sec  int64
	Ftv_nsec int64
} /* struct_timespec.h:11:1 */

type Tsuseconds_t = int64 /* select.h:43:23 */

// The fd_set member is required to be an array of longs.
type T__fd_mask = int64 /* select.h:49:18 */

// Some versions of <linux/posix_types.h> define this macros.
// It's easier to assume 8-bit bytes than to get CHAR_BIT.

// fd_set for select and pselect.
type Tfd_set = struct{ F__fds_bits [16]int64 } /* select.h:70:5 */

// Maximum number of file descriptors in `fd_set'.

// Sometimes the fd_set member is assumed to have this type.
type Tfd_mask = int64 /* select.h:77:19 */

// Define some inlines helping to catch common problems.

type Tblksize_t = int64 /* types.h:185:21 */

// Types from the Large File Support interface.
type Tblkcnt_t = int64    /* types.h:205:22 */ // Type to count number of disk blocks.
type Tfsblkcnt_t = uint64 /* types.h:209:24 */ // Type to count file system blocks.
type Tfsfilcnt_t = uint64 /* types.h:213:24 */ // Type to count file system inodes.

// Now add the thread types.
// Declaration of common pthread types for all architectures.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// For internal mutex and condition variable definitions.
// Common threading primitives definitions for both POSIX and C11.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Arch-specific definitions.  Each architecture must define the following
//    macros to define the expected sizes of pthread data types:
//
//    __SIZEOF_PTHREAD_ATTR_T        - size of pthread_attr_t.
//    __SIZEOF_PTHREAD_MUTEX_T       - size of pthread_mutex_t.
//    __SIZEOF_PTHREAD_MUTEXATTR_T   - size of pthread_mutexattr_t.
//    __SIZEOF_PTHREAD_COND_T        - size of pthread_cond_t.
//    __SIZEOF_PTHREAD_CONDATTR_T    - size of pthread_condattr_t.
//    __SIZEOF_PTHREAD_RWLOCK_T      - size of pthread_rwlock_t.
//    __SIZEOF_PTHREAD_RWLOCKATTR_T  - size of pthread_rwlockattr_t.
//    __SIZEOF_PTHREAD_BARRIER_T     - size of pthread_barrier_t.
//    __SIZEOF_PTHREAD_BARRIERATTR_T - size of pthread_barrierattr_t.
//
//    The additional macro defines any constraint for the lock alignment
//    inside the thread structures:
//
//    __LOCK_ALIGNMENT - for internal lock/futex usage.
//
//    Same idea but for the once locking primitive:
//
//    __ONCE_ALIGNMENT - for pthread_once_t/once_flag definition.

// Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Determine the wordsize from the preprocessor defines.

// Both x86-64 and x32 use the 64-bit system call interface.

// Monotonically increasing wide counters (at least 62 bits).
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Counter that is monotonically increasing (by less than 2**31 per
//
//	increment), with a single writer, and an arbitrary number of
//	readers.
type T__atomic_wide_counter = struct{ F__value64 uint64 } /* atomic_wide_counter.h:33:3 */

// Common definition of pthread_mutex_t.

type S__pthread_internal_list = struct {
	F__prev uintptr
	F__next uintptr
} /* thread-shared-types.h:51:9 */

// Common definition of pthread_mutex_t.

type T__pthread_list_t = S__pthread_internal_list /* thread-shared-types.h:55:3 */

type S__pthread_internal_slist = struct{ F__next uintptr } /* thread-shared-types.h:57:9 */

type T__pthread_slist_t = S__pthread_internal_slist /* thread-shared-types.h:60:3 */

// Arch-specific mutex definitions.  A generic implementation is provided
//    by sysdeps/nptl/bits/struct_mutex.h.  If required, an architecture
//    can override it by defining:
//
//    1. struct __pthread_mutex_s (used on both pthread_mutex_t and mtx_t
//       definition).  It should contains at least the internal members
//       defined in the generic version.
//
//    2. __LOCK_ALIGNMENT for any extra attribute for internal lock used with
//       atomic operations.
//
//    3. The macro __PTHREAD_MUTEX_INITIALIZER used for static initialization.
//       It should initialize the mutex internal flag.

// x86 internal mutex struct definitions.
//    Copyright (C) 2019-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_mutex_s = struct {
	F__lock    int32
	F__count   uint32
	F__owner   int32
	F__nusers  uint32
	F__kind    int32
	F__spins   int16
	F__elision int16
	F__list    T__pthread_list_t
} /* struct_mutex.h:22:1 */

// Arch-sepecific read-write lock definitions.  A generic implementation is
//    provided by struct_rwlock.h.  If required, an architecture can override it
//    by defining:
//
//    1. struct __pthread_rwlock_arch_t (used on pthread_rwlock_t definition).
//       It should contain at least the internal members defined in the
//       generic version.
//
//    2. The macro __PTHREAD_RWLOCK_INITIALIZER used for static initialization.
//       It should initialize the rwlock internal type.

// x86 internal rwlock struct definitions.
//    Copyright (C) 2019-2022 Free Software Foundation, Inc.
//
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <http://www.gnu.org/licenses/>.

type S__pthread_rwlock_arch_t = struct {
	F__readers       uint32
	F__writers       uint32
	F__wrphase_futex uint32
	F__writers_futex uint32
	F__pad3          uint32
	F__pad4          uint32
	F__cur_writer    int32
	F__shared        int32
	F__rwelision     int8
	F__pad1          [7]uint8
	F__pad2          uint64
	F__flags         uint32
	F__ccgo_pad1     [4]byte
} /* struct_rwlock.h:23:1 */

// Common definition of pthread_cond_t.

type S__pthread_cond_s = struct {
	F__wseq         T__atomic_wide_counter
	F__g1_start     T__atomic_wide_counter
	F__g_refs       [2]uint32
	F__g_size       [2]uint32
	F__g1_orig_size uint32
	F__wrefs        uint32
	F__g_signals    [2]uint32
} /* thread-shared-types.h:94:1 */

type T__tss_t = uint32  /* thread-shared-types.h:105:22 */
type T__thrd_t = uint64 /* thread-shared-types.h:106:27 */

type T__once_flag = struct{ F__data int32 } /* thread-shared-types.h:111:3 */

// Thread identifiers.  The structure of the attribute type is not
//
//	exposed on purpose.
type Tpthread_t = uint64 /* pthreadtypes.h:27:27 */

// Data structures for mutex handling.  The structure of the attribute
//
//	type is not exposed on purpose.
type Tpthread_mutexattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:36:3 */

// Data structure for condition variable handling.  The structure of
//
//	the attribute type is not exposed on purpose.
type Tpthread_condattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:45:3 */

// Keys for thread-specific data
type Tpthread_key_t = uint32 /* pthreadtypes.h:49:22 */

// Once-only execution
type Tpthread_once_t = int32 /* pthreadtypes.h:53:30 */

type Spthread_attr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [56]int8
} /* pthreadtypes.h:56:1 */

type Tpthread_attr_t = Spthread_attr_t /* pthreadtypes.h:62:30 */

type Tpthread_mutex_t = struct{ F__data S__pthread_mutex_s } /* pthreadtypes.h:72:3 */

type Tpthread_cond_t = struct{ F__data S__pthread_cond_s } /* pthreadtypes.h:80:3 */

// Data structure for reader-writer lock variable handling.  The
//
//	structure of the attribute type is deliberately not exposed.
type Tpthread_rwlock_t = struct{ F__data S__pthread_rwlock_arch_t } /* pthreadtypes.h:91:3 */

type Tpthread_rwlockattr_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [8]int8
} /* pthreadtypes.h:97:3 */

// POSIX spinlock data type.
type Tpthread_spinlock_t = int32 /* pthreadtypes.h:103:22 */

// POSIX barriers data type.  The structure of the type is
//
//	deliberately not exposed.
type Tpthread_barrier_t = struct {
	F__ccgo_pad1 [0]uint64
	F__size      [32]int8
} /* pthreadtypes.h:112:3 */

type Tpthread_barrierattr_t = struct {
	F__ccgo_pad1 [0]uint32
	F__size      [4]int8
} /* pthreadtypes.h:118:3 */

// Reentrant versions of the `random' family of functions.
//    These functions all use the following data structure to contain
//    state, rather than global state variables.

type Srandom_data = struct {
	Ffptr        uintptr
	Frptr        uintptr
	Fstate       uintptr
	Frand_type   int32
	Frand_deg    int32
	Frand_sep    int32
	F__ccgo_pad1 [4]byte
	Fend_ptr     uintptr
} /* stdlib.h:424:1 */

// Data structure for communication with thread safe versions.  This
//
//	type is to be regarded as opaque.  It's only exported because users
//	have to allocate objects of this type.
type Sdrand48_data = struct {
	F__x     [3]uint16
	F__old_x [3]uint16
	F__c     uint16
	F__init  uint16
	F__a     uint64
} /* stdlib.h:491:1 */

// Shorthand for type of comparison functions.
type T__compar_fn_t = uintptr /* stdlib.h:816:13 */

// Floating-point inline functions for stdlib.h.
//    Copyright (C) 2012-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define some macros helping to catch buffer overflows.

// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// H3 is compiled as C, not C++ code. `extern "C"` is needed for C++ code
// to be able to use the library.

// * @brief Identifier for an object (cell, edge, etc) in the H3 system.
//
// The H3Index fits within a 64-bit unsigned integer.
type TH3Index = uint64 /* h3api.h:69:18 */

// *
// Invalid index used to indicate an error from latLngToCell and related
// functions or missing data in arrays of H3 indices. Analogous to NaN in
// floating point.

// * @brief Result code (success or specific error) from an H3 operation
type TH3Error = uint32 /* h3api.h:79:18 */

type TH3ErrorCodes = uint32 /* h3api.h:105:3 */
//* @}

// library version numbers generated from VERSION file
// clang-format off
// clang-format on

// * Maximum number of cell boundary vertices; worst case is pentagon:
//  5 original verts + 5 edge crossings

//   - @struct LatLng
//     @brief latitude/longitude in radians
type TLatLng = struct {
	Flat float64
	Flng float64
} /* h3api.h:133:3 */

//   - @struct CellBoundary
//     @brief cell boundary in latitude/longitude
type TCellBoundary = struct {
	FnumVerts    int32
	F__ccgo_pad1 [4]byte
	Fverts       [10]TLatLng
} /* h3api.h:141:3 */

//   - @struct GeoLoop
//     @brief similar to CellBoundary, but requires more alloc work
type TGeoLoop = struct {
	FnumVerts    int32
	F__ccgo_pad1 [4]byte
	Fverts       uintptr
} /* h3api.h:149:3 */

//   - @struct GeoPolygon
//     @brief Simplified core of GeoJSON Polygon coordinates definition
type TGeoPolygon = struct {
	Fgeoloop     TGeoLoop
	FnumHoles    int32
	F__ccgo_pad1 [4]byte
	Fholes       uintptr
} /* h3api.h:158:3 */

//   - @struct GeoMultiPolygon
//     @brief Simplified core of GeoJSON MultiPolygon coordinates definition
type TGeoMultiPolygon = struct {
	FnumPolygons int32
	F__ccgo_pad1 [4]byte
	Fpolygons    uintptr
} /* h3api.h:166:3 */

//   - @struct LinkedLatLng
//     @brief A coordinate node in a linked geo structure, part of a linked list
type SLinkedLatLng = struct {
	Fvertex TLatLng
	Fnext   uintptr
} /* h3api.h:171:9 */

//   - @struct LinkedLatLng
//     @brief A coordinate node in a linked geo structure, part of a linked list
type TLinkedLatLng = SLinkedLatLng /* h3api.h:171:29 */

//   - @struct LinkedGeoLoop
//     @brief A loop node in a linked geo structure, part of a linked list
type SLinkedGeoLoop = struct {
	Ffirst uintptr
	Flast  uintptr
	Fnext  uintptr
} /* h3api.h:180:9 */

//   - @struct LinkedGeoLoop
//     @brief A loop node in a linked geo structure, part of a linked list
type TLinkedGeoLoop = SLinkedGeoLoop /* h3api.h:180:30 */

//   - @struct LinkedGeoPolygon
//     @brief A polygon node in a linked geo structure, part of a linked list.
type SLinkedGeoPolygon = struct {
	Ffirst uintptr
	Flast  uintptr
	Fnext  uintptr
} /* h3api.h:190:9 */

//   - @struct LinkedGeoPolygon
//     @brief A polygon node in a linked geo structure, part of a linked list.
type TLinkedGeoPolygon = SLinkedGeoPolygon /* h3api.h:190:33 */

// * @struct CoordIJ
// @brief IJ hexagon coordinates
//
// Each axis is spaced 120 degrees apart.
type TCoordIJ = struct {
	Fi int32
	Fj int32
} /* h3api.h:205:3 */
//* @}

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.17  Common definitions  <stddef.h>

// Any one of these symbols __need_* means that GNU libc
//    wants us just to define one data type.  So don't define
//    the symbols that indicate this file's entire job has been done.

// This avoids lossage on SunOS but only if stdtypes.h comes first.
//    There's no way to win with the other order!  Sun lossage.

// Sequent's header files use _PTRDIFF_T_ in some conflicting way.
//    Just ignore it.

// On VxWorks, <type/vxTypesBase.h> may have defined macros like
//    _TYPE_size_t which will typedef size_t.  fixincludes patched the
//    vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is
//    not defined, and so that defining this macro defines _GCC_SIZE_T.
//    If we find that the macros are still defined at this point, we must
//    invoke them so that the type is defined as expected.

// In case nobody has defined these types, but we aren't running under
//    GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE_TYPE__, and
//    __WCHAR_TYPE__ have reasonable values.  This can happen if the
//    parts of GCC is compiled by an older compiler, that actually
//    include gstddef.h, such as collect2.

// Signed type of difference of two pointers.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Unsigned type of `sizeof' something.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// Wide character type.
//    Locale-writers should change this as necessary to
//    be big enough to hold unique values not between 0 and 127,
//    and not (wchar_t) -1, for each defined multibyte character.

// Define this type if we are doing the whole job,
//    or if we want this type in particular.

// A null pointer constant.

// Copyright (C) 1989-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// Define __gnuc_va_list.

type T__gnuc_va_list = uintptr /* stdarg.h:40:27 */

// Define the standard macros for the user,
//    if this invocation was from the user program.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Integral type unchanged by default argument promotions that can
//    hold any value corresponding to members of the extended character
//    set, as well as at least one value that does not correspond to any
//    member of the extended character set.

// Conversion state information.
type T__mbstate_t = struct {
	F__count int32
	F__value struct{ F__wch uint32 }
} /* __mbstate_t.h:21:3 */

// The tag name of this struct is _G_fpos_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t arguments.
//	That name should not be used in new code.
type S_G_fpos_t = struct {
	F__pos   int64
	F__state T__mbstate_t
} /* __fpos_t.h:10:9 */

// The tag name of this struct is _G_fpos_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t arguments.
//	That name should not be used in new code.
type T__fpos_t = S_G_fpos_t /* __fpos_t.h:14:3 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t and/or fpos64_t
//	arguments.  That name should not be used in new code.
type S_G_fpos64_t = struct {
	F__pos   int64
	F__state T__mbstate_t
} /* __fpos64_t.h:10:9 */

// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// The tag name of this struct is _G_fpos64_t to preserve historic
//
//	C++ mangled names for functions taking fpos_t and/or fpos64_t
//	arguments.  That name should not be used in new code.
type T__fpos64_t = S_G_fpos64_t /* __fpos64_t.h:14:3 */

type S_IO_FILE = struct {
	F_flags          int32
	F__ccgo_pad1     [4]byte
	F_IO_read_ptr    uintptr
	F_IO_read_end    uintptr
	F_IO_read_base   uintptr
	F_IO_write_base  uintptr
	F_IO_write_ptr   uintptr
	F_IO_write_end   uintptr
	F_IO_buf_base    uintptr
	F_IO_buf_end     uintptr
	F_IO_save_base   uintptr
	F_IO_backup_base uintptr
	F_IO_save_end    uintptr
	F_markers        uintptr
	F_chain          uintptr
	F_fileno         int32
	F_flags2         int32
	F_old_offset     int64
	F_cur_column     uint16
	F_vtable_offset  int8
	F_shortbuf       [1]int8
	F__ccgo_pad2     [4]byte
	F_lock           uintptr
	F_offset         int64
	F_codecvt        uintptr
	F_wide_data      uintptr
	F_freeres_list   uintptr
	F_freeres_buf    uintptr
	F__pad5          uint64
	F_mode           int32
	F_unused2        [20]int8
} /* __FILE.h:4:1 */

type T__FILE = S_IO_FILE /* __FILE.h:5:25 */

// The opaque type of streams.  This is the definition used elsewhere.
type TFILE = S_IO_FILE /* FILE.h:7:25 */

// These macros are used by bits/stdio.h and internal headers.

// Many more flag bits are defined internally.

type Tva_list = uintptr /* stdio.h:52:24 */

// The type of the second argument to `fgetpos' and `fsetpos'.
type Tfpos_t = T__fpos64_t /* stdio.h:86:20 */

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Copyright 2016-2017, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

//* pi

//* pi / 2.0

//* 2.0 * PI

//* pi / 180
//* 180 / pi

//* threshold epsilon
//* sqrt(3) / 2.0
//* sin(60')
//* 1/sin(60') *

//* one third *

//* one seventh (1/7) *

// * rotation angle between Class II and Class III resolution axes
// (asin(sqrt(3.0 / 28.0)))

//* sin(M_AP7_ROT_RADS)

//* cos(M_AP7_ROT_RADS)

//* earth radius in kilometers using WGS84 authalic radius

// * scaling factor from hex2d resolution 0 unit length
// (or distance between adjacent cell center points
// on the plane) to gnomonic unit length.

//* max H3 resolution; H3 version 1 has 16 resolutions, numbered 0 through 15

//* The number of faces on an icosahedron
//* The number of H3 base cells
//* The number of vertices in a hexagon
//* The number of vertices in a pentagon
//* The number of pentagons per resolution *

//* H3 index modes

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

//* epsilon of ~0.1mm in degrees
//* epsilon of ~0.1mm in radians

type TLongitudeNormalization = uint32 /* latLng.h:39:3 */

//   - @struct BBox
//     @brief  Geographic bounding box with coordinates defined in radians
type TBBox = struct {
	Fnorth float64
	Fsouth float64
	Feast  float64
	Fwest  float64
} /* bbox.h:36:3 */

// Copyright 2016-2018, 2020-2022 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lng
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec2d.h
// @brief   2D floating point vector functions.

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

//   - @struct Vec2d
//     @brief 2D floating-point vector
type TVec2d = struct {
	Fx float64
	Fy float64
} /* vec2d.h:31:3 */

// * @struct CoordIJK
// @brief IJK hexagon coordinates
//
// Each axis is spaced 120 degrees apart.
type TCoordIJK = struct {
	Fi int32
	Fj int32
	Fk int32
} /* coordijk.h:46:3 */

// * @brief H3 digit representing ijk+ axes direction.
// Values will be within the lowest 3 bits of an integer.
type TDirection = uint32 /* coordijk.h:85:3 */

// Copyright 2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

//   - @struct VertexNode
//     @brief A single node in a vertex graph, part of a linked list
type SVertexNode = struct {
	Ffrom TLatLng
	Fto   TLatLng
	Fnext uintptr
} /* vertexGraph.h:31:9 */

// Copyright 2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

//   - @struct VertexNode
//     @brief A single node in a vertex graph, part of a linked list
type TVertexNode = SVertexNode /* vertexGraph.h:31:27 */

//   - @struct VertexGraph
//     @brief A data structure to store a graph of vertices
type TVertexGraph = struct {
	Fbuckets     uintptr
	FnumBuckets  int32
	Fsize        int32
	Fres         int32
	F__ccgo_pad1 [4]byte
} /* vertexGraph.h:46:3 */

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// Copyright (C) 2002-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>

// Radix of exponent representation, b.

// Number of base-FLT_RADIX digits in the significand, p.

// Number of decimal digits, q, such that any floating-point number with q
//    decimal digits can be rounded into a floating-point number with p radix b
//    digits and back again without change to the q decimal digits,
//
// 	p * log10(b)			if b is a power of 10
// 	floor((p - 1) * log10(b))	otherwise

// Minimum int x such that FLT_RADIX**(x-1) is a normalized float, emin

// Minimum negative integer such that 10 raised to that power is in the
//    range of normalized floating-point numbers,
//
// 	ceil(log10(b) * (emin - 1))

// Maximum int x such that FLT_RADIX**(x-1) is a representable float, emax.

// Maximum integer such that 10 raised to that power is in the range of
//    representable finite floating-point numbers,
//
// 	floor(log10((1 - b**-p) * b**emax))

// Maximum representable finite floating-point number,
//
// 	(1 - b**-p) * b**emax

// The difference between 1 and the least value greater than 1 that is
//    representable in the given floating point type, b**1-p.

// Minimum normalized positive floating-point number, b**(emin - 1).

// Addition rounds to 0: zero, 1: nearest, 2: +inf, 3: -inf, -1: unknown.
// ??? This is supposed to change with calls to fesetround in <fenv.h>.

// The floating-point expression evaluation method.  The precise
//    definitions of these values are generalised to include support for
//    the interchange and extended types defined in ISO/IEC TS 18661-3.
//    Prior to this (for C99/C11) the definitions were:
//
// 	-1  indeterminate
// 	 0  evaluate all operations and constants just to the range and
// 	    precision of the type
// 	 1  evaluate operations and constants of type float and double
// 	    to the range and precision of the double type, evaluate
// 	    long double operations and constants to the range and
// 	    precision of the long double type
// 	 2  evaluate all operations and constants to the range and
// 	    precision of the long double type
//
//    The TS 18661-3 definitions are:
//
// 	-1  indeterminate
// 	 0  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of float, to the range and
// 	    precision of float; evaluate all other operations and constants
// 	    to the range and precision of the semantic type.
// 	 1  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of double, to the range and
// 	    precision of double; evaluate all other operations and constants
// 	    to the range and precision of the semantic type.
// 	 2  evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of long double, to the range and
// 	    precision of long double; evaluate all other operations and
// 	    constants to the range and precision of the semantic type.
// 	 N  where _FloatN  is a supported interchange floating type
// 	    evaluate all operations and constants, whose semantic type has
// 	    at most the range and precision of the _FloatN type, to the
// 	    range and precision of the _FloatN type; evaluate all other
// 	    operations and constants to the range and precision of the
// 	    semantic type.
// 	 N + 1, where _FloatNx is a supported extended floating type
// 	    evaluate operations and constants, whose semantic type has at
// 	    most the range and precision of the _FloatNx type, to the range
// 	    and precision of the _FloatNx type; evaluate all other
// 	    operations and constants to the range and precision of the
// 	    semantic type.
//
//    The compiler predefines two macros:
//
//       __FLT_EVAL_METHOD__
//       Which, depending on the value given for
//       -fpermitted-flt-eval-methods, may be limited to only those values
//       for FLT_EVAL_METHOD defined in C99/C11.
//
//      __FLT_EVAL_METHOD_TS_18661_3__
//       Which always permits the values for FLT_EVAL_METHOD defined in
//       ISO/IEC TS 18661-3.
//
//      Here we want to use __FLT_EVAL_METHOD__, unless
//      __STDC_WANT_IEC_60559_TYPES_EXT__ is defined, in which case the user
//      is specifically asking for the ISO/IEC TS 18661-3 types, so we use
//      __FLT_EVAL_METHOD_TS_18661_3__.
//
//    ??? This ought to change with the setting of the fp control word;
//    the value provided by the compiler assumes the widest setting.

// Number of decimal digits, n, such that any floating-point number in the
//    widest supported floating type with pmax radix b digits can be rounded
//    to a floating-point number with n decimal digits and back again without
//    change to the value,
//
// 	pmax * log10(b)			if b is a power of 10
// 	ceil(1 + pmax * log10(b))	otherwise

// Versions of DECIMAL_DIG for each floating-point type.

// Whether types support subnormal numbers.

// Minimum positive values, including subnormals.

// Declarations for math functions.
//    Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Handle feature test macros at the start of a header.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// This header is internal to glibc and should not be included outside
//    of glibc headers.  Headers including it must define
//    __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION first.  This header
//    cannot have multiple include guards because ISO C feature test
//    macros depend on the definition of the macro when an affected
//    header is included, not when the first system header is
//    included.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// ISO/IEC TR 24731-2:2010 defines the __STDC_WANT_LIB_EXT2__
//    macro.

// ISO/IEC TS 18661-1:2014 defines the __STDC_WANT_IEC_60559_BFP_EXT__
//    macro.  Most but not all symbols enabled by that macro in TS
//    18661-1 are enabled unconditionally in C2X.  In C2X, the symbols in
//    Annex F still require a new feature test macro
//    __STDC_WANT_IEC_60559_EXT__ instead (C2X does not define
//    __STDC_WANT_IEC_60559_BFP_EXT__), while a few features from TS
//    18661-1 are not included in C2X (and thus should depend on
//    __STDC_WANT_IEC_60559_BFP_EXT__ even when C2X features are
//    enabled).
//
//    __GLIBC_USE (IEC_60559_BFP_EXT) controls those features from TS
//    18661-1 not included in C2X.
//
//    __GLIBC_USE (IEC_60559_BFP_EXT_C2X) controls those features from TS
//    18661-1 that are also included in C2X (with no feature test macro
//    required in C2X).
//
//    __GLIBC_USE (IEC_60559_EXT) controls those features from TS 18661-1
//    that are included in C2X but conditional on
//    __STDC_WANT_IEC_60559_EXT__.  (There are currently no features
//    conditional on __STDC_WANT_IEC_60559_EXT__ that are not in TS
//    18661-1.)

// ISO/IEC TS 18661-4:2015 defines the
//    __STDC_WANT_IEC_60559_FUNCS_EXT__ macro.  Other than the reduction
//    functions, the symbols from this TS are enabled unconditionally in
//    C2X.

// ISO/IEC TS 18661-3:2015 defines the
//    __STDC_WANT_IEC_60559_TYPES_EXT__ macro.

// Get definitions of __intmax_t and __uintmax_t.
// bits/types.h -- definitions of __*_t types underlying *_t types.
//    Copyright (C) 2002-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Never include this file directly; use <sys/types.h> instead.

// Get machine-dependent vector math functions declarations.
// Platform-specific SIMD declarations of math functions.
//    Copyright (C) 2014-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Get default empty definitions for simd declarations.
// Empty definitions required for __MATHCALL_VEC unfolding in mathcalls.h.
//    Copyright (C) 2014-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Needed definitions could be generated with:
//    for func in $(grep __MATHCALL_VEC math/bits/mathcalls.h |		 sed -r "s|__MATHCALL_VEC.?\(||; s|,.*||"); do
//      echo "#define __DECL_SIMD_${func}";
//      echo "#define __DECL_SIMD_${func}f";
//      echo "#define __DECL_SIMD_${func}l";
//    done
//

// Gather machine dependent type support.
// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Value returned on overflow.  With IEEE 754 floating point, this is
//    +Infinity, otherwise the largest representable positive value.

// IEEE positive infinity.

// IEEE Not A Number.

// Get __GLIBC_FLT_EVAL_METHOD.
// Define __GLIBC_FLT_EVAL_METHOD.  x86 version.
//    Copyright (C) 2016-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Define the following typedefs.
//
//	    float_t	floating-point type at least as wide as `float' used
//			to evaluate `float' expressions
//	    double_t	floating-point type at least as wide as `double' used
//			to evaluate `double' expressions
type Tfloat_t = float32  /* math.h:163:15 */
type Tdouble_t = float64 /* math.h:164:16 */

// POSIX.1-2008 extended locale interface (see locale.h).
// Definition of locale_t.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// Definition of struct __locale_struct and __locale_t.
//    Copyright (C) 1997-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// POSIX.1-2008: the locale_t type, representing a locale context
//    (implementation-namespace version).  This type should be treated
//    as opaque by applications; some details are exposed for the sake of
//    efficiency in e.g. ctype functions.

type S__locale_struct = struct {
	F__locales       [13]uintptr
	F__ctype_b       uintptr
	F__ctype_tolower uintptr
	F__ctype_toupper uintptr
	F__names         [13]uintptr
} /* __locale_t.h:27:1 */

type T__locale_t = uintptr /* __locale_t.h:41:32 */

type Tlocale_t = uintptr /* locale_t.h:24:20 */

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2018 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file baseCells.h
// @brief   Base cell related lookup tables and access functions.

// Copyright 2016-2017, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2018, 2020-2022 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lng
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lng.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

// Copyright 2016-2018, 2020-2022 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file coordijk.h
// @brief   Header file for CoordIJK functions including conversion from lat/lng
//
// References two Vec2d cartesian coordinate systems:
//
//    1. gnomonic: face-centered polyhedral gnomonic projection space with
//             traditional scaling and x-axes aligned with the face Class II
//             i-axes.
//
//    2. hex2d: local face-centered coordinate system scaled a specific H3 grid
//             resolution unit length and with x-axes aligned with the local
//             i-axes

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2016-2017 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec2d.h
// @brief   2D floating point vector functions.

// * @struct FaceIJK
// @brief Face number and ijk coordinates on that face-centered coordinate
// system
type TFaceIJK = struct {
	Fface  int32
	Fcoord TCoordIJK
} /* faceijk.h:38:3 */

// * @struct FaceOrientIJK
// @brief Information to transform into an adjacent face IJK system
type TFaceOrientIJK = struct {
	Fface      int32
	Ftranslate TCoordIJK
	FccwRot60  int32
} /* faceijk.h:48:3 */

// indexes for faceNeighbors table
//* IJ quadrant faceNeighbors table direction
//* KI quadrant faceNeighbors table direction
//* JK quadrant faceNeighbors table direction

//* Invalid face index

// * Digit representing overage type
type TOverage = uint32 /* faceijk.h:71:3 */

// * @struct BaseCellData
// @brief information on a single base cell
type TBaseCellData = struct {
	FhomeFijk     TFaceIJK
	FisPentagon   int32
	FcwOffsetPent [2]int32
} /* baseCells.h:36:3 */

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2017-2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file linkedGeo.h
// @brief   Linked data structure for geo data

// Copyright 2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file polygon.h
// @brief Polygon algorithms

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright 2016-2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2017-2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file linkedGeo.h
// @brief   Linked data structure for geo data

// Macros for use with polygonAlgos.h
//* Macro: Init iteration vars for GeoLoop

//* Macro: Increment GeoLoop loop iteration, or break if done.

//* Macro: Whether a GeoLoop is empty

// *
// Values representing polyfill containment modes, to be used in
// the `flags` bit field.
type TContainmentMode = uint32 /* polygon.h:53:3 */

// Copyright 2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vertexGraph.h
// @brief   Data structure for storing a graph of vertices

// Return codes from gridDiskUnsafe and related functions.

// *
// Directions used for traversing a hexagonal ring counterclockwise around
// {1, 0, 0}
//
// <pre>
//
//	   _
//	 _/ \\_
//	/ \\5/ \ *   \\0/ \\4/
//	/ \\_/ \ *   \\1/ \\3/
//	  \\2/
//
// </pre>
var sDIRECTIONS = [6]uint32{J_AXES_DIGIT, JK_AXES_DIGIT,
	K_AXES_DIGIT, IK_AXES_DIGIT,
	I_AXES_DIGIT, IJ_AXES_DIGIT} /* algos.c:62:24 */

// *
// Direction used for traversing to the next outward hexagonal ring.
var sNEXT_RING_DIRECTION uint32 = I_AXES_DIGIT /* algos.c:69:24 */

// *
// New digit when traversing along class II grids.
//
// Current digit -> direction -> new digit.
var sNEW_DIGIT_II = [7][7]uint32{
	{CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, IJ_AXES_DIGIT},
	{K_AXES_DIGIT, I_AXES_DIGIT, JK_AXES_DIGIT, IJ_AXES_DIGIT, IK_AXES_DIGIT,
		J_AXES_DIGIT, CENTER_DIGIT},
	{J_AXES_DIGIT, JK_AXES_DIGIT, K_AXES_DIGIT, I_AXES_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, IK_AXES_DIGIT},
	{JK_AXES_DIGIT, IJ_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, J_AXES_DIGIT},
	{I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, J_AXES_DIGIT,
		JK_AXES_DIGIT, K_AXES_DIGIT},
	{IK_AXES_DIGIT, J_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, JK_AXES_DIGIT,
		IJ_AXES_DIGIT, I_AXES_DIGIT},
	{IJ_AXES_DIGIT, CENTER_DIGIT, IK_AXES_DIGIT, J_AXES_DIGIT, K_AXES_DIGIT,
		I_AXES_DIGIT, JK_AXES_DIGIT}} /* algos.c:76:24 */

// *
// New traversal direction when traversing along class II grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_ADJUSTMENT_II = [7][7]uint32{
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, J_AXES_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, JK_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		I_AXES_DIGIT, IJ_AXES_DIGIT},
	{CENTER_DIGIT, IK_AXES_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, CENTER_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT}} /* algos.c:97:24 */

// *
// New traversal direction when traversing along class III grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_DIGIT_III = [7][7]uint32{
	{CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, IJ_AXES_DIGIT},
	{K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT,
		IJ_AXES_DIGIT, CENTER_DIGIT},
	{J_AXES_DIGIT, JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT,
		CENTER_DIGIT, K_AXES_DIGIT},
	{JK_AXES_DIGIT, I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, J_AXES_DIGIT},
	{I_AXES_DIGIT, IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT,
		J_AXES_DIGIT, JK_AXES_DIGIT},
	{IK_AXES_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT,
		JK_AXES_DIGIT, I_AXES_DIGIT},
	{IJ_AXES_DIGIT, CENTER_DIGIT, K_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT,
		I_AXES_DIGIT, IK_AXES_DIGIT}} /* algos.c:118:24 */

// *
// New traversal direction when traversing along class III grids.
//
// Current digit -> direction -> new ap7 move (at coarser level).
var sNEW_ADJUSTMENT_III = [7][7]uint32{
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		K_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, J_AXES_DIGIT, J_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT},
	{CENTER_DIGIT, JK_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, CENTER_DIGIT,
		CENTER_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		IK_AXES_DIGIT, I_AXES_DIGIT},
	{CENTER_DIGIT, K_AXES_DIGIT, CENTER_DIGIT, CENTER_DIGIT, IK_AXES_DIGIT,
		IK_AXES_DIGIT, CENTER_DIGIT},
	{CENTER_DIGIT, CENTER_DIGIT, IJ_AXES_DIGIT, CENTER_DIGIT, I_AXES_DIGIT,
		CENTER_DIGIT, IJ_AXES_DIGIT}} /* algos.c:139:24 */

// *
// k value which will encompass all cells at resolution 15.
// This is the largest possible k in the H3 grid system.
var sK_ALL_CELLS_AT_RES_15 int32 = 13780510 /* algos.c:159:18 */

// *
// Maximum number of cells that result from the gridDisk algorithm with the
// given k. Formula source and proof: https://oeis.org/A003215
//
// @param   k   k value, k >= 0.
// @param out   size in indexes
func XmaxGridDiskSize(tls *libc.TLS, k int32, out uintptr) uint32 { /* algos.c:168:9: */
	if k < 0 {
		return E_DOMAIN
	}
	if k >= sK_ALL_CELLS_AT_RES_15 {
		// If a k value of this value or above is provided, this function will
		// estimate more cells than exist in the H3 grid at the finest
		// resolution. This is a problem since the function does signed integer
		// arithmetic on `k`, which could overflow. To prevent that, instead
		// substitute the maximum number of cells in the grid, as it should not
		// be possible for the gridDisk functions to exceed that. Note this is
		// not resolution specific. So, when resolution < 15, this function may
		// still estimate a size larger than the number of cells in the grid.
		return XgetNumCells(tls, DMAX_H3_RES, out)
	}
	*(*int64)(unsafe.Pointer(out)) = int64(3)*int64(k)*(int64(k)+int64(1)) + int64(1)
	return E_SUCCESS
}

// *
// Produce cells within grid distance k of the origin cell.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Output is placed in the provided array in no particular order. Elements of
// the output array may be left zero, as can happen when crossing a pentagon.
//
// @param  origin   origin cell
// @param  k        k >= 0
// @param  out      zero-filled array which must be of size maxGridDiskSize(k)
func XgridDisk(tls *libc.TLS, origin uint64, k int32, out uintptr) uint32 { /* algos.c:200:9: */
	return XgridDiskDistances(tls, origin, k, out, uintptr(0))
}

// *
// Produce cells and their distances from the given origin cell, up to
// distance k.
//
// k-ring 0 is defined as the origin cell, k-ring 1 is defined as k-ring 0 and
// all neighboring cells, and so on.
//
// Output is placed in the provided array in no particular order. Elements of
// the output array may be left zero, as can happen when crossing a pentagon.
//
// @param  origin      origin cell
// @param  k           k >= 0
// @param  out         zero-filled array which must be of size
// maxGridDiskSize(k)
// @param  distances   NULL or a zero-filled array which must be of size
//
//	maxGridDiskSize(k)
func XgridDiskDistances(tls *libc.TLS, origin uint64, k int32, out uintptr, distances uintptr) uint32 { /* algos.c:221:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// Optimistically try the faster gridDiskUnsafe algorithm first
	var failed uint32 = XgridDiskDistancesUnsafe(tls, origin, k, out, distances)
	if failed != 0 {
		// var maxIdx int64 at bp, 8

		var err uint32 = XmaxGridDiskSize(tls, k, bp)
		if err != 0 {
			return err
		}
		// Fast algo failed, fall back to slower, correct algo
		// and also wipe out array because contents untrustworthy
		libc.Xmemset(tls, out, 0, uint64(*(*int64)(unsafe.Pointer(bp)))*uint64(unsafe.Sizeof(uint64(0))))

		if distances == uintptr(0) {
			distances = libc.Xcalloc(tls, uint64(*(*int64)(unsafe.Pointer(bp /* maxIdx */))), uint64(unsafe.Sizeof(int32(0))))
			if !(distances != 0) {
				return E_MEMORY_ALLOC
			}
			var result uint32 = X_gridDiskDistancesInternal(tls, origin, k, out,
				distances, *(*int64)(unsafe.Pointer(bp /* maxIdx */)), 0)
			libc.Xfree(tls, distances)
			return result
		} else {
			libc.Xmemset(tls, distances, 0, uint64(*(*int64)(unsafe.Pointer(bp)))*uint64(unsafe.Sizeof(int32(0))))
			return X_gridDiskDistancesInternal(tls, origin, k, out, distances, *(*int64)(unsafe.Pointer(bp /* maxIdx */)),
				0)
		}
	} else {
		return E_SUCCESS
	}
	return uint32(0)
}

// *
// Internal algorithm for the safe but slow version of gridDiskDistances
//
// Adds the origin cell to the output set (treating it as a hash set)
// and recurses to its neighbors, if needed.
//
// @param  origin      Origin cell
// @param  k           Maximum distance to move from the origin
// @param  out         Array treated as a hash set, elements being either
//
//	H3Index or 0.
//
// @param  distances   Scratch area, with elements paralleling the out array.
//
//	Elements indicate ijk distance from the origin cell to
//	the output cell
//
// @param  maxIdx      Size of out and scratch arrays (must be
// maxGridDiskSize(k))
// @param  curK        Current distance from the origin
func X_gridDiskDistancesInternal(tls *libc.TLS, origin uint64, k int32, out uintptr, distances uintptr, maxIdx int64, curK int32) uint32 { /* algos.c:272:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// Put origin in the output array. out is used as a hash set.
	var off int64 = int64(origin % uint64(maxIdx))
	for *(*uint64)(unsafe.Pointer(out + uintptr(off)*8)) != uint64(0) && *(*uint64)(unsafe.Pointer(out + uintptr(off)*8)) != origin {
		off = (off + int64(1)) % maxIdx
	}

	// We either got a free slot in the hash set or hit a duplicate
	// We might need to process the duplicate anyways because we got
	// here on a longer path before.
	if *(*uint64)(unsafe.Pointer(out + uintptr(off)*8)) == origin && *(*int32)(unsafe.Pointer(distances + uintptr(off)*4)) <= curK {
		return E_SUCCESS
	}

	*(*uint64)(unsafe.Pointer(out + uintptr(off)*8)) = origin
	*(*int32)(unsafe.Pointer(distances + uintptr(off)*4)) = curK

	// Base case: reached an index k away from the origin.
	if curK >= k {
		return E_SUCCESS
	}

	// Recurse to all neighbors in no particular order.
	{
		var i int32 = 0
		for ; i < 6; i++ {
			*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
			// var nextNeighbor uint64 at bp+8, 8

			var neighborResult uint32 = Xh3NeighborRotations(tls, origin, sDIRECTIONS[i],
				bp, bp+8)
			if neighborResult != E_PENTAGON {
				// E_PENTAGON is an expected case when trying to traverse off of
				// pentagons.
				if neighborResult != E_SUCCESS {
					return neighborResult
				}
				neighborResult = X_gridDiskDistancesInternal(tls,
					*(*uint64)(unsafe.Pointer(bp + 8 /* nextNeighbor */)), k, out, distances, maxIdx, curK+1)
				if neighborResult != 0 {
					return neighborResult
				}
			}
		}
	}
	return E_SUCCESS
}

// *
// Safe but slow version of gridDiskDistances (also called by it when needed).
//
// Adds the origin cell to the output set (treating it as a hash set)
// and recurses to its neighbors, if needed.
//
// @param  origin      Origin cell
// @param  k           Maximum distance to move from the origin
// @param  out         Array treated as a hash set, elements being either
//
//	H3Index or 0.
//
// @param  distances   Scratch area, with elements paralleling the out array.
//
//	Elements indicate ijk distance from the origin cell to
//	the output cell
func XgridDiskDistancesSafe(tls *libc.TLS, origin uint64, k int32, out uintptr, distances uintptr) uint32 { /* algos.c:327:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var maxIdx int64 at bp, 8

	var err uint32 = XmaxGridDiskSize(tls, k, bp)
	if err != 0 {
		return err
	}
	return X_gridDiskDistancesInternal(tls, origin, k, out, distances, *(*int64)(unsafe.Pointer(bp /* maxIdx */)), 0)
}

// *
// Returns the hexagon index neighboring the origin, in the direction dir.
//
// Implementation note: The only reachable case where this returns 0 is if the
// origin is a pentagon and the translation is in the k direction. Thus,
// 0 can only be returned if origin is a pentagon.
//
// @param origin Origin index
// @param dir Direction to move in
// @param rotations Number of ccw rotations to perform to reorient the
//
//	translation vector. Will be modified to the new number of
//	rotations to perform (such as when crossing a face edge.)
//
// @param out H3Index of the specified neighbor if succesful
// @return E_SUCCESS on success
func Xh3NeighborRotations(tls *libc.TLS, origin uint64, dir uint32, rotations uintptr, out uintptr) uint32 { /* algos.c:352:9: */
	var current uint64 = origin

	if dir < CENTER_DIGIT || dir >= INVALID_DIGIT {
		return E_FAILED
	}
	// Ensure that rotations is modulo'd by 6 before any possible addition,
	// to protect against signed integer overflow.
	*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) % 6
	{
		var i int32 = 0
		for ; i < *(*int32)(unsafe.Pointer(rotations)); i++ {
			dir = X_rotate60ccw(tls, dir)
		}
	}

	var newRotations int32 = 0
	var oldBaseCell int32 = int32(current & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if func() int32 {
		if oldBaseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+2, int32(368), uintptr(unsafe.Pointer(&__func__)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || oldBaseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return E_CELL_INVALID
	}
	var oldLeadingDigit uint32 = X_h3LeadingNonZeroDigit(tls, current)

	// Adjust the indexing digits and, if needed, the base cell.
	var r int32 = int32(current&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) - 1
	for 1 != 0 {
		if r == -1 {
			current = current&libc.CplUint64(uint64(uint64(127))<<DH3_BC_OFFSET) | uint64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(oldBaseCell)*28 + uintptr(dir)*4)))<<DH3_BC_OFFSET
			newRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(oldBaseCell)*28 + uintptr(dir)*4))

			if int32(current&(uint64(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET) == DINVALID_BASE_CELL {
				// Adjust for the deleted k vertex at the base cell level.
				// This edge actually borders a different neighbor.
				current = current&libc.CplUint64(uint64(uint64(127))<<DH3_BC_OFFSET) | uint64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(oldBaseCell)*28 + 5*4)))<<DH3_BC_OFFSET
				newRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(oldBaseCell)*28 + 5*4))

				// perform the adjustment for the k-subsequence we're skipping
				// over.
				current = X_h3Rotate60ccw(tls, current)
				*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
			}

			break
		} else {
			var oldDigit uint32 = uint32(current >> ((DMAX_H3_RES - (r + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			var nextDir uint32
			if oldDigit == INVALID_DIGIT {
				// Only possible on invalid input
				return E_CELL_INVALID
			} else if XisResolutionClassIII(tls, r+1) != 0 {
				current = current & ^(uint64(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | uint64(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_DIGIT_II)) + uintptr(oldDigit)*28 + uintptr(dir)*4)))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
				nextDir = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_ADJUSTMENT_II)) + uintptr(oldDigit)*28 + uintptr(dir)*4))
			} else {
				current = current & ^(uint64(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | uint64(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_DIGIT_III)) + uintptr(oldDigit)*28 + uintptr(dir)*4)))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
				nextDir = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(&sNEW_ADJUSTMENT_III)) + uintptr(oldDigit)*28 + uintptr(dir)*4))
			}

			if nextDir != CENTER_DIGIT {
				dir = nextDir
				r--
			} else {
				// No more adjustment to perform
				break
			}
		}
	}

	var newBaseCell int32 = int32(current & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if X_isBaseCellPentagon(tls, newBaseCell) != 0 {
		var alreadyAdjustedKSubsequence int32 = 0

		// force rotation out of missing k-axes sub-sequence
		if X_h3LeadingNonZeroDigit(tls, current) == K_AXES_DIGIT {
			if oldBaseCell != newBaseCell {
				// in this case, we traversed into the deleted
				// k subsequence of a pentagon base cell.
				// We need to rotate out of that case depending
				// on how we got here.
				// check for a cw/ccw offset face; default is ccw

				if func() int32 {
					if X_baseCellIsCwOffset(tls, newBaseCell, XbaseCellData[oldBaseCell].FhomeFijk.Fface) != 0 {
						return 1
					}
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+2, int32(434), uintptr(unsafe.Pointer(&__func__)))
						}
						return 0
					}()
				}() != 0 {
					current = X_h3Rotate60cw(tls, current)
				} else {
					// See cwOffsetPent in testGridDisk.c for why this is
					// unreachable.
					current = X_h3Rotate60ccw(tls, current)
				}
				alreadyAdjustedKSubsequence = 1
			} else {
				// In this case, we traversed into the deleted
				// k subsequence from within the same pentagon
				// base cell.
				if oldLeadingDigit == CENTER_DIGIT {
					// Undefined: the k direction is deleted from here
					return E_PENTAGON
				} else if oldLeadingDigit == JK_AXES_DIGIT {
					// Rotate out of the deleted k subsequence
					// We also need an additional change to the direction we're
					// moving in
					current = X_h3Rotate60ccw(tls, current)
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
				} else if oldLeadingDigit == IK_AXES_DIGIT {
					// Rotate out of the deleted k subsequence
					// We also need an additional change to the direction we're
					// moving in
					current = X_h3Rotate60cw(tls, current)
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 5
				} else {
					// TODO: Should never occur, but is reachable by fuzzer
					return E_FAILED
				}
			}
		}

		{
			var i int32 = 0
			for ; i < newRotations; i++ {
				current = X_h3RotatePent60ccw(tls, current)
			}
		}

		// Account for differing orientation of the base cells (this edge
		// might not follow properties of some other edges.)
		if oldBaseCell != newBaseCell {
			if X_isBaseCellPolarPentagon(tls, newBaseCell) != 0 {
				// 'polar' base cells behave differently because they have all
				// i neighbors.
				if oldBaseCell != 118 && oldBaseCell != 8 && X_h3LeadingNonZeroDigit(tls, current) != JK_AXES_DIGIT {
					*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
				}
			} else if X_h3LeadingNonZeroDigit(tls, current) == IK_AXES_DIGIT && !(alreadyAdjustedKSubsequence != 0) {
				// account for distortion introduced to the 5 neighbor by the
				// deleted k subsequence.
				*(*int32)(unsafe.Pointer(rotations)) = *(*int32)(unsafe.Pointer(rotations)) + 1
			}
		}
	} else {
		{
			var i int32 = 0
			for ; i < newRotations; i++ {
				current = X_h3Rotate60ccw(tls, current)
			}
		}
	}

	*(*int32)(unsafe.Pointer(rotations)) = (*(*int32)(unsafe.Pointer(rotations)) + newRotations) % 6
	*(*uint64)(unsafe.Pointer(out)) = current

	return E_SUCCESS
}

var __func__ = *(*[20]int8)(unsafe.Pointer(ts + 24)) /* algos.c:353:43 */

// *
// Get the direction from the origin to a given neighbor. This is effectively
// the reverse operation for h3NeighborRotations. Returns INVALID_DIGIT if the
// cells are not neighbors.
//
// TODO: This is currently a brute-force algorithm, but as it's O(6) that's
// probably acceptable.
func XdirectionForNeighbor(tls *libc.TLS, origin uint64, destination uint64) uint32 { /* algos.c:509:11: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var isPent uint8 = uint8(XisPentagon(tls, origin))
	// Checks each neighbor, in order, to determine which direction the
	// destination neighbor is located. Skips CENTER_DIGIT since that
	// would be the origin; skips deleted K direction for pentagons.
	{
		var direction uint32
		if isPent != 0 {
			direction = J_AXES_DIGIT
		} else {
			direction = K_AXES_DIGIT
		}
		for ; direction < NUM_DIGITS; direction++ {
			// var neighbor uint64 at bp+8, 8

			*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
			var neighborError uint32 = Xh3NeighborRotations(tls, origin, direction, bp, bp+8)
			if !(neighborError != 0) && *(*uint64)(unsafe.Pointer(bp + 8)) == destination {
				return direction
			}
		}
	}
	return INVALID_DIGIT
}

// *
// gridDiskUnsafe produces indexes within k distance of the origin index.
// Output behavior is undefined when one of the indexes returned by this
// function is a pentagon or is in the pentagon distortion area.
//
// k-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and
// all neighboring indexes, and so on.
//
// Output is placed in the provided array in order of increasing distance from
// the origin.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size maxGridDiskSize(k).
// @return 0 if no pentagon or pentagonal distortion area was encountered.
func XgridDiskUnsafe(tls *libc.TLS, origin uint64, k int32, out uintptr) uint32 { /* algos.c:543:9: */
	return XgridDiskDistancesUnsafe(tls, origin, k, out, uintptr(0))
}

// *
// gridDiskDistancesUnsafe produces indexes within k distance of the origin
// index. Output behavior is undefined when one of the indexes returned by this
// function is a pentagon or is in the pentagon distortion area.
//
// k-ring 0 is defined as the origin index, k-ring 1 is defined as k-ring 0 and
// all neighboring indexes, and so on.
//
// Output is placed in the provided array in order of increasing distance from
// the origin. The distances in hexagons is placed in the distances array at
// the same offset.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size maxGridDiskSize(k).
// @param distances Null or array which must be of size maxGridDiskSize(k).
// @return 0 if no pentagon or pentagonal distortion area was encountered.
func XgridDiskDistancesUnsafe(tls *libc.TLS, origin uint64, k int32, out uintptr, distances uintptr) uint32 { /* algos.c:565:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uint64)(unsafe.Pointer(bp + 8)) = origin

	// Return codes:
	// 1 Pentagon was encountered
	// 2 Pentagon distortion (deleted k subsequence) was encountered
	// Pentagon being encountered is not itself a problem; really the deleted
	// k-subsequence is the problem, but for compatibility reasons we fail on
	// the pentagon.
	if k < 0 {
		return E_DOMAIN
	}

	// k must be >= 0, so origin is always needed
	var idx int32 = 0
	*(*uint64)(unsafe.Pointer(out + uintptr(idx)*8)) = *(*uint64)(unsafe.Pointer(bp + 8 /* origin */))
	if distances != 0 {
		*(*int32)(unsafe.Pointer(distances + uintptr(idx)*4)) = 0
	}
	idx++

	if XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp + 8))) != 0 {
		// Pentagon was encountered; bail out as user doesn't want this.
		return E_PENTAGON
	}

	// 0 < ring <= k, current ring
	var ring int32 = 1
	// 0 <= direction < 6, current side of the ring
	var direction int32 = 0
	// 0 <= i < ring, current position on the side of the ring
	var i int32 = 0
	// Number of 60 degree ccw rotations to perform on the direction (based on
	// which faces have been crossed.)
	*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0

	for ring <= k {
		if direction == 0 && i == 0 {
			// Not putting in the output set as it will be done later, at
			// the end of this ring.
			var neighborResult uint32 = Xh3NeighborRotations(tls,
				*(*uint64)(unsafe.Pointer(bp + 8 /* origin */)), sNEXT_RING_DIRECTION, bp, bp+8)
			if neighborResult != 0 {
				// Should not be possible because `origin` would have to be a
				// pentagon
				// TODO: Reachable via fuzzer
				return neighborResult
			}

			if XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp + 8))) != 0 {
				// Pentagon was encountered; bail out as user doesn't want this.
				return E_PENTAGON
			}
		}

		var neighborResult uint32 = Xh3NeighborRotations(tls,
			*(*uint64)(unsafe.Pointer(bp + 8 /* origin */)), sDIRECTIONS[direction], bp, bp+8)
		if neighborResult != 0 {
			return neighborResult
		}
		*(*uint64)(unsafe.Pointer(out + uintptr(idx)*8)) = *(*uint64)(unsafe.Pointer(bp + 8 /* origin */))
		if distances != 0 {
			*(*int32)(unsafe.Pointer(distances + uintptr(idx)*4)) = ring
		}
		idx++

		i++
		// Check if end of this side of the k-ring
		if i == ring {
			i = 0
			direction++
			// Check if end of this ring.
			if direction == 6 {
				direction = 0
				ring++
			}
		}

		if XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp + 8))) != 0 {
			// Pentagon was encountered; bail out as user doesn't want this.
			return E_PENTAGON
		}
	}
	return E_SUCCESS
}

// *
// gridDisksUnsafe takes an array of input hex IDs and a max k-ring and returns
// an array of hexagon IDs sorted first by the original hex IDs and then by the
// k-ring (0 to max), with no guaranteed sorting within each k-ring group.
//
// @param h3Set A pointer to an array of H3Indexes
// @param length The total number of H3Indexes in h3Set
// @param k The number of rings to generate
// @param out A pointer to the output memory to dump the new set of H3Indexes to
//
//	The memory block should be equal to maxGridDiskSize(k) * length
//
// @return 0 if no pentagon is encountered. Cannot trust output otherwise
func XgridDisksUnsafe(tls *libc.TLS, h3Set uintptr, length int32, k int32, out uintptr) uint32 { /* algos.c:662:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var segment uintptr
	// var segmentSize int64 at bp, 8

	var err uint32 = XmaxGridDiskSize(tls, k, bp)
	if err != 0 {
		return err
	}
	{
		var i int32 = 0
		for ; i < length; i++ {
			// Determine the appropriate segment of the output array to operate on
			segment = out + uintptr(int64(i)**(*int64)(unsafe.Pointer(bp)))*8
			var failed uint32 = XgridDiskUnsafe(tls, *(*uint64)(unsafe.Pointer(h3Set + uintptr(i)*8)), k, segment)
			if failed != 0 {
				return failed
			}
		}
	}
	return E_SUCCESS
}

// *
// Returns the "hollow" ring of hexagons at exactly grid distance k from
// the origin hexagon. In particular, k=0 returns just the origin hexagon.
//
// A nonzero failure code may be returned in some cases, for example,
// if a pentagon is encountered.
// Failure cases may be fixed in future versions.
//
// @param origin Origin location.
// @param k k >= 0
// @param out Array which must be of size 6 * k (or 1 if k == 0)
// @return 0 if successful; nonzero otherwise.
func XgridRingUnsafe(tls *libc.TLS, origin uint64, k int32, out uintptr) uint32 { /* algos.c:692:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uint64)(unsafe.Pointer(bp + 8)) = origin

	// Short-circuit on 'identity' ring
	if k == 0 {
		*(*uint64)(unsafe.Pointer(out)) = *(*uint64)(unsafe.Pointer(bp + 8 /* origin */))
		return E_SUCCESS
	}
	var idx int32 = 0
	// Number of 60 degree ccw rotations to perform on the direction (based on
	// which faces have been crossed.)
	*(*int32)(unsafe.Pointer(bp /* rotations */)) = 0
	// Scratch structure for checking for pentagons
	if XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp + 8))) != 0 {
		// Pentagon was encountered; bail out as user doesn't want this.
		return E_PENTAGON
	}

	{
		var ring int32 = 0
		for ; ring < k; ring++ {
			var neighborResult uint32 = Xh3NeighborRotations(tls,
				*(*uint64)(unsafe.Pointer(bp + 8 /* origin */)), sNEXT_RING_DIRECTION, bp, bp+8)
			if neighborResult != 0 {
				// Should not be possible because `origin` would have to be a
				// pentagon
				// TODO: Reachable via fuzzer
				return neighborResult
			}

			if XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp + 8))) != 0 {
				return E_PENTAGON
			}
		}
	}

	var lastIndex uint64 = *(*uint64)(unsafe.Pointer(bp + 8 /* origin */))

	*(*uint64)(unsafe.Pointer(out + uintptr(idx)*8)) = *(*uint64)(unsafe.Pointer(bp + 8 /* origin */))
	idx++

	{
		var direction int32 = 0
		for ; direction < 6; direction++ {
			{
				var pos int32 = 0
				for ; pos < k; pos++ {
					var neighborResult uint32 = Xh3NeighborRotations(tls,
						*(*uint64)(unsafe.Pointer(bp + 8 /* origin */)), sDIRECTIONS[direction], bp, bp+8)
					if neighborResult != 0 {
						// Should not be possible because `origin` would have to be a
						// pentagon
						// TODO: Reachable via fuzzer
						return neighborResult
					}

					// Skip the very last index, it was already added. We do
					// however need to traverse to it because of the pentagonal
					// distortion check, below.
					if pos != k-1 || direction != 5 {
						*(*uint64)(unsafe.Pointer(out + uintptr(idx)*8)) = *(*uint64)(unsafe.Pointer(bp + 8 /* origin */))
						idx++

						if XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp + 8))) != 0 {
							return E_PENTAGON
						}
					}
				}
			}
		}
	}

	// Check that this matches the expected lastIndex, if it doesn't,
	// it indicates pentagonal distortion occurred and we should report
	// failure.
	if lastIndex != *(*uint64)(unsafe.Pointer(bp + 8)) {
		return E_PENTAGON
	} else {
		return E_SUCCESS
	}
	return uint32(0)
}

// *
// maxPolygonToCellsSize returns the number of cells to allocate space for
// when performing a polygonToCells on the given GeoJSON-like data structure.
//
// The size is the maximum of either the number of points in the geoloop or the
// number of cells in the bounding box of the geoloop.
//
// @param geoPolygon A GeoJSON-like data structure indicating the poly to fill
// @param res Hexagon resolution (0-15)
// @param out number of cells to allocate for
// @return 0 (E_SUCCESS) on success.
func XmaxPolygonToCellsSize(tls *libc.TLS, geoPolygon uintptr, res int32, flags uint32, out uintptr) uint32 { /* algos.c:775:9: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var flagErr uint32 = XvalidatePolygonFlags(tls, flags)
	if flagErr != 0 {
		return flagErr
	}
	// Get the bounding box for the GeoJSON-like struct
	// var bbox TBBox at bp+16, 32

	*(*TGeoLoop)(unsafe.Pointer(bp /* geoloop */)) = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fgeoloop
	XbboxFromGeoLoop(tls, bp, bp+16)
	// var numHexagons int64 at bp+48, 8

	var estimateErr uint32 = XbboxHexEstimate(tls, bp+16, res, bp+48)
	if estimateErr != 0 {
		return estimateErr
	}
	// This algorithm assumes that the number of vertices is usually less than
	// the number of hexagons, but when it's wrong, this will keep it from
	// failing
	var totalVerts int32 = (*TGeoLoop)(unsafe.Pointer(bp /* &geoloop */)).FnumVerts
	{
		var i int32 = 0
		for ; i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles; i++ {
			totalVerts = totalVerts + (*TGeoLoop)(unsafe.Pointer((*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16)).FnumVerts
		}
	}
	if *(*int64)(unsafe.Pointer(bp + 48)) < int64(totalVerts) {
		*(*int64)(unsafe.Pointer(bp + 48 /* numHexagons */)) = int64(totalVerts)
	}
	// When the polygon is very small, near an icosahedron edge and is an odd
	// resolution, the line tracing needs an extra buffer than the estimator
	// function provides (but beefing that up to cover causes most situations to
	// overallocate memory)
	*(*int64)(unsafe.Pointer(bp + 48 /* numHexagons */)) += int64(DPOLYGON_TO_CELLS_BUFFER)
	*(*int64)(unsafe.Pointer(out)) = *(*int64)(unsafe.Pointer(bp + 48 /* numHexagons */))
	return E_SUCCESS
}

// *
// _getEdgeHexagons takes a given geoloop ring (either the main geoloop or
// one of the holes) and traces it with hexagons and updates the search and
// found memory blocks. This is used for determining the initial hexagon set
// for the polygonToCells algorithm to execute on.
//
// @param geoloop The geoloop (or hole) to be traced
// @param numHexagons The maximum number of hexagons possible for the geoloop
//
//	(also the bounds of the search and found arrays)
//
// @param res The hexagon resolution (0-15)
// @param numSearchHexes The number of hexagons found so far to be searched
// @param search The block of memory containing the hexagons to search from
// @param found The block of memory containing the hexagons found from the
// search
//
// @return An error code if the hash function cannot insert a found hexagon
//
//	into the found array.
func X_getEdgeHexagons(tls *libc.TLS, geoloop uintptr, numHexagons int64, res int32, numSearchHexes uintptr, search uintptr, found uintptr) uint32 { /* algos.c:825:9: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	{
		var i int32 = 0
		for ; i < (*TGeoLoop)(unsafe.Pointer(geoloop)).FnumVerts; i++ {
			*(*TLatLng)(unsafe.Pointer(bp /* origin */)) = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(geoloop)).Fverts + uintptr(i)*16))
			if i == (*TGeoLoop)(unsafe.Pointer(geoloop)).FnumVerts-1 {
				*(*TLatLng)(unsafe.Pointer(bp + 16 /* destination */)) = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(geoloop)).Fverts))
			} else {
				*(*TLatLng)(unsafe.Pointer(bp + 16 /* destination */)) = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(geoloop)).Fverts + uintptr(i+1)*16))
			}
			// var numHexesEstimate int64 at bp+32, 8

			var estimateErr uint32 = XlineHexEstimate(tls, bp, bp+16, res, bp+32)
			if estimateErr != 0 {
				return estimateErr
			}
			{
				var j int64 = int64(0)
				for ; j < *(*int64)(unsafe.Pointer(bp + 32)); j++ {
					// var interpolate TLatLng at bp+40, 16

					var invNumHexesEst float64 = 1.0 / float64(*(*int64)(unsafe.Pointer(bp + 32)))
					(*TLatLng)(unsafe.Pointer(bp + 40 /* &interpolate */)).Flat = (*TLatLng)(unsafe.Pointer(bp)).Flat*float64(*(*int64)(unsafe.Pointer(bp + 32))-j)*invNumHexesEst + (*TLatLng)(unsafe.Pointer(bp+16)).Flat*float64(j)*invNumHexesEst
					(*TLatLng)(unsafe.Pointer(bp + 40 /* &interpolate */)).Flng = (*TLatLng)(unsafe.Pointer(bp)).Flng*float64(*(*int64)(unsafe.Pointer(bp + 32))-j)*invNumHexesEst + (*TLatLng)(unsafe.Pointer(bp+16)).Flng*float64(j)*invNumHexesEst
					// var pointHex uint64 at bp+56, 8

					var e uint32 = XlatLngToCell(tls, bp+40, res, bp+56)
					if e != 0 {
						return e
					}
					// A simple hash to store the hexagon, or move to another place if
					// needed
					var loc int64 = int64(*(*uint64)(unsafe.Pointer(bp + 56)) % uint64(numHexagons))
					var loopCount int64 = int64(0)
					for *(*uint64)(unsafe.Pointer(found + uintptr(loc)*8)) != uint64(0) {
						// If this conditional is reached, the `found` memory block is
						// too small for the given polygon. This should not happen.
						// TODO: Reachable via fuzzer
						if loopCount > numHexagons {
							return E_FAILED
						}
						if *(*uint64)(unsafe.Pointer(found + uintptr(loc)*8)) == *(*uint64)(unsafe.Pointer(bp + 56)) {
							break
						} // At least two points of the geoloop index to the
						// same cell
						loc = (loc + int64(1)) % numHexagons
						loopCount++
					}
					if *(*uint64)(unsafe.Pointer(found + uintptr(loc)*8)) == *(*uint64)(unsafe.Pointer(bp + 56)) {
						continue
					} // Skip this hex, already exists in the found hash
					// Otherwise, set it in the found hash for now
					*(*uint64)(unsafe.Pointer(found + uintptr(loc)*8)) = *(*uint64)(unsafe.Pointer(bp + 56 /* pointHex */))

					*(*uint64)(unsafe.Pointer(search + uintptr(*(*int64)(unsafe.Pointer(numSearchHexes)))*8)) = *(*uint64)(unsafe.Pointer(bp + 56 /* pointHex */))
					*(*int64)(unsafe.Pointer(numSearchHexes))++
				}
			}
		}
	}
	return E_SUCCESS
}

// *
// polygonToCells takes a given GeoJSON-like data structure and preallocated,
// zeroed memory, and fills it with the hexagons that are contained by
// the GeoJSON-like data structure.
//
// This implementation traces the GeoJSON geoloop(s) in cartesian space with
// hexagons, tests them and their neighbors to be contained by the geoloop(s),
// and then any newly found hexagons are used to test again until no new
// hexagons are found.
//
// @param geoPolygon The geoloop and holes defining the relevant area
// @param res The Hexagon resolution (0-15)
// @param out The slab of zeroed memory to write to. Assumed to be big enough.
func XpolygonToCells(tls *libc.TLS, geoPolygon uintptr, res int32, flags uint32, out uintptr) uint32 { /* algos.c:893:9: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var flagErr uint32 = XvalidatePolygonFlags(tls, flags)
	if flagErr != 0 {
		return flagErr
	}
	// One of the goals of the polygonToCells algorithm is that two adjacent
	// polygons with zero overlap have zero overlapping hexagons. That the
	// hexagons are uniquely assigned. There are a few approaches to take here,
	// such as deciding based on which polygon has the greatest overlapping area
	// of the hexagon, or the most number of contained points on the hexagon
	// (using the center point as a tiebreaker).
	//
	// But if the polygons are convex, both of these more complex algorithms can
	// be reduced down to checking whether or not the center of the hexagon is
	// contained in the polygon, and so this is the approach that this
	// polygonToCells algorithm will follow, as it's simpler, faster, and the
	// error for concave polygons is still minimal (only affecting concave
	// shapes on the order of magnitude of the hexagon size or smaller, not
	// impacting larger concave shapes)
	//
	// This first part is identical to the maxPolygonToCellsSize above.

	// Get the bounding boxes for the polygon and any holes
	var bboxes uintptr = libc.Xmalloc(tls, uint64((*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles+1)*uint64(unsafe.Sizeof(TBBox{})))
	if !(bboxes != 0) {
		return E_MEMORY_ALLOC
	}
	XbboxesFromGeoPolygon(tls, geoPolygon, bboxes)

	// Get the estimated number of hexagons and allocate some temporary memory
	// for the hexagons
	// var numHexagons int64 at bp, 8

	var numHexagonsError uint32 = XmaxPolygonToCellsSize(tls, geoPolygon, res, flags, bp)
	if numHexagonsError != 0 {
		libc.Xfree(tls, bboxes)
		return numHexagonsError
	}
	var search uintptr = libc.Xcalloc(tls, uint64(*(*int64)(unsafe.Pointer(bp /* numHexagons */))), uint64(unsafe.Sizeof(uint64(0))))
	if !(search != 0) {
		libc.Xfree(tls, bboxes)
		return E_MEMORY_ALLOC
	}
	var found uintptr = libc.Xcalloc(tls, uint64(*(*int64)(unsafe.Pointer(bp /* numHexagons */))), uint64(unsafe.Sizeof(uint64(0))))
	if !(found != 0) {
		libc.Xfree(tls, bboxes)
		libc.Xfree(tls, search)
		return E_MEMORY_ALLOC
	}

	// Some metadata for tracking the state of the search and found memory
	// blocks
	*(*int64)(unsafe.Pointer(bp + 24 /* numSearchHexes */)) = int64(0)
	var numFoundHexes int64 = int64(0)

	// 1. Trace the hexagons along the polygon defining the outer geoloop and
	// add them to the search hash. The hexagon containing the geoloop point
	// may or may not be contained by the geoloop (as the hexagon's center
	// point may be outside of the boundary.)
	*(*TGeoLoop)(unsafe.Pointer(bp + 8 /* geoloop */)) = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fgeoloop
	var edgeHexError uint32 = X_getEdgeHexagons(tls, bp+8, *(*int64)(unsafe.Pointer(bp /* numHexagons */)), res,
		bp+24, search, found)
	// If this branch is reached, we have exceeded the maximum number of
	// hexagons possible and need to clean up the allocated memory.
	// TODO: Reachable via fuzzer
	if edgeHexError != 0 {
		libc.Xfree(tls, search)
		libc.Xfree(tls, found)
		libc.Xfree(tls, bboxes)
		return edgeHexError
	}

	// 2. Iterate over all holes, trace the polygons defining the holes with
	// hexagons and add to only the search hash. We're going to temporarily use
	// the `found` hash to use for dedupe purposes and then re-zero it once
	// we're done here, otherwise we'd have to scan the whole set on each insert
	// to make sure there's no duplicates, which is very inefficient.
	{
		var i int32 = 0
		for ; i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles; i++ {
			var hole uintptr = (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes + uintptr(i)*16
			edgeHexError = X_getEdgeHexagons(tls, hole, *(*int64)(unsafe.Pointer(bp /* numHexagons */)), res, bp+24,
				search, found)
			// If this branch is reached, we have exceeded the maximum number of
			// hexagons possible and need to clean up the allocated memory.
			// TODO: Reachable via fuzzer
			if edgeHexError != 0 {
				libc.Xfree(tls, search)
				libc.Xfree(tls, found)
				libc.Xfree(tls, bboxes)
				return edgeHexError
			}
		}
	}

	// 3. Re-zero the found hash so it can be used in the main loop below
	{
		var i1 int64 = int64(0)
		for ; i1 < *(*int64)(unsafe.Pointer(bp)); i1++ {
			*(*uint64)(unsafe.Pointer(found + uintptr(i1)*8)) = uint64(DH3_NULL)
		}
	}

	// 4. Begin main loop. While the search hash is not empty do the following
	for *(*int64)(unsafe.Pointer(bp + 24)) > int64(0) {
		// Iterate through all hexagons in the current search hash, then loop
		// through all neighbors and test Point-in-Poly, if point-in-poly
		// succeeds, add to out and found hashes if not already there.
		var currentSearchNum int64 = int64(0)
		var i int64 = int64(0)
		for currentSearchNum < *(*int64)(unsafe.Pointer(bp + 24)) {
			*(*[7]uint64)(unsafe.Pointer(bp + 32 /* ring */)) = [7]uint64{0: uint64(0)}
			var searchHex uint64 = *(*uint64)(unsafe.Pointer(search + uintptr(i)*8))
			XgridDisk(tls, searchHex, 1, bp+32)
			{
				var j int32 = 0
				for ; j < DMAX_ONE_RING_SIZE; j++ {
					if *(*uint64)(unsafe.Pointer(bp + 32 + uintptr(j)*8)) == uint64(DH3_NULL) {
						continue // Skip if this was a pentagon and only had 5
						// neighbors
					}

					var hex uint64 = *(*uint64)(unsafe.Pointer(bp + 32 + uintptr(j)*8))

					// A simple hash to store the hexagon, or move to another place
					// if needed. This MUST be done before the point-in-poly check
					// since that's far more expensive
					var loc int64 = int64(hex % uint64(*(*int64)(unsafe.Pointer(bp))))
					var loopCount int64 = int64(0)
					for *(*uint64)(unsafe.Pointer(out + uintptr(loc)*8)) != uint64(0) {
						// If this branch is reached, we have exceeded the maximum
						// number of hexagons possible and need to clean up the
						// allocated memory.
						// TODO: Reachable via fuzzer
						if loopCount > *(*int64)(unsafe.Pointer(bp)) {
							libc.Xfree(tls, search)
							libc.Xfree(tls, found)
							libc.Xfree(tls, bboxes)
							return E_FAILED
						}
						if *(*uint64)(unsafe.Pointer(out + uintptr(loc)*8)) == hex {
							break
						} // Skip duplicates found
						loc = (loc + int64(1)) % *(*int64)(unsafe.Pointer(bp))
						loopCount++
					}
					if *(*uint64)(unsafe.Pointer(out + uintptr(loc)*8)) == hex {
						continue // Skip this hex, already exists in the out hash
					}

					// Check if the hexagon is in the polygon or not
					// var hexCenter TLatLng at bp+88, 16

					XcellToLatLng(tls, hex, bp+88)

					// If not, skip
					if !(XpointInsidePolygon(tls, geoPolygon, bboxes, bp+88) != 0) {
						continue
					}

					// Otherwise set it in the output array
					*(*uint64)(unsafe.Pointer(out + uintptr(loc)*8)) = hex

					// Set the hexagon in the found hash
					*(*uint64)(unsafe.Pointer(found + uintptr(numFoundHexes)*8)) = hex
					numFoundHexes++
				}
			}
			currentSearchNum++
			i++
		}

		// Swap the search and found pointers, copy the found hex count to the
		// search hex count, and zero everything related to the found memory.
		var temp uintptr = search
		search = found
		found = temp
		{
			var j int64 = int64(0)
			for ; j < *(*int64)(unsafe.Pointer(bp + 24)); j++ {
				*(*uint64)(unsafe.Pointer(found + uintptr(j)*8)) = uint64(0)
			}
		}
		*(*int64)(unsafe.Pointer(bp + 24 /* numSearchHexes */)) = numFoundHexes
		numFoundHexes = int64(0)
		// Repeat until no new hexagons are found
	}
	// The out memory structure should be complete, end it here
	libc.Xfree(tls, bboxes)
	libc.Xfree(tls, search)
	libc.Xfree(tls, found)
	return E_SUCCESS
}

// *
// Internal: Create a vertex graph from a set of hexagons. It is the
// responsibility of the caller to call destroyVertexGraph on the populated
// graph, otherwise the memory in the graph nodes will not be freed.
// @private
// @param h3Set    Set of hexagons
// @param numHexes Number of hexagons in the set
// @param graph    Output graph
func Xh3SetToVertexGraph(tls *libc.TLS, h3Set uintptr, numHexes int32, graph uintptr) uint32 { /* algos.c:1078:9: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var vertices TCellBoundary at bp, 168

	var fromVtx uintptr
	var toVtx uintptr
	var edge uintptr
	if numHexes < 1 {
		// We still need to init the graph, or calls to destroyVertexGraph will
		// fail
		XinitVertexGraph(tls, graph, 0, 0)
		return E_SUCCESS
	}
	var res int32 = int32(*(*uint64)(unsafe.Pointer(h3Set)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var minBuckets int32 = 6
	// TODO: Better way to calculate/guess?
	var numBuckets int32
	if numHexes > minBuckets {
		numBuckets = numHexes
	} else {
		numBuckets = minBuckets
	}
	XinitVertexGraph(tls, graph, numBuckets, res)
	// Iterate through every hexagon
	{
		var i int32 = 0
		for ; i < numHexes; i++ {
			var boundaryErr uint32 = XcellToBoundary(tls, *(*uint64)(unsafe.Pointer(h3Set + uintptr(i)*8)), bp)
			if boundaryErr != 0 {
				// Destroy vertex graph as caller will not know to do so.
				XdestroyVertexGraph(tls, graph)
				return boundaryErr
			}
			// iterate through every edge
			{
				var j int32 = 0
				for ; j < (*TCellBoundary)(unsafe.Pointer(bp)).FnumVerts; j++ {
					fromVtx = bp + 8 + uintptr(j)*16
					toVtx = bp + 8 + uintptr((j+1)%(*TCellBoundary)(unsafe.Pointer(bp)).FnumVerts)*16
					// If we've seen this edge already, it will be reversed
					edge = XfindNodeForEdge(tls, graph, toVtx, fromVtx)
					if edge != uintptr(0) {
						// If we've seen it, drop it. No edge is shared by more than 2
						// hexagons, so we'll never see it again.
						XremoveVertexNode(tls, graph, edge)
					} else {
						// Add a new node for this edge
						XaddVertexNode(tls, graph, fromVtx, toVtx)
					}
				}
			}
		}
	}
	return E_SUCCESS
}

// *
// Internal: Create a LinkedGeoPolygon from a vertex graph. It is the
// responsibility of the caller to call destroyLinkedMultiPolygon on the
// populated linked geo structure, or the memory for that structure will not be
// freed.
// @private
// @param graph Input graph
// @param out   Output polygon
func X_vertexGraphToLinkedGeo(tls *libc.TLS, graph uintptr, out uintptr) { /* algos.c:1131:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*TLinkedGeoPolygon)(unsafe.Pointer(out)) = TLinkedGeoPolygon{}
	var loop uintptr
	var edge uintptr
	// var nextVtx TLatLng at bp, 16

	// Find the next unused entry point
	for libc.AssignUintptr(&edge, XfirstVertexNode(tls, graph)) != uintptr(0) {
		loop = XaddNewLinkedLoop(tls, out)
		// Walk the graph to get the outline
		for __ccgo := true; __ccgo; __ccgo = edge != 0 {
			XaddLinkedCoord(tls, loop, edge)
			*(*TLatLng)(unsafe.Pointer(bp /* nextVtx */)) = (*TVertexNode)(unsafe.Pointer(edge)).Fto
			// Remove frees the node, so we can't use edge after this
			XremoveVertexNode(tls, graph, edge)
			edge = XfindNodeForVertex(tls, graph, bp)
		}
	}
}

// *
// Create a LinkedGeoPolygon describing the outline(s) of a set of  hexagons.
// Polygon outlines will follow GeoJSON MultiPolygon order: Each polygon will
// have one outer loop, which is first in the list, followed by any holes.
//
// It is the responsibility of the caller to call destroyLinkedMultiPolygon on
// the populated linked geo structure, or the memory for that structure will not
// be freed.
//
// It is expected that all hexagons in the set have the same resolution and
// that the set contains no duplicates. Behavior is undefined if duplicates
// or multiple resolutions are present, and the algorithm may produce
// unexpected or invalid output.
//
// @param h3Set    Set of hexagons
// @param numHexes Number of hexagons in set
// @param out      Output polygon
func XcellsToLinkedMultiPolygon(tls *libc.TLS, h3Set uintptr, numHexes int32, out uintptr) uint32 { /* algos.c:1168:9: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var graph TVertexGraph at bp, 24

	var err uint32 = Xh3SetToVertexGraph(tls, h3Set, numHexes, bp)
	if err != 0 {
		return err
	}
	X_vertexGraphToLinkedGeo(tls, bp, out)
	XdestroyVertexGraph(tls, bp)
	var normalizeResult uint32 = XnormalizeMultiPolygon(tls, out)
	if normalizeResult != 0 {
		XdestroyLinkedMultiPolygon(tls, out)
	}
	return normalizeResult
}

//   - @struct BaseCellRotation
//     @brief base cell at a given ijk and required rotations into its system
type TBaseCellRotation = struct {
	FbaseCell int32
	FccwRot60 int32
} /* baseCells.c:31:3 */

// * @brief Neighboring base cell ID in each IJK direction.
//
// For each base cell, for each direction, the neighboring base
// cell ID is given. 127 indicates there is no neighbor in that direction.
var XbaseCellNeighbors = [122][7]int32{
	{0, 1, 5, 2, 4, 3, 8},                          // base cell 0
	{1, 7, 6, 9, 0, 3, 2},                          // base cell 1
	{2, 6, 10, 11, 0, 1, 5},                        // base cell 2
	{3, 13, 1, 7, 4, 12, 0},                        // base cell 3
	{4, DINVALID_BASE_CELL, 15, 8, 3, 0, 12},       // base cell 4 (pentagon)
	{5, 2, 18, 10, 8, 0, 16},                       // base cell 5
	{6, 14, 11, 17, 1, 9, 2},                       // base cell 6
	{7, 21, 9, 19, 3, 13, 1},                       // base cell 7
	{8, 5, 22, 16, 4, 0, 15},                       // base cell 8
	{9, 19, 14, 20, 1, 7, 6},                       // base cell 9
	{10, 11, 24, 23, 5, 2, 18},                     // base cell 10
	{11, 17, 23, 25, 2, 6, 10},                     // base cell 11
	{12, 28, 13, 26, 4, 15, 3},                     // base cell 12
	{13, 26, 21, 29, 3, 12, 7},                     // base cell 13
	{14, DINVALID_BASE_CELL, 17, 27, 9, 20, 6},     // base cell 14 (pentagon)
	{15, 22, 28, 31, 4, 8, 12},                     // base cell 15
	{16, 18, 33, 30, 8, 5, 22},                     // base cell 16
	{17, 11, 14, 6, 35, 25, 27},                    // base cell 17
	{18, 24, 30, 32, 5, 10, 16},                    // base cell 18
	{19, 34, 20, 36, 7, 21, 9},                     // base cell 19
	{20, 14, 19, 9, 40, 27, 36},                    // base cell 20
	{21, 38, 19, 34, 13, 29, 7},                    // base cell 21
	{22, 16, 41, 33, 15, 8, 31},                    // base cell 22
	{23, 24, 11, 10, 39, 37, 25},                   // base cell 23
	{24, DINVALID_BASE_CELL, 32, 37, 10, 23, 18},   // base cell 24 (pentagon)
	{25, 23, 17, 11, 45, 39, 35},                   // base cell 25
	{26, 42, 29, 43, 12, 28, 13},                   // base cell 26
	{27, 40, 35, 46, 14, 20, 17},                   // base cell 27
	{28, 31, 42, 44, 12, 15, 26},                   // base cell 28
	{29, 43, 38, 47, 13, 26, 21},                   // base cell 29
	{30, 32, 48, 50, 16, 18, 33},                   // base cell 30
	{31, 41, 44, 53, 15, 22, 28},                   // base cell 31
	{32, 30, 24, 18, 52, 50, 37},                   // base cell 32
	{33, 30, 49, 48, 22, 16, 41},                   // base cell 33
	{34, 19, 38, 21, 54, 36, 51},                   // base cell 34
	{35, 46, 45, 56, 17, 27, 25},                   // base cell 35
	{36, 20, 34, 19, 55, 40, 54},                   // base cell 36
	{37, 39, 52, 57, 24, 23, 32},                   // base cell 37
	{38, DINVALID_BASE_CELL, 34, 51, 29, 47, 21},   // base cell 38 (pentagon)
	{39, 37, 25, 23, 59, 57, 45},                   // base cell 39
	{40, 27, 36, 20, 60, 46, 55},                   // base cell 40
	{41, 49, 53, 61, 22, 33, 31},                   // base cell 41
	{42, 58, 43, 62, 28, 44, 26},                   // base cell 42
	{43, 62, 47, 64, 26, 42, 29},                   // base cell 43
	{44, 53, 58, 65, 28, 31, 42},                   // base cell 44
	{45, 39, 35, 25, 63, 59, 56},                   // base cell 45
	{46, 60, 56, 68, 27, 40, 35},                   // base cell 46
	{47, 38, 43, 29, 69, 51, 64},                   // base cell 47
	{48, 49, 30, 33, 67, 66, 50},                   // base cell 48
	{49, DINVALID_BASE_CELL, 61, 66, 33, 48, 41},   // base cell 49 (pentagon)
	{50, 48, 32, 30, 70, 67, 52},                   // base cell 50
	{51, 69, 54, 71, 38, 47, 34},                   // base cell 51
	{52, 57, 70, 74, 32, 37, 50},                   // base cell 52
	{53, 61, 65, 75, 31, 41, 44},                   // base cell 53
	{54, 71, 55, 73, 34, 51, 36},                   // base cell 54
	{55, 40, 54, 36, 72, 60, 73},                   // base cell 55
	{56, 68, 63, 77, 35, 46, 45},                   // base cell 56
	{57, 59, 74, 78, 37, 39, 52},                   // base cell 57
	{58, DINVALID_BASE_CELL, 62, 76, 44, 65, 42},   // base cell 58 (pentagon)
	{59, 63, 78, 79, 39, 45, 57},                   // base cell 59
	{60, 72, 68, 80, 40, 55, 46},                   // base cell 60
	{61, 53, 49, 41, 81, 75, 66},                   // base cell 61
	{62, 43, 58, 42, 82, 64, 76},                   // base cell 62
	{63, DINVALID_BASE_CELL, 56, 45, 79, 59, 77},   // base cell 63 (pentagon)
	{64, 47, 62, 43, 84, 69, 82},                   // base cell 64
	{65, 58, 53, 44, 86, 76, 75},                   // base cell 65
	{66, 67, 81, 85, 49, 48, 61},                   // base cell 66
	{67, 66, 50, 48, 87, 85, 70},                   // base cell 67
	{68, 56, 60, 46, 90, 77, 80},                   // base cell 68
	{69, 51, 64, 47, 89, 71, 84},                   // base cell 69
	{70, 67, 52, 50, 83, 87, 74},                   // base cell 70
	{71, 89, 73, 91, 51, 69, 54},                   // base cell 71
	{72, DINVALID_BASE_CELL, 73, 55, 80, 60, 88},   // base cell 72 (pentagon)
	{73, 91, 72, 88, 54, 71, 55},                   // base cell 73
	{74, 78, 83, 92, 52, 57, 70},                   // base cell 74
	{75, 65, 61, 53, 94, 86, 81},                   // base cell 75
	{76, 86, 82, 96, 58, 65, 62},                   // base cell 76
	{77, 63, 68, 56, 93, 79, 90},                   // base cell 77
	{78, 74, 59, 57, 95, 92, 79},                   // base cell 78
	{79, 78, 63, 59, 93, 95, 77},                   // base cell 79
	{80, 68, 72, 60, 99, 90, 88},                   // base cell 80
	{81, 85, 94, 101, 61, 66, 75},                  // base cell 81
	{82, 96, 84, 98, 62, 76, 64},                   // base cell 82
	{83, DINVALID_BASE_CELL, 74, 70, 100, 87, 92},  // base cell 83 (pentagon)
	{84, 69, 82, 64, 97, 89, 98},                   // base cell 84
	{85, 87, 101, 102, 66, 67, 81},                 // base cell 85
	{86, 76, 75, 65, 104, 96, 94},                  // base cell 86
	{87, 83, 102, 100, 67, 70, 85},                 // base cell 87
	{88, 72, 91, 73, 99, 80, 105},                  // base cell 88
	{89, 97, 91, 103, 69, 84, 71},                  // base cell 89
	{90, 77, 80, 68, 106, 93, 99},                  // base cell 90
	{91, 73, 89, 71, 105, 88, 103},                 // base cell 91
	{92, 83, 78, 74, 108, 100, 95},                 // base cell 92
	{93, 79, 90, 77, 109, 95, 106},                 // base cell 93
	{94, 86, 81, 75, 107, 104, 101},                // base cell 94
	{95, 92, 79, 78, 109, 108, 93},                 // base cell 95
	{96, 104, 98, 110, 76, 86, 82},                 // base cell 96
	{97, DINVALID_BASE_CELL, 98, 84, 103, 89, 111}, // base cell 97 (pentagon)
	{98, 110, 97, 111, 82, 96, 84},                 // base cell 98
	{99, 80, 105, 88, 106, 90, 113},                // base cell 99
	{100, 102, 83, 87, 108, 114, 92},               // base cell 100
	{101, 102, 107, 112, 81, 85, 94},               // base cell 101
	{102, 101, 87, 85, 114, 112, 100},              // base cell 102
	{103, 91, 97, 89, 116, 105, 111},               // base cell 103
	{104, 107, 110, 115, 86, 94, 96},               // base cell 104
	{105, 88, 103, 91, 113, 99, 116},               // base cell 105
	{106, 93, 99, 90, 117, 109, 113},               // base cell 106
	{107, DINVALID_BASE_CELL, 101, 94, 115, 104,
		112}, // base cell 107 (pentagon)
	{108, 100, 95, 92, 118, 114, 109},   // base cell 108
	{109, 108, 93, 95, 117, 118, 106},   // base cell 109
	{110, 98, 104, 96, 119, 111, 115},   // base cell 110
	{111, 97, 110, 98, 116, 103, 119},   // base cell 111
	{112, 107, 102, 101, 120, 115, 114}, // base cell 112
	{113, 99, 116, 105, 117, 106, 121},  // base cell 113
	{114, 112, 100, 102, 118, 120, 108}, // base cell 114
	{115, 110, 107, 104, 120, 119, 112}, // base cell 115
	{116, 103, 119, 111, 113, 105, 121}, // base cell 116
	{117, DINVALID_BASE_CELL, 109, 118, 113, 121,
		106}, // base cell 117 (pentagon)
	{118, 120, 108, 114, 117, 121, 109}, // base cell 118
	{119, 111, 115, 110, 121, 116, 120}, // base cell 119
	{120, 115, 114, 112, 121, 119, 118}, // base cell 120
	{121, 116, 120, 119, 117, 113, 118}, // base cell 121
} /* baseCells.c:38:11 */

// * @brief Neighboring base cell rotations in each IJK direction.
//
// For each base cell, for each direction, the number of 60 degree
// CCW rotations to the coordinate system of the neighbor is given.
// -1 indicates there is no neighbor in that direction.
var XbaseCellNeighbor60CCWRots = [122][7]int32{
	{0, 5, 0, 0, 1, 5, 1},  // base cell 0
	{0, 0, 1, 0, 1, 0, 1},  // base cell 1
	{0, 0, 0, 0, 0, 5, 0},  // base cell 2
	{0, 5, 0, 0, 2, 5, 1},  // base cell 3
	{0, -1, 1, 0, 3, 4, 2}, // base cell 4 (pentagon)
	{0, 0, 1, 0, 1, 0, 1},  // base cell 5
	{0, 0, 0, 3, 5, 5, 0},  // base cell 6
	{0, 0, 0, 0, 0, 5, 0},  // base cell 7
	{0, 5, 0, 0, 0, 5, 1},  // base cell 8
	{0, 0, 1, 3, 0, 0, 1},  // base cell 9
	{0, 0, 1, 3, 0, 0, 1},  // base cell 10
	{0, 3, 3, 3, 0, 0, 0},  // base cell 11
	{0, 5, 0, 0, 3, 5, 1},  // base cell 12
	{0, 0, 1, 0, 1, 0, 1},  // base cell 13
	{0, -1, 3, 0, 5, 2, 0}, // base cell 14 (pentagon)
	{0, 5, 0, 0, 4, 5, 1},  // base cell 15
	{0, 0, 0, 0, 0, 5, 0},  // base cell 16
	{0, 3, 3, 3, 3, 0, 3},  // base cell 17
	{0, 0, 0, 3, 5, 5, 0},  // base cell 18
	{0, 3, 3, 3, 0, 0, 0},  // base cell 19
	{0, 3, 3, 3, 0, 3, 0},  // base cell 20
	{0, 0, 0, 3, 5, 5, 0},  // base cell 21
	{0, 0, 1, 0, 1, 0, 1},  // base cell 22
	{0, 3, 3, 3, 0, 3, 0},  // base cell 23
	{0, -1, 3, 0, 5, 2, 0}, // base cell 24 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 25
	{0, 0, 0, 0, 0, 5, 0},  // base cell 26
	{0, 3, 0, 0, 0, 3, 3},  // base cell 27
	{0, 0, 1, 0, 1, 0, 1},  // base cell 28
	{0, 0, 1, 3, 0, 0, 1},  // base cell 29
	{0, 3, 3, 3, 0, 0, 0},  // base cell 30
	{0, 0, 0, 0, 0, 5, 0},  // base cell 31
	{0, 3, 3, 3, 3, 0, 3},  // base cell 32
	{0, 0, 1, 3, 0, 0, 1},  // base cell 33
	{0, 3, 3, 3, 3, 0, 3},  // base cell 34
	{0, 0, 3, 0, 3, 0, 3},  // base cell 35
	{0, 0, 0, 3, 0, 0, 3},  // base cell 36
	{0, 3, 0, 0, 0, 3, 3},  // base cell 37
	{0, -1, 3, 0, 5, 2, 0}, // base cell 38 (pentagon)
	{0, 3, 0, 0, 3, 3, 0},  // base cell 39
	{0, 3, 0, 0, 3, 3, 0},  // base cell 40
	{0, 0, 0, 3, 5, 5, 0},  // base cell 41
	{0, 0, 0, 3, 5, 5, 0},  // base cell 42
	{0, 3, 3, 3, 0, 0, 0},  // base cell 43
	{0, 0, 1, 3, 0, 0, 1},  // base cell 44
	{0, 0, 3, 0, 0, 3, 3},  // base cell 45
	{0, 0, 0, 3, 0, 3, 0},  // base cell 46
	{0, 3, 3, 3, 0, 3, 0},  // base cell 47
	{0, 3, 3, 3, 0, 3, 0},  // base cell 48
	{0, -1, 3, 0, 5, 2, 0}, // base cell 49 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 50
	{0, 3, 0, 0, 0, 3, 3},  // base cell 51
	{0, 0, 3, 0, 3, 0, 3},  // base cell 52
	{0, 3, 3, 3, 0, 0, 0},  // base cell 53
	{0, 0, 3, 0, 3, 0, 3},  // base cell 54
	{0, 0, 3, 0, 0, 3, 3},  // base cell 55
	{0, 3, 3, 3, 0, 0, 3},  // base cell 56
	{0, 0, 0, 3, 0, 3, 0},  // base cell 57
	{0, -1, 3, 0, 5, 2, 0}, // base cell 58 (pentagon)
	{0, 3, 3, 3, 3, 3, 0},  // base cell 59
	{0, 3, 3, 3, 3, 3, 0},  // base cell 60
	{0, 3, 3, 3, 3, 0, 3},  // base cell 61
	{0, 3, 3, 3, 3, 0, 3},  // base cell 62
	{0, -1, 3, 0, 5, 2, 0}, // base cell 63 (pentagon)
	{0, 0, 0, 3, 0, 0, 3},  // base cell 64
	{0, 3, 3, 3, 0, 3, 0},  // base cell 65
	{0, 3, 0, 0, 0, 3, 3},  // base cell 66
	{0, 3, 0, 0, 3, 3, 0},  // base cell 67
	{0, 3, 3, 3, 0, 0, 0},  // base cell 68
	{0, 3, 0, 0, 3, 3, 0},  // base cell 69
	{0, 0, 3, 0, 0, 3, 3},  // base cell 70
	{0, 0, 0, 3, 0, 3, 0},  // base cell 71
	{0, -1, 3, 0, 5, 2, 0}, // base cell 72 (pentagon)
	{0, 3, 3, 3, 0, 0, 3},  // base cell 73
	{0, 3, 3, 3, 0, 0, 3},  // base cell 74
	{0, 0, 0, 3, 0, 0, 3},  // base cell 75
	{0, 3, 0, 0, 0, 3, 3},  // base cell 76
	{0, 0, 0, 3, 0, 5, 0},  // base cell 77
	{0, 3, 3, 3, 0, 0, 0},  // base cell 78
	{0, 0, 1, 3, 1, 0, 1},  // base cell 79
	{0, 0, 1, 3, 1, 0, 1},  // base cell 80
	{0, 0, 3, 0, 3, 0, 3},  // base cell 81
	{0, 0, 3, 0, 3, 0, 3},  // base cell 82
	{0, -1, 3, 0, 5, 2, 0}, // base cell 83 (pentagon)
	{0, 0, 3, 0, 0, 3, 3},  // base cell 84
	{0, 0, 0, 3, 0, 3, 0},  // base cell 85
	{0, 3, 0, 0, 3, 3, 0},  // base cell 86
	{0, 3, 3, 3, 3, 3, 0},  // base cell 87
	{0, 0, 0, 3, 0, 5, 0},  // base cell 88
	{0, 3, 3, 3, 3, 3, 0},  // base cell 89
	{0, 0, 0, 0, 0, 0, 1},  // base cell 90
	{0, 3, 3, 3, 0, 0, 0},  // base cell 91
	{0, 0, 0, 3, 0, 5, 0},  // base cell 92
	{0, 5, 0, 0, 5, 5, 0},  // base cell 93
	{0, 0, 3, 0, 0, 3, 3},  // base cell 94
	{0, 0, 0, 0, 0, 0, 1},  // base cell 95
	{0, 0, 0, 3, 0, 3, 0},  // base cell 96
	{0, -1, 3, 0, 5, 2, 0}, // base cell 97 (pentagon)
	{0, 3, 3, 3, 0, 0, 3},  // base cell 98
	{0, 5, 0, 0, 5, 5, 0},  // base cell 99
	{0, 0, 1, 3, 1, 0, 1},  // base cell 100
	{0, 3, 3, 3, 0, 0, 3},  // base cell 101
	{0, 3, 3, 3, 0, 0, 0},  // base cell 102
	{0, 0, 1, 3, 1, 0, 1},  // base cell 103
	{0, 3, 3, 3, 3, 3, 0},  // base cell 104
	{0, 0, 0, 0, 0, 0, 1},  // base cell 105
	{0, 0, 1, 0, 3, 5, 1},  // base cell 106
	{0, -1, 3, 0, 5, 2, 0}, // base cell 107 (pentagon)
	{0, 5, 0, 0, 5, 5, 0},  // base cell 108
	{0, 0, 1, 0, 4, 5, 1},  // base cell 109
	{0, 3, 3, 3, 0, 0, 0},  // base cell 110
	{0, 0, 0, 3, 0, 5, 0},  // base cell 111
	{0, 0, 0, 3, 0, 5, 0},  // base cell 112
	{0, 0, 1, 0, 2, 5, 1},  // base cell 113
	{0, 0, 0, 0, 0, 0, 1},  // base cell 114
	{0, 0, 1, 3, 1, 0, 1},  // base cell 115
	{0, 5, 0, 0, 5, 5, 0},  // base cell 116
	{0, -1, 1, 0, 3, 4, 2}, // base cell 117 (pentagon)
	{0, 0, 1, 0, 0, 5, 1},  // base cell 118
	{0, 0, 0, 0, 0, 0, 1},  // base cell 119
	{0, 5, 0, 0, 5, 5, 0},  // base cell 120
	{0, 0, 1, 0, 1, 5, 1},  // base cell 121
} /* baseCells.c:171:11 */

// * @brief Resolution 0 base cell lookup table for each face.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, gives the base cell located at that
// coordinate and the number of 60 ccw rotations to rotate into that base
// cell's orientation.
//
// Valid lookup coordinates are from (0, 0, 0) to (2, 2, 2).
//
// This table can be accessed using the functions `_faceIjkToBaseCell` and
// `_faceIjkToBaseCellCCWrot60`
var faceIjkBaseCells = [20][3][3][3]TBaseCellRotation{{
	{{{FbaseCell: 16}, {FbaseCell: 18}, {FbaseCell: 24}}, // j 0
		{{FbaseCell: 33}, {FbaseCell: 30}, {FbaseCell: 32, FccwRot60: 3}}, // j 1
		{{FbaseCell: 49, FccwRot60: 1}, {FbaseCell: 48, FccwRot60: 3}, {FbaseCell: 50, FccwRot60: 3}}},
	{
		{
			// i 1
			{FbaseCell: 8}, {FbaseCell: 5, FccwRot60: 5}, {FbaseCell: 10, FccwRot60: 5}}, // j 0
		{{FbaseCell: 22}, {FbaseCell: 16}, {FbaseCell: 18}}, // j 1
		{{FbaseCell: 41, FccwRot60: 1}, {FbaseCell: 33}, {FbaseCell: 30}}},
	{
		{
			// i 2
			{FbaseCell: 4}, {FccwRot60: 5}, {FbaseCell: 2, FccwRot60: 5}}, // j 0
		{{FbaseCell: 15, FccwRot60: 1}, {FbaseCell: 8}, {FbaseCell: 5, FccwRot60: 5}}, // j 1
		{{FbaseCell: 31, FccwRot60: 1}, {FbaseCell: 22}, {FbaseCell: 16}}}},
	{
		{ // face 1
			{
				{FbaseCell: 2}, {FbaseCell: 6}, {FbaseCell: 14}}, // j 0
			{{FbaseCell: 10}, {FbaseCell: 11}, {FbaseCell: 17, FccwRot60: 3}}, // j 1
			{{FbaseCell: 24, FccwRot60: 1}, {FbaseCell: 23, FccwRot60: 3}, {FbaseCell: 25, FccwRot60: 3}}},
		{
			{
				// i 1
				{}, {FbaseCell: 1, FccwRot60: 5}, {FbaseCell: 9, FccwRot60: 5}}, // j 0
			{{FbaseCell: 5}, {FbaseCell: 2}, {FbaseCell: 6}}, // j 1
			{{FbaseCell: 18, FccwRot60: 1}, {FbaseCell: 10}, {FbaseCell: 11}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 1}, {FbaseCell: 3, FccwRot60: 5}, {FbaseCell: 7, FccwRot60: 5}}, // j 0
			{{FbaseCell: 8, FccwRot60: 1}, {}, {FbaseCell: 1, FccwRot60: 5}}, // j 1
			{{FbaseCell: 16, FccwRot60: 1}, {FbaseCell: 5}, {FbaseCell: 2}}}},
	{
		{ // face 2
			{
				{FbaseCell: 7}, {FbaseCell: 21}, {FbaseCell: 38}}, // j 0
			{{FbaseCell: 9}, {FbaseCell: 19}, {FbaseCell: 34, FccwRot60: 3}}, // j 1
			{{FbaseCell: 14, FccwRot60: 1}, {FbaseCell: 20, FccwRot60: 3}, {FbaseCell: 36, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 3}, {FbaseCell: 13, FccwRot60: 5}, {FbaseCell: 29, FccwRot60: 5}}, // j 0
			{{FbaseCell: 1}, {FbaseCell: 7}, {FbaseCell: 21}}, // j 1
			{{FbaseCell: 6, FccwRot60: 1}, {FbaseCell: 9}, {FbaseCell: 19}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 2}, {FbaseCell: 12, FccwRot60: 5}, {FbaseCell: 26, FccwRot60: 5}}, // j 0
			{{FccwRot60: 1}, {FbaseCell: 3}, {FbaseCell: 13, FccwRot60: 5}}, // j 1
			{{FbaseCell: 2, FccwRot60: 1}, {FbaseCell: 1}, {FbaseCell: 7}}}},
	{
		{ // face 3
			{
				{FbaseCell: 26}, {FbaseCell: 42}, {FbaseCell: 58}}, // j 0
			{{FbaseCell: 29}, {FbaseCell: 43}, {FbaseCell: 62, FccwRot60: 3}}, // j 1
			{{FbaseCell: 38, FccwRot60: 1}, {FbaseCell: 47, FccwRot60: 3}, {FbaseCell: 64, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 12}, {FbaseCell: 28, FccwRot60: 5}, {FbaseCell: 44, FccwRot60: 5}}, // j 0
			{{FbaseCell: 13}, {FbaseCell: 26}, {FbaseCell: 42}}, // j 1
			{{FbaseCell: 21, FccwRot60: 1}, {FbaseCell: 29}, {FbaseCell: 43}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 3}, {FbaseCell: 15, FccwRot60: 5}, {FbaseCell: 31, FccwRot60: 5}}, // j 0
			{{FbaseCell: 3, FccwRot60: 1}, {FbaseCell: 12}, {FbaseCell: 28, FccwRot60: 5}}, // j 1
			{{FbaseCell: 7, FccwRot60: 1}, {FbaseCell: 13}, {FbaseCell: 26}}}},
	{
		{ // face 4
			{
				{FbaseCell: 31}, {FbaseCell: 41}, {FbaseCell: 49}}, // j 0
			{{FbaseCell: 44}, {FbaseCell: 53}, {FbaseCell: 61, FccwRot60: 3}}, // j 1
			{{FbaseCell: 58, FccwRot60: 1}, {FbaseCell: 65, FccwRot60: 3}, {FbaseCell: 75, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 15}, {FbaseCell: 22, FccwRot60: 5}, {FbaseCell: 33, FccwRot60: 5}}, // j 0
			{{FbaseCell: 28}, {FbaseCell: 31}, {FbaseCell: 41}}, // j 1
			{{FbaseCell: 42, FccwRot60: 1}, {FbaseCell: 44}, {FbaseCell: 53}}},
		{
			{
				// i 2
				{FbaseCell: 4, FccwRot60: 4}, {FbaseCell: 8, FccwRot60: 5}, {FbaseCell: 16, FccwRot60: 5}}, // j 0
			{{FbaseCell: 12, FccwRot60: 1}, {FbaseCell: 15}, {FbaseCell: 22, FccwRot60: 5}}, // j 1
			{{FbaseCell: 26, FccwRot60: 1}, {FbaseCell: 28}, {FbaseCell: 31}}}},
	{
		{ // face 5
			{
				{FbaseCell: 50}, {FbaseCell: 48}, {FbaseCell: 49, FccwRot60: 3}}, // j 0
			{{FbaseCell: 32}, {FbaseCell: 30, FccwRot60: 3}, {FbaseCell: 33, FccwRot60: 3}}, // j 1
			{{FbaseCell: 24, FccwRot60: 3}, {FbaseCell: 18, FccwRot60: 3}, {FbaseCell: 16, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 70}, {FbaseCell: 67}, {FbaseCell: 66, FccwRot60: 3}}, // j 0
			{{FbaseCell: 52, FccwRot60: 3}, {FbaseCell: 50}, {FbaseCell: 48}}, // j 1
			{{FbaseCell: 37, FccwRot60: 3}, {FbaseCell: 32}, {FbaseCell: 30, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 83}, {FbaseCell: 87, FccwRot60: 3}, {FbaseCell: 85, FccwRot60: 3}}, // j 0
			{{FbaseCell: 74, FccwRot60: 3}, {FbaseCell: 70}, {FbaseCell: 67}}, // j 1
			{{FbaseCell: 57, FccwRot60: 1}, {FbaseCell: 52, FccwRot60: 3}, {FbaseCell: 50}}}},
	{
		{ // face 6
			{
				{FbaseCell: 25}, {FbaseCell: 23}, {FbaseCell: 24, FccwRot60: 3}}, // j 0
			{{FbaseCell: 17}, {FbaseCell: 11, FccwRot60: 3}, {FbaseCell: 10, FccwRot60: 3}}, // j 1
			{{FbaseCell: 14, FccwRot60: 3}, {FbaseCell: 6, FccwRot60: 3}, {FbaseCell: 2, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 45}, {FbaseCell: 39}, {FbaseCell: 37, FccwRot60: 3}}, // j 0
			{{FbaseCell: 35, FccwRot60: 3}, {FbaseCell: 25}, {FbaseCell: 23}}, // j 1
			{{FbaseCell: 27, FccwRot60: 3}, {FbaseCell: 17}, {FbaseCell: 11, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 63}, {FbaseCell: 59, FccwRot60: 3}, {FbaseCell: 57, FccwRot60: 3}}, // j 0
			{{FbaseCell: 56, FccwRot60: 3}, {FbaseCell: 45}, {FbaseCell: 39}}, // j 1
			{{FbaseCell: 46, FccwRot60: 3}, {FbaseCell: 35, FccwRot60: 3}, {FbaseCell: 25}}}},
	{
		{ // face 7
			{
				{FbaseCell: 36}, {FbaseCell: 20}, {FbaseCell: 14, FccwRot60: 3}}, // j 0
			{{FbaseCell: 34}, {FbaseCell: 19, FccwRot60: 3}, {FbaseCell: 9, FccwRot60: 3}}, // j 1
			{{FbaseCell: 38, FccwRot60: 3}, {FbaseCell: 21, FccwRot60: 3}, {FbaseCell: 7, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 55}, {FbaseCell: 40}, {FbaseCell: 27, FccwRot60: 3}}, // j 0
			{{FbaseCell: 54, FccwRot60: 3}, {FbaseCell: 36}, {FbaseCell: 20}}, // j 1
			{{FbaseCell: 51, FccwRot60: 3}, {FbaseCell: 34}, {FbaseCell: 19, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 72}, {FbaseCell: 60, FccwRot60: 3}, {FbaseCell: 46, FccwRot60: 3}}, // j 0
			{{FbaseCell: 73, FccwRot60: 3}, {FbaseCell: 55}, {FbaseCell: 40}}, // j 1
			{{FbaseCell: 71, FccwRot60: 3}, {FbaseCell: 54, FccwRot60: 3}, {FbaseCell: 36}}}},
	{
		{ // face 8
			{
				{FbaseCell: 64}, {FbaseCell: 47}, {FbaseCell: 38, FccwRot60: 3}}, // j 0
			{{FbaseCell: 62}, {FbaseCell: 43, FccwRot60: 3}, {FbaseCell: 29, FccwRot60: 3}}, // j 1
			{{FbaseCell: 58, FccwRot60: 3}, {FbaseCell: 42, FccwRot60: 3}, {FbaseCell: 26, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 84}, {FbaseCell: 69}, {FbaseCell: 51, FccwRot60: 3}}, // j 0
			{{FbaseCell: 82, FccwRot60: 3}, {FbaseCell: 64}, {FbaseCell: 47}}, // j 1
			{{FbaseCell: 76, FccwRot60: 3}, {FbaseCell: 62}, {FbaseCell: 43, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 97}, {FbaseCell: 89, FccwRot60: 3}, {FbaseCell: 71, FccwRot60: 3}}, // j 0
			{{FbaseCell: 98, FccwRot60: 3}, {FbaseCell: 84}, {FbaseCell: 69}}, // j 1
			{{FbaseCell: 96, FccwRot60: 3}, {FbaseCell: 82, FccwRot60: 3}, {FbaseCell: 64}}}},
	{
		{ // face 9
			{
				{FbaseCell: 75}, {FbaseCell: 65}, {FbaseCell: 58, FccwRot60: 3}}, // j 0
			{{FbaseCell: 61}, {FbaseCell: 53, FccwRot60: 3}, {FbaseCell: 44, FccwRot60: 3}}, // j 1
			{{FbaseCell: 49, FccwRot60: 3}, {FbaseCell: 41, FccwRot60: 3}, {FbaseCell: 31, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 94}, {FbaseCell: 86}, {FbaseCell: 76, FccwRot60: 3}}, // j 0
			{{FbaseCell: 81, FccwRot60: 3}, {FbaseCell: 75}, {FbaseCell: 65}}, // j 1
			{{FbaseCell: 66, FccwRot60: 3}, {FbaseCell: 61}, {FbaseCell: 53, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 107}, {FbaseCell: 104, FccwRot60: 3}, {FbaseCell: 96, FccwRot60: 3}}, // j 0
			{{FbaseCell: 101, FccwRot60: 3}, {FbaseCell: 94}, {FbaseCell: 86}}, // j 1
			{{FbaseCell: 85, FccwRot60: 3}, {FbaseCell: 81, FccwRot60: 3}, {FbaseCell: 75}}}},
	{
		{ // face 10
			{
				{FbaseCell: 57}, {FbaseCell: 59}, {FbaseCell: 63, FccwRot60: 3}}, // j 0
			{{FbaseCell: 74}, {FbaseCell: 78, FccwRot60: 3}, {FbaseCell: 79, FccwRot60: 3}}, // j 1
			{{FbaseCell: 83, FccwRot60: 3}, {FbaseCell: 92, FccwRot60: 3}, {FbaseCell: 95, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 37}, {FbaseCell: 39, FccwRot60: 3}, {FbaseCell: 45, FccwRot60: 3}}, // j 0
			{{FbaseCell: 52}, {FbaseCell: 57}, {FbaseCell: 59}}, // j 1
			{{FbaseCell: 70, FccwRot60: 3}, {FbaseCell: 74}, {FbaseCell: 78, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 24}, {FbaseCell: 23, FccwRot60: 3}, {FbaseCell: 25, FccwRot60: 3}}, // j 0
			{{FbaseCell: 32, FccwRot60: 3}, {FbaseCell: 37}, {FbaseCell: 39, FccwRot60: 3}}, // j 1
			{{FbaseCell: 50, FccwRot60: 3}, {FbaseCell: 52}, {FbaseCell: 57}}}},
	{
		{ // face 11
			{
				{FbaseCell: 46}, {FbaseCell: 60}, {FbaseCell: 72, FccwRot60: 3}}, // j 0
			{{FbaseCell: 56}, {FbaseCell: 68, FccwRot60: 3}, {FbaseCell: 80, FccwRot60: 3}}, // j 1
			{{FbaseCell: 63, FccwRot60: 3}, {FbaseCell: 77, FccwRot60: 3}, {FbaseCell: 90, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 27}, {FbaseCell: 40, FccwRot60: 3}, {FbaseCell: 55, FccwRot60: 3}}, // j 0
			{{FbaseCell: 35}, {FbaseCell: 46}, {FbaseCell: 60}}, // j 1
			{{FbaseCell: 45, FccwRot60: 3}, {FbaseCell: 56}, {FbaseCell: 68, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 14}, {FbaseCell: 20, FccwRot60: 3}, {FbaseCell: 36, FccwRot60: 3}}, // j 0
			{{FbaseCell: 17, FccwRot60: 3}, {FbaseCell: 27}, {FbaseCell: 40, FccwRot60: 3}}, // j 1
			{{FbaseCell: 25, FccwRot60: 3}, {FbaseCell: 35}, {FbaseCell: 46}}}},
	{
		{ // face 12
			{
				{FbaseCell: 71}, {FbaseCell: 89}, {FbaseCell: 97, FccwRot60: 3}}, // j 0
			{{FbaseCell: 73}, {FbaseCell: 91, FccwRot60: 3}, {FbaseCell: 103, FccwRot60: 3}}, // j 1
			{{FbaseCell: 72, FccwRot60: 3}, {FbaseCell: 88, FccwRot60: 3}, {FbaseCell: 105, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 51}, {FbaseCell: 69, FccwRot60: 3}, {FbaseCell: 84, FccwRot60: 3}}, // j 0
			{{FbaseCell: 54}, {FbaseCell: 71}, {FbaseCell: 89}}, // j 1
			{{FbaseCell: 55, FccwRot60: 3}, {FbaseCell: 73}, {FbaseCell: 91, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 38}, {FbaseCell: 47, FccwRot60: 3}, {FbaseCell: 64, FccwRot60: 3}}, // j 0
			{{FbaseCell: 34, FccwRot60: 3}, {FbaseCell: 51}, {FbaseCell: 69, FccwRot60: 3}}, // j 1
			{{FbaseCell: 36, FccwRot60: 3}, {FbaseCell: 54}, {FbaseCell: 71}}}},
	{
		{ // face 13
			{
				{FbaseCell: 96}, {FbaseCell: 104}, {FbaseCell: 107, FccwRot60: 3}}, // j 0
			{{FbaseCell: 98}, {FbaseCell: 110, FccwRot60: 3}, {FbaseCell: 115, FccwRot60: 3}}, // j 1
			{{FbaseCell: 97, FccwRot60: 3}, {FbaseCell: 111, FccwRot60: 3}, {FbaseCell: 119, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 76}, {FbaseCell: 86, FccwRot60: 3}, {FbaseCell: 94, FccwRot60: 3}}, // j 0
			{{FbaseCell: 82}, {FbaseCell: 96}, {FbaseCell: 104}}, // j 1
			{{FbaseCell: 84, FccwRot60: 3}, {FbaseCell: 98}, {FbaseCell: 110, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 58}, {FbaseCell: 65, FccwRot60: 3}, {FbaseCell: 75, FccwRot60: 3}}, // j 0
			{{FbaseCell: 62, FccwRot60: 3}, {FbaseCell: 76}, {FbaseCell: 86, FccwRot60: 3}}, // j 1
			{{FbaseCell: 64, FccwRot60: 3}, {FbaseCell: 82}, {FbaseCell: 96}}}},
	{
		{ // face 14
			{
				{FbaseCell: 85}, {FbaseCell: 87}, {FbaseCell: 83, FccwRot60: 3}}, // j 0
			{{FbaseCell: 101}, {FbaseCell: 102, FccwRot60: 3}, {FbaseCell: 100, FccwRot60: 3}}, // j 1
			{{FbaseCell: 107, FccwRot60: 3}, {FbaseCell: 112, FccwRot60: 3}, {FbaseCell: 114, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 66}, {FbaseCell: 67, FccwRot60: 3}, {FbaseCell: 70, FccwRot60: 3}}, // j 0
			{{FbaseCell: 81}, {FbaseCell: 85}, {FbaseCell: 87}}, // j 1
			{{FbaseCell: 94, FccwRot60: 3}, {FbaseCell: 101}, {FbaseCell: 102, FccwRot60: 3}}},
		{
			{
				// i 2
				{FbaseCell: 49}, {FbaseCell: 48, FccwRot60: 3}, {FbaseCell: 50, FccwRot60: 3}}, // j 0
			{{FbaseCell: 61, FccwRot60: 3}, {FbaseCell: 66}, {FbaseCell: 67, FccwRot60: 3}}, // j 1
			{{FbaseCell: 75, FccwRot60: 3}, {FbaseCell: 81}, {FbaseCell: 85}}}},
	{
		{ // face 15
			{
				{FbaseCell: 95}, {FbaseCell: 92}, {FbaseCell: 83}}, // j 0
			{{FbaseCell: 79}, {FbaseCell: 78}, {FbaseCell: 74, FccwRot60: 3}}, // j 1
			{{FbaseCell: 63, FccwRot60: 1}, {FbaseCell: 59, FccwRot60: 3}, {FbaseCell: 57, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 109}, {FbaseCell: 108}, {FbaseCell: 100, FccwRot60: 5}}, // j 0
			{{FbaseCell: 93, FccwRot60: 1}, {FbaseCell: 95}, {FbaseCell: 92}}, // j 1
			{{FbaseCell: 77, FccwRot60: 1}, {FbaseCell: 79}, {FbaseCell: 78}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 4}, {FbaseCell: 118, FccwRot60: 5}, {FbaseCell: 114, FccwRot60: 5}}, // j 0
			{{FbaseCell: 106, FccwRot60: 1}, {FbaseCell: 109}, {FbaseCell: 108}}, // j 1
			{{FbaseCell: 90, FccwRot60: 1}, {FbaseCell: 93, FccwRot60: 1}, {FbaseCell: 95}}}},
	{
		{ // face 16
			{
				{FbaseCell: 90}, {FbaseCell: 77}, {FbaseCell: 63}}, // j 0
			{{FbaseCell: 80}, {FbaseCell: 68}, {FbaseCell: 56, FccwRot60: 3}}, // j 1
			{{FbaseCell: 72, FccwRot60: 1}, {FbaseCell: 60, FccwRot60: 3}, {FbaseCell: 46, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 106}, {FbaseCell: 93}, {FbaseCell: 79, FccwRot60: 5}}, // j 0
			{{FbaseCell: 99, FccwRot60: 1}, {FbaseCell: 90}, {FbaseCell: 77}}, // j 1
			{{FbaseCell: 88, FccwRot60: 1}, {FbaseCell: 80}, {FbaseCell: 68}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 3}, {FbaseCell: 109, FccwRot60: 5}, {FbaseCell: 95, FccwRot60: 5}}, // j 0
			{{FbaseCell: 113, FccwRot60: 1}, {FbaseCell: 106}, {FbaseCell: 93}}, // j 1
			{{FbaseCell: 105, FccwRot60: 1}, {FbaseCell: 99, FccwRot60: 1}, {FbaseCell: 90}}}},
	{
		{ // face 17
			{
				{FbaseCell: 105}, {FbaseCell: 88}, {FbaseCell: 72}}, // j 0
			{{FbaseCell: 103}, {FbaseCell: 91}, {FbaseCell: 73, FccwRot60: 3}}, // j 1
			{{FbaseCell: 97, FccwRot60: 1}, {FbaseCell: 89, FccwRot60: 3}, {FbaseCell: 71, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 113}, {FbaseCell: 99}, {FbaseCell: 80, FccwRot60: 5}}, // j 0
			{{FbaseCell: 116, FccwRot60: 1}, {FbaseCell: 105}, {FbaseCell: 88}}, // j 1
			{{FbaseCell: 111, FccwRot60: 1}, {FbaseCell: 103}, {FbaseCell: 91}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 2}, {FbaseCell: 106, FccwRot60: 5}, {FbaseCell: 90, FccwRot60: 5}}, // j 0
			{{FbaseCell: 121, FccwRot60: 1}, {FbaseCell: 113}, {FbaseCell: 99}}, // j 1
			{{FbaseCell: 119, FccwRot60: 1}, {FbaseCell: 116, FccwRot60: 1}, {FbaseCell: 105}}}},
	{
		{ // face 18
			{
				{FbaseCell: 119}, {FbaseCell: 111}, {FbaseCell: 97}}, // j 0
			{{FbaseCell: 115}, {FbaseCell: 110}, {FbaseCell: 98, FccwRot60: 3}}, // j 1
			{{FbaseCell: 107, FccwRot60: 1}, {FbaseCell: 104, FccwRot60: 3}, {FbaseCell: 96, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 121}, {FbaseCell: 116}, {FbaseCell: 103, FccwRot60: 5}}, // j 0
			{{FbaseCell: 120, FccwRot60: 1}, {FbaseCell: 119}, {FbaseCell: 111}}, // j 1
			{{FbaseCell: 112, FccwRot60: 1}, {FbaseCell: 115}, {FbaseCell: 110}}},
		{
			{
				// i 2
				{FbaseCell: 117, FccwRot60: 1}, {FbaseCell: 113, FccwRot60: 5}, {FbaseCell: 105, FccwRot60: 5}}, // j 0
			{{FbaseCell: 118, FccwRot60: 1}, {FbaseCell: 121}, {FbaseCell: 116}}, // j 1
			{{FbaseCell: 114, FccwRot60: 1}, {FbaseCell: 120, FccwRot60: 1}, {FbaseCell: 119}}}},
	{
		{ // face 19
			{
				{FbaseCell: 114}, {FbaseCell: 112}, {FbaseCell: 107}}, // j 0
			{{FbaseCell: 100}, {FbaseCell: 102}, {FbaseCell: 101, FccwRot60: 3}}, // j 1
			{{FbaseCell: 83, FccwRot60: 1}, {FbaseCell: 87, FccwRot60: 3}, {FbaseCell: 85, FccwRot60: 3}}},
		{
			{
				// i 1
				{FbaseCell: 118}, {FbaseCell: 120}, {FbaseCell: 115, FccwRot60: 5}}, // j 0
			{{FbaseCell: 108, FccwRot60: 1}, {FbaseCell: 114}, {FbaseCell: 112}}, // j 1
			{{FbaseCell: 92, FccwRot60: 1}, {FbaseCell: 100}, {FbaseCell: 102}}},
		{
			{
				// i 2
				{FbaseCell: 117}, {FbaseCell: 121, FccwRot60: 5}, {FbaseCell: 119, FccwRot60: 5}}, // j 0
			{{FbaseCell: 109, FccwRot60: 1}, {FbaseCell: 118}, {FbaseCell: 120}},                // j 1
			{{FbaseCell: 95, FccwRot60: 1}, {FbaseCell: 108, FccwRot60: 1}, {FbaseCell: 114}}}}} /* baseCells.c:308:31 */

// * @brief Resolution 0 base cell data table.
//
// For each base cell, gives the "home" face and ijk+ coordinates on that face,
// whether or not the base cell is a pentagon. Additionally, if the base cell
// is a pentagon, the two cw offset rotation adjacent faces are given (-1
// indicates that no cw offset rotation faces exist for this base cell).
var XbaseCellData = [122]TBaseCellData{{

	FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fi: 1}}}, // base cell 0
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 1
	{FhomeFijk: TFaceIJK{Fface: 1}},                                                                           // base cell 2
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 3
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{-1, -1}},          // base cell 4
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 5
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fk: 1}}},                                                 // base cell 6
	{FhomeFijk: TFaceIJK{Fface: 2}},                                                                           // base cell 7
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 1}}},                                                           // base cell 8
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fj: 1}}},                                                 // base cell 9
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fj: 1}}},                                                 // base cell 10
	{FhomeFijk: TFaceIJK{Fface: 1, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                          // base cell 11
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 12
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                          // base cell 13
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{2, 6}}, // base cell 14
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fi: 1}}},                                                 // base cell 15
	{}, // base cell 16
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 17
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fk: 1}}},                                                             // base cell 18
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 19
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 20
	{FhomeFijk: TFaceIJK{Fface: 2, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 21
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                                      // base cell 22
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 23
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{1, 5}},   // base cell 24
	{FhomeFijk: TFaceIJK{Fface: 6}},                                                                             // base cell 25
	{FhomeFijk: TFaceIJK{Fface: 3}},                                                                             // base cell 26
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 27
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                            // base cell 28
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 29
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                                      // base cell 30
	{FhomeFijk: TFaceIJK{Fface: 4}},                                                                             // base cell 31
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 32
	{FhomeFijk: TFaceIJK{Fcoord: TCoordIJK{Fj: 1}}},                                                             // base cell 33
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 34
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 35
	{FhomeFijk: TFaceIJK{Fface: 7}},                                                                             // base cell 36
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 37
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{3, 7}},   // base cell 38
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 39
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 40
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 41
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 42
	{FhomeFijk: TFaceIJK{Fface: 3, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 43
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 44
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 45
	{FhomeFijk: TFaceIJK{Fface: 11}},                                                                            // base cell 46
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 47
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 48
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{0, 9}},   // base cell 49
	{FhomeFijk: TFaceIJK{Fface: 5}},                                                                             // base cell 50
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 51
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 52
	{FhomeFijk: TFaceIJK{Fface: 4, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                            // base cell 53
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 54
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 55
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 56
	{FhomeFijk: TFaceIJK{Fface: 10}},                                                                            // base cell 57
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{4, 8}},   // base cell 58
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 59
	{FhomeFijk: TFaceIJK{Fface: 11, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 60
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 61
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fj: 1}}},                                                   // base cell 62
	{FhomeFijk: TFaceIJK{Fface: 6, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{11, 15}},  // base cell 63
	{FhomeFijk: TFaceIJK{Fface: 8}},                                                                             // base cell 64
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fk: 1}}},                                                   // base cell 65
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 66
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 67
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 68
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 69
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 70
	{FhomeFijk: TFaceIJK{Fface: 12}},                                                                            // base cell 71
	{FhomeFijk: TFaceIJK{Fface: 7, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{12, 16}},  // base cell 72
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 73
	{FhomeFijk: TFaceIJK{Fface: 10, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 74
	{FhomeFijk: TFaceIJK{Fface: 9}},                                                                             // base cell 75
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 76
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 77
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 78
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 79
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 80
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 81
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fi: 1, Fj: 1}}},                                           // base cell 82
	{FhomeFijk: TFaceIJK{Fface: 5, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{10, 19}},  // base cell 83
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 84
	{FhomeFijk: TFaceIJK{Fface: 14}},                                                                            // base cell 85
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                            // base cell 86
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 87
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 88
	{FhomeFijk: TFaceIJK{Fface: 12, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 89
	{FhomeFijk: TFaceIJK{Fface: 16}},                                                                            // base cell 90
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 91
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 92
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 93
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 1}}},                                                   // base cell 94
	{FhomeFijk: TFaceIJK{Fface: 15}},                                                                            // base cell 95
	{FhomeFijk: TFaceIJK{Fface: 13}},                                                                            // base cell 96
	{FhomeFijk: TFaceIJK{Fface: 8, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{13, 17}},  // base cell 97
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 98
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 99
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 100
	{FhomeFijk: TFaceIJK{Fface: 14, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 101
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 102
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 103
	{FhomeFijk: TFaceIJK{Fface: 13, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 104
	{FhomeFijk: TFaceIJK{Fface: 17}},                                                                            // base cell 105
	{FhomeFijk: TFaceIJK{Fface: 16, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 106
	{FhomeFijk: TFaceIJK{Fface: 9, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{14, 18}},  // base cell 107
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 108
	{FhomeFijk: TFaceIJK{Fface: 15, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 109
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fj: 1, Fk: 1}}},                                           // base cell 110
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 111
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fk: 1}}},                                                  // base cell 112
	{FhomeFijk: TFaceIJK{Fface: 17, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 113
	{FhomeFijk: TFaceIJK{Fface: 19}},                                                                            // base cell 114
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fj: 1}}},                                                  // base cell 115
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 116
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 2}}, FisPentagon: 1, FcwOffsetPent: [2]int32{-1, -1}}, // base cell 117
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 1}}},                                                  // base cell 118
	{FhomeFijk: TFaceIJK{Fface: 18}},                                                                            // base cell 119
	{FhomeFijk: TFaceIJK{Fface: 19, Fcoord: TCoordIJK{Fi: 1, Fk: 1}}},                                           // base cell 120
	{FhomeFijk: TFaceIJK{Fface: 18, Fcoord: TCoordIJK{Fi: 1}}}}                                                  /* baseCells.c:697:20 */

// * @brief Return whether or not the indicated base cell is a pentagon.
func X_isBaseCellPentagon(tls *libc.TLS, baseCell int32) int32 { /* baseCells.c:824:5: */
	if baseCell < 0 || baseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return Dfalse
	}
	return XbaseCellData[baseCell].FisPentagon
}

// * @brief Return whether the indicated base cell is a pentagon where all
// neighbors are oriented towards it.
func X_isBaseCellPolarPentagon(tls *libc.TLS, baseCell int32) uint8 { /* baseCells.c:834:6: */
	return uint8(libc.Bool32(baseCell == 4 || baseCell == 117))
}

// * @brief Find base cell given FaceIJK.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, return the base cell located at that
// coordinate.
//
// Valid ijk+ lookup coordinates are from (0, 0, 0) to (2, 2, 2).
func X_faceIjkToBaseCell(tls *libc.TLS, h uintptr) int32 { /* baseCells.c:846:5: */
	return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fface)*216 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fi)*72 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fj)*24 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fk)*8)).FbaseCell
}

// * @brief Find base cell given FaceIJK.
//
// Given the face number and a resolution 0 ijk+ coordinate in that face's
// face-centered ijk coordinate system, return the number of 60' ccw rotations
// to rotate into the coordinate system of the base cell at that coordinates.
//
// Valid ijk+ lookup coordinates are from (0, 0, 0) to (2, 2, 2).
func X_faceIjkToBaseCellCCWrot60(tls *libc.TLS, h uintptr) int32 { /* baseCells.c:859:5: */
	return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fface)*216 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fi)*72 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fj)*24 + uintptr((*TFaceIJK)(unsafe.Pointer(h)).Fcoord.Fk)*8)).FccwRot60
}

// * @brief Find the FaceIJK given a base cell.
func X_baseCellToFaceIjk(tls *libc.TLS, baseCell int32, h uintptr) { /* baseCells.c:866:6: */
	*(*TFaceIJK)(unsafe.Pointer(h)) = XbaseCellData[baseCell].FhomeFijk
}

// *
// @brief Given a base cell and the face it appears on, return
//
//	the number of 60' ccw rotations for that base cell's
//	coordinate system.
//
// @returns The number of rotations, or INVALID_ROTATIONS if the base
//
//	cell is not found on the given face
func X_baseCellToCCWrot60(tls *libc.TLS, baseCell int32, face int32) int32 { /* baseCells.c:877:5: */
	if face < 0 || face > DNUM_ICOSA_FACES {
		return -1
	}
	{
		var i int32 = 0
		for ; i < 3; i++ {
			{
				var j int32 = 0
				for ; j < 3; j++ {
					{
						var k int32 = 0
						for ; k < 3; k++ {
							if (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells))+uintptr(face)*216+uintptr(i)*72+uintptr(j)*24+uintptr(k)*8)).FbaseCell == baseCell {
								return (*TBaseCellRotation)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceIjkBaseCells)) + uintptr(face)*216 + uintptr(i)*72 + uintptr(j)*24 + uintptr(k)*8)).FccwRot60
							}
						}
					}
				}
			}
		}
	}
	return -1
}

// * @brief Return whether or not the tested face is a cw offset face.
func X_baseCellIsCwOffset(tls *libc.TLS, baseCell int32, testFace int32) uint8 { /* baseCells.c:893:6: */
	return uint8(libc.Bool32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellData)) + uintptr(baseCell)*28 + 20)) == testFace || *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellData)) + uintptr(baseCell)*28 + 20 + 1*4)) == testFace))
}

// * @brief Return the neighboring base cell in the given direction.
func X_getBaseCellNeighbor(tls *libc.TLS, baseCell int32, dir uint32) int32 { /* baseCells.c:900:5: */
	return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbors)) + uintptr(baseCell)*28 + uintptr(dir)*4))
}

// * @brief Return the direction from the origin base cell to the neighbor.
// Returns INVALID_DIGIT if the base cells are not neighbors.
func X_getBaseCellDirection(tls *libc.TLS, originBaseCell int32, neighboringBaseCell int32) uint32 { /* baseCells.c:907:11: */
	{
		var dir uint32 = CENTER_DIGIT
		for ; dir < NUM_DIGITS; dir++ {
			var testBaseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
			if testBaseCell == neighboringBaseCell {
				return dir
			}
		}
	}
	return INVALID_DIGIT
}

// *
// res0CellCount returns the number of resolution 0 cells
//
// @return int count of resolution 0 cells
func Xres0CellCount(tls *libc.TLS) int32 { /* baseCells.c:922:5: */
	return DNUM_BASE_CELLS
}

// *
// getRes0Cells generates all base cells storing them into the provided
// memory pointer. Buffer must be of size NUM_BASE_CELLS * sizeof(H3Index).
//
// @param out H3Index* the memory to store the resulting base cells in
// @returns E_SUCCESS.
func XgetRes0Cells(tls *libc.TLS, out uintptr) uint32 { /* baseCells.c:931:9: */
	{
		var bc int32 = 0
		for ; bc < DNUM_BASE_CELLS; bc++ {
			var baseCell uint64 = 35184372088831
			baseCell = baseCell&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
			baseCell = baseCell&libc.CplUint64(uint64(uint64(127))<<DH3_BC_OFFSET) | uint64(bc)<<DH3_BC_OFFSET
			*(*uint64)(unsafe.Pointer(out + uintptr(bc)*8)) = baseCell
		}
	}
	return E_SUCCESS
}

// *
// Width of the bounding box, in rads
// @param  bbox Bounding box to inspect
// @return      width, in rads
func XbboxWidthRads(tls *libc.TLS, bbox uintptr) float64 { /* bbox.c:37:8: */
	if XbboxIsTransmeridian(tls, bbox) != 0 {
		return (*TBBox)(unsafe.Pointer(bbox)).Feast - (*TBBox)(unsafe.Pointer(bbox)).Fwest + 6.28318530717958647692528676655900576839433
	}
	return (*TBBox)(unsafe.Pointer(bbox)).Feast - (*TBBox)(unsafe.Pointer(bbox)).Fwest
}

// *
// Height of the bounding box
// @param  bbox Bounding box to inspect
// @return      height, in rads
func XbboxHeightRads(tls *libc.TLS, bbox uintptr) float64 { /* bbox.c:47:8: */
	return (*TBBox)(unsafe.Pointer(bbox)).Fnorth - (*TBBox)(unsafe.Pointer(bbox)).Fsouth
}

// *
// Whether the given bounding box crosses the antimeridian
// @param  bbox Bounding box to inspect
// @return      is transmeridian
func XbboxIsTransmeridian(tls *libc.TLS, bbox uintptr) uint8 { /* bbox.c:54:6: */
	return uint8(libc.Bool32((*TBBox)(unsafe.Pointer(bbox)).Feast < (*TBBox)(unsafe.Pointer(bbox)).Fwest))
}

// *
// Get the center of a bounding box
// @param bbox   Input bounding box
// @param center Output center coordinate
func XbboxCenter(tls *libc.TLS, bbox uintptr, center uintptr) { /* bbox.c:61:6: */
	(*TLatLng)(unsafe.Pointer(center)).Flat = ((*TBBox)(unsafe.Pointer(bbox)).Fnorth + (*TBBox)(unsafe.Pointer(bbox)).Fsouth) * 0.5
	// If the bbox crosses the antimeridian, shift east 360 degrees
	var east float64
	if XbboxIsTransmeridian(tls, bbox) != 0 {
		east = (*TBBox)(unsafe.Pointer(bbox)).Feast + 6.28318530717958647692528676655900576839433
	} else {
		east = (*TBBox)(unsafe.Pointer(bbox)).Feast
	}
	(*TLatLng)(unsafe.Pointer(center)).Flng = XconstrainLng(tls, (east+(*TBBox)(unsafe.Pointer(bbox)).Fwest)*0.5)
}

// *
// Whether the bounding box contains a given point
// @param  bbox  Bounding box
// @param  point Point to test
// @return       Whether the point is contained
func XbboxContains(tls *libc.TLS, bbox uintptr, point uintptr) uint8 { /* bbox.c:74:6: */
	return uint8(libc.Bool32((*TLatLng)(unsafe.Pointer(point)).Flat >= (*TBBox)(unsafe.Pointer(bbox)).Fsouth && (*TLatLng)(unsafe.Pointer(point)).Flat <= (*TBBox)(unsafe.Pointer(bbox)).Fnorth && func() int32 {
		if XbboxIsTransmeridian(tls, bbox) != 0 {
			return libc.Bool32((*TLatLng)(unsafe.Pointer(point)).Flng >= (*TBBox)(unsafe.Pointer(bbox)).Fwest || (*TLatLng)(unsafe.Pointer(point)).Flng <= (*TBBox)(unsafe.Pointer(bbox)).Feast)
		}
		return libc.Bool32((*TLatLng)(unsafe.Pointer(point)).Flng >= (*TBBox)(unsafe.Pointer(bbox)).Fwest && (*TLatLng)(unsafe.Pointer(point)).Flng <= (*TBBox)(unsafe.Pointer(bbox)).Feast)
	}() != 0))
}

// *
// Whether two bounding boxes overlap
// @param  a First bounding box
// @param  b Second bounding box
// @return   Whether the bounding boxes overlap
func XbboxOverlapsBBox(tls *libc.TLS, a uintptr, b uintptr) uint8 { /* bbox.c:90:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// Check whether latitude coords overlap
	if (*TBBox)(unsafe.Pointer(a)).Fnorth < (*TBBox)(unsafe.Pointer(b)).Fsouth || (*TBBox)(unsafe.Pointer(a)).Fsouth > (*TBBox)(unsafe.Pointer(b)).Fnorth {
		return uint8(Dfalse)
	}

	// Check whether longitude coords overlap, accounting for transmeridian
	// bboxes
	// var aNormalization uint32 at bp, 4

	// var bNormalization uint32 at bp+4, 4

	XbboxNormalization(tls, a, b, bp, bp+4)

	if XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(a)).Feast, *(*uint32)(unsafe.Pointer(bp))) < XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(b)).Fwest, *(*uint32)(unsafe.Pointer(bp + 4))) || XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(a)).Fwest, *(*uint32)(unsafe.Pointer(bp))) > XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(b)).Feast, *(*uint32)(unsafe.Pointer(bp + 4))) {
		return uint8(Dfalse)
	}

	return uint8(Dtrue)
}

// *
// Whether one bounding box contains another
// @param  a First bounding box
// @param  b Second bounding box
// @return   Whether a contains b
func XbboxContainsBBox(tls *libc.TLS, a uintptr, b uintptr) uint8 { /* bbox.c:118:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// Check whether latitude coords are contained
	if (*TBBox)(unsafe.Pointer(a)).Fnorth < (*TBBox)(unsafe.Pointer(b)).Fnorth || (*TBBox)(unsafe.Pointer(a)).Fsouth > (*TBBox)(unsafe.Pointer(b)).Fsouth {
		return uint8(Dfalse)
	}
	// Check whether longitude coords are contained
	// Account for transmeridian bboxes
	// var aNormalization uint32 at bp, 4

	// var bNormalization uint32 at bp+4, 4

	XbboxNormalization(tls, a, b, bp, bp+4)
	return uint8(libc.Bool32(XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(a)).Fwest, *(*uint32)(unsafe.Pointer(bp))) <= XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(b)).Fwest, *(*uint32)(unsafe.Pointer(bp + 4))) && XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(a)).Feast, *(*uint32)(unsafe.Pointer(bp))) >= XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(b)).Feast, *(*uint32)(unsafe.Pointer(bp + 4)))))
}

// *
// Whether two bounding boxes are strictly equal
// @param  b1 Bounding box 1
// @param  b2 Bounding box 2
// @return    Whether the boxes are equal
func XbboxEquals(tls *libc.TLS, b1 uintptr, b2 uintptr) uint8 { /* bbox.c:140:6: */
	return uint8(libc.Bool32((*TBBox)(unsafe.Pointer(b1)).Fnorth == (*TBBox)(unsafe.Pointer(b2)).Fnorth && (*TBBox)(unsafe.Pointer(b1)).Fsouth == (*TBBox)(unsafe.Pointer(b2)).Fsouth && (*TBBox)(unsafe.Pointer(b1)).Feast == (*TBBox)(unsafe.Pointer(b2)).Feast && (*TBBox)(unsafe.Pointer(b1)).Fwest == (*TBBox)(unsafe.Pointer(b2)).Fwest))
}

func XbboxToCellBoundary(tls *libc.TLS, bbox uintptr) TCellBoundary { /* bbox.c:145:14: */
	// Convert bbox to cell boundary, CCW vertex order
	var bboxBoundary = TCellBoundary{FnumVerts: 4, Fverts: [10]TLatLng{0: {Flat: (*TBBox)(unsafe.Pointer(bbox)).Fnorth, Flng: (*TBBox)(unsafe.Pointer(bbox)).Feast},
		1: {Flat: (*TBBox)(unsafe.Pointer(bbox)).Fnorth, Flng: (*TBBox)(unsafe.Pointer(bbox)).Fwest},
		2: {Flat: (*TBBox)(unsafe.Pointer(bbox)).Fsouth, Flng: (*TBBox)(unsafe.Pointer(bbox)).Fwest},
		3: {Flat: (*TBBox)(unsafe.Pointer(bbox)).Fsouth, Flng: (*TBBox)(unsafe.Pointer(bbox)).Feast}}}
	return bboxBoundary
}

// *
// _hexRadiusKm returns the radius of a given hexagon in Km
//
// @param h3Index the index of the hexagon
// @return the radius of the hexagon in Km
func X_hexRadiusKm(tls *libc.TLS, h3Index uint64) float64 { /* bbox.c:161:8: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// There is probably a cheaper way to determine the radius of a
	// hexagon, but this way is conceptually simple
	// var h3Center TLatLng at bp, 16

	// var h3Boundary TCellBoundary at bp+16, 168

	XcellToLatLng(tls, h3Index, bp)
	XcellToBoundary(tls, h3Index, bp+16)
	return XgreatCircleDistanceKm(tls, bp, bp+16+8)
}

// *
// bboxHexEstimate returns an estimated number of hexagons that fit
//
//	within the cartesian-projected bounding box
//
// @param bbox the bounding box to estimate the hexagon fill level
// @param res the resolution of the H3 hexagons to fill the bounding box
// @param out the estimated number of hexagons to fill the bounding box
// @return E_SUCCESS (0) on success, or another value otherwise.
func XbboxHexEstimate(tls *libc.TLS, bbox uintptr, res int32, out uintptr) uint32 { /* bbox.c:180:9: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	// Get the area of the pentagon as the maximally-distorted area possible
	*(*[12]uint64)(unsafe.Pointer(bp /* pentagons */)) = [12]uint64{0: uint64(0)}
	var pentagonsErr uint32 = XgetPentagons(tls, res, bp)
	if pentagonsErr != 0 {
		return pentagonsErr
	}
	var pentagonRadiusKm float64 = X_hexRadiusKm(tls, *(*uint64)(unsafe.Pointer(bp)))
	// Area of a regular hexagon is 3/2*sqrt(3) * r * r
	// The pentagon has the most distortion (smallest edges) and shares its
	// edges with hexagons, so the most-distorted hexagons have this area,
	// shrunk by 20% off chance that the bounding box perfectly bounds a
	// pentagon.
	var pentagonAreaKm2 float64 = 0.8 * (2.59807621135 * pentagonRadiusKm * pentagonRadiusKm)

	// Then get the area of the bounding box of the geoloop in question
	// var p1 TLatLng at bp+96, 16

	// var p2 TLatLng at bp+112, 16

	(*TLatLng)(unsafe.Pointer(bp + 96 /* &p1 */)).Flat = (*TBBox)(unsafe.Pointer(bbox)).Fnorth
	(*TLatLng)(unsafe.Pointer(bp + 96 /* &p1 */)).Flng = (*TBBox)(unsafe.Pointer(bbox)).Feast
	(*TLatLng)(unsafe.Pointer(bp + 112 /* &p2 */)).Flat = (*TBBox)(unsafe.Pointer(bbox)).Fsouth
	(*TLatLng)(unsafe.Pointer(bp + 112 /* &p2 */)).Flng = (*TBBox)(unsafe.Pointer(bbox)).Fwest
	var d float64 = XgreatCircleDistanceKm(tls, bp+96, bp+112)
	var lngDiff float64 = libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(bp+96)).Flng-(*TLatLng)(unsafe.Pointer(bp+112)).Flng)
	var latDiff float64 = libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(bp+96)).Flat-(*TLatLng)(unsafe.Pointer(bp+112)).Flat)
	if lngDiff == float64(0) || latDiff == float64(0) {
		return E_FAILED
	}
	var length float64 = Xfmax(tls, lngDiff, latDiff)
	var width float64 = Xfmin(tls, lngDiff, latDiff)
	var ratio float64 = length / width
	// Derived constant based on: https://math.stackexchange.com/a/1921940
	// Clamped to 3 as higher values tend to rapidly drag the estimate to zero.
	var a float64 = d * d / Xfmin(tls, 3.0, ratio)

	// Divide the two to get an estimate of the number of hexagons needed
	var estimateDouble float64 = libc.Xceil(tls, a/pentagonAreaKm2)
	if !(XisXfinite(tls, estimateDouble) != 0) {
		return E_FAILED
	}
	var estimate int64 = int64(estimateDouble)
	if estimate == int64(0) {
		estimate = int64(1)
	}
	*(*int64)(unsafe.Pointer(out)) = estimate
	return E_SUCCESS
}

// *
// lineHexEstimate returns an estimated number of hexagons that trace
//
//	the cartesian-projected line
//
// @param origin the origin coordinates
// @param destination the destination coordinates
// @param res the resolution of the H3 hexagons to trace the line
// @param out Out parameter for the estimated number of hexagons required to
// trace the line
// @return E_SUCCESS (0) on success or another value otherwise.
func XlineHexEstimate(tls *libc.TLS, origin uintptr, destination uintptr, res int32, out uintptr) uint32 { /* bbox.c:237:9: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// Get the area of the pentagon as the maximally-distorted area possible
	*(*[12]uint64)(unsafe.Pointer(bp /* pentagons */)) = [12]uint64{0: uint64(0)}
	var pentagonsErr uint32 = XgetPentagons(tls, res, bp)
	if pentagonsErr != 0 {
		return pentagonsErr
	}
	var pentagonRadiusKm float64 = X_hexRadiusKm(tls, *(*uint64)(unsafe.Pointer(bp)))

	var dist float64 = XgreatCircleDistanceKm(tls, origin, destination)
	var distCeil float64 = libc.Xceil(tls, dist/(float64(2)*pentagonRadiusKm))
	if !(XisXfinite(tls, distCeil) != 0) {
		return E_FAILED
	}
	var estimate int64 = int64(distCeil)
	if estimate == int64(0) {
		estimate = int64(1)
	}
	*(*int64)(unsafe.Pointer(out)) = estimate
	return E_SUCCESS
}

// *
// Scale a given bounding box by some factor. Scales both width and height
// by the factor, rather than scaling area, which will scale at scale^2.
// Note that this function is meant to handle bounding boxes and scales,
// within a reasonable domain, and does not guarantee reasonable results for
// extreme values.
// @param bbox Bounding box to scale, in-place
// @param scale Scale factor
func XscaleBBox(tls *libc.TLS, bbox uintptr, scale float64) { /* bbox.c:267:6: */
	var width float64 = XbboxWidthRads(tls, bbox)
	var height float64 = XbboxHeightRads(tls, bbox)
	var widthBuffer float64 = (width*scale - width) * 0.5
	var heightBuffer float64 = (height*scale - height) * 0.5
	// Scale north and south, clamping to latitude domain
	*(*float64)(unsafe.Pointer(bbox)) += heightBuffer
	if (*TBBox)(unsafe.Pointer(bbox)).Fnorth > 1.57079632679489661923 {
		(*TBBox)(unsafe.Pointer(bbox)).Fnorth = 1.57079632679489661923
	}
	*(*float64)(unsafe.Pointer(bbox + 8)) -= heightBuffer
	if (*TBBox)(unsafe.Pointer(bbox)).Fsouth < -1.57079632679489661923 {
		(*TBBox)(unsafe.Pointer(bbox)).Fsouth = -1.57079632679489661923
	}
	// Scale east and west, clamping to longitude domain
	*(*float64)(unsafe.Pointer(bbox + 16)) += widthBuffer
	if (*TBBox)(unsafe.Pointer(bbox)).Feast > 3.14159265358979323846 {
		*(*float64)(unsafe.Pointer(bbox + 16)) -= 6.28318530717958647692528676655900576839433
	}
	if (*TBBox)(unsafe.Pointer(bbox)).Feast < -3.14159265358979323846 {
		*(*float64)(unsafe.Pointer(bbox + 16)) += 6.28318530717958647692528676655900576839433
	}
	*(*float64)(unsafe.Pointer(bbox + 24)) -= widthBuffer
	if (*TBBox)(unsafe.Pointer(bbox)).Fwest > 3.14159265358979323846 {
		*(*float64)(unsafe.Pointer(bbox + 24)) -= 6.28318530717958647692528676655900576839433
	}
	if (*TBBox)(unsafe.Pointer(bbox)).Fwest < -3.14159265358979323846 {
		*(*float64)(unsafe.Pointer(bbox + 24)) += 6.28318530717958647692528676655900576839433
	}
}

// *
// Determine the longitude normalization scheme for two bounding boxes, either
// or both of which might cross the antimeridian. The goal is to transform
// latitudes in one or both boxes so that they are in the same frame of
// reference and can be operated on with standard Cartesian functions.
// @param a              First bounding box
// @param b              Second bounding box
// @param aNormalization Output: Normalization for longitudes in the first box
// @param bNormalization Output: Normalization for longitudes in the second box
func XbboxNormalization(tls *libc.TLS, a uintptr, b uintptr, aNormalization uintptr, bNormalization uintptr) { /* bbox.c:296:6: */
	var aIsTransmeridian uint8 = XbboxIsTransmeridian(tls, a)
	var bIsTransmeridian uint8 = XbboxIsTransmeridian(tls, b)
	var aToBTrendsEast uint8 = uint8(libc.Bool32((*TBBox)(unsafe.Pointer(a)).Fwest-(*TBBox)(unsafe.Pointer(b)).Feast < (*TBBox)(unsafe.Pointer(b)).Fwest-(*TBBox)(unsafe.Pointer(a)).Feast))
	// If neither is transmeridian, no normalization.
	// If both are transmeridian, normalize east by convention.
	// If one is transmeridian and one is not, normalize toward the other.
	*(*uint32)(unsafe.Pointer(aNormalization)) = func() uint32 {
		if !(aIsTransmeridian != 0) {
			return NORMALIZE_NONE
		}
		return func() uint32 {
			if bIsTransmeridian != 0 {
				return NORMALIZE_EAST
			}
			return func() uint32 {
				if aToBTrendsEast != 0 {
					return NORMALIZE_EAST
				}
				return NORMALIZE_WEST
			}()
		}()
	}()
	*(*uint32)(unsafe.Pointer(bNormalization)) = func() uint32 {
		if !(bIsTransmeridian != 0) {
			return NORMALIZE_NONE
		}
		return func() uint32 {
			if aIsTransmeridian != 0 {
				return NORMALIZE_EAST
			}
			return func() uint32 {
				if aToBTrendsEast != 0 {
					return NORMALIZE_WEST
				}
				return NORMALIZE_EAST
			}()
		}()
	}()
}

// * @brief CoordIJK unit vectors corresponding to the 7 H3 digits.
var sUNIT_VECS3 = [7]TCoordIJK{
	{},             // direction 0
	{Fk: 1},        // direction 1
	{Fj: 1},        // direction 2
	{Fj: 1, Fk: 1}, // direction 3
	{Fi: 1},        // direction 4
	{Fi: 1, Fk: 1}, // direction 5
	{Fi: 1, Fj: 1}, // direction 6
} /* coordijk.h:50:23 */

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// The testcase() macro is used to aid in coverage testing.  When
// doing coverage testing, the condition inside the argument to
// testcase() must be evaluated both true and false in order to
// get full branch coverage.  The testcase() macro is inserted
// to help ensure adequate test coverage in places where simple
// condition/decision coverage is inadequate.  For example, testcase()
// can be used to make sure boundary values are tested.  For
// bitmask tests, testcase() can be used to make sure each bit
// is significant and used at least once.  On switch statements
// where multiple cases go to the same block of code, testcase()
// can insure that all cases are evaluated.

// Disable ALWAYS() and NEVER() (make them pass-throughs) for coverage
// and mutation testing

// The TESTONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within testcase() and assert() macros.

// The DEFENSEONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within ALWAYS() or NEVER() macros.

// The ALWAYS and NEVER macros surround boolean expressions which
// are intended to always be true or false, respectively.  Such
// expressions could be omitted from the code completely.  But they
// are included in a few cases in order to enhance the resilience
// of the H3 library to unexpected behavior - to make the code "self-healing"
// or "ductile" rather than being "brittle" and crashing at the first
// hint of unplanned behavior.
//
// In other words, ALWAYS and NEVER are added for defensive code.
//
// When doing coverage testing ALWAYS and NEVER are hard-coded to
// be true and false so that the unreachable code they specify will
// not be counted as untested code.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2017-2018, 2022 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file mathExtensions.h
// @brief   Math functions that should've been in math.h but aren't

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// *
// MAX returns the maximum of two values.

// * Evaluates to true if a + b would overflow for int32
func sADD_INT32S_OVERFLOWS(tls *libc.TLS, a int32, b int32) uint8 { /* mathExtensions.h:32:20: */
	if a > 0 {
		return uint8(libc.Bool32(2147483647-a < b))
	} else {
		return uint8(libc.Bool32(-2147483647-1-a > b))
	}
	return uint8(0)
}

// * Evaluates to true if a - b would overflow for int32
func sSUB_INT32S_OVERFLOWS(tls *libc.TLS, a int32, b int32) uint8 { /* mathExtensions.h:41:20: */
	if a >= 0 {
		return uint8(libc.Bool32(-2147483647-1+a >= b))
	} else {
		return uint8(libc.Bool32(2147483647+a+1 < b))
	}
	return uint8(0)
}

// *
// Sets an IJK coordinate to the specified component values.
//
// @param ijk The IJK coordinate to set.
// @param i The desired i component value.
// @param j The desired j component value.
// @param k The desired k component value.
func X_setIJK(tls *libc.TLS, ijk uintptr, i int32, j int32, k int32) { /* coordijk.c:43:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = i
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = j
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = k
}

// *
// Determine the containing hex in ijk+ coordinates for a 2D cartesian
// coordinate vector (from DGGRID).
//
// @param v The 2D cartesian coordinate vector.
// @param h The ijk+ coordinates of the containing hex.
func X_hex2dToCoordIJK(tls *libc.TLS, v uintptr, h uintptr) { /* coordijk.c:56:6: */
	var a1 float64
	var a2 float64
	var x1 float64
	var x2 float64
	var m1 int32
	var m2 int32
	var r1 float64
	var r2 float64

	// quantize into the ij system and then normalize
	(*TCoordIJK)(unsafe.Pointer(h)).Fk = 0

	a1 = libc.Xfabsl(tls, (*TVec2d)(unsafe.Pointer(v)).Fx)
	a2 = libc.Xfabsl(tls, (*TVec2d)(unsafe.Pointer(v)).Fy)

	// first do a reverse conversion
	x2 = a2 * 1.1547005383792515290182975610039149112953
	x1 = a1 + x2/2.0

	// check if we have the center of a hex
	m1 = int32(x1)
	m2 = int32(x2)

	// otherwise round correctly
	r1 = x1 - float64(m1)
	r2 = x2 - float64(m2)

	if r1 < 0.5 {
		if r1 < float64(1.0)/3.0 {
			if r2 < (1.0+r1)/2.0 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}
		} else {
			if r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}

			if 1.0-r1 <= r2 && r2 < 2.0*r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
			}
		}
	} else {
		if r1 < float64(2.0)/3.0 {
			if r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}

			if 2.0*r1-1.0 < r2 && r2 < 1.0-r1 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
			}
		} else {
			if r2 < r1/2.0 {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2
			} else {
				(*TCoordIJK)(unsafe.Pointer(h)).Fi = m1 + 1
				(*TCoordIJK)(unsafe.Pointer(h)).Fj = m2 + 1
			}
		}
	}

	// now fold across the axes if necessary

	if (*TVec2d)(unsafe.Pointer(v)).Fx < 0.0 {
		if (*TCoordIJK)(unsafe.Pointer(h)).Fj%2 == 0 {
			var axisi int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fj / 2)
			var diff int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - axisi
			(*TCoordIJK)(unsafe.Pointer(h)).Fi = libc.Int32FromFloat64(float64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - 2.0*float64(diff))
		} else {
			var axisi int64 = int64(((*TCoordIJK)(unsafe.Pointer(h)).Fj + 1) / 2)
			var diff int64 = int64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - axisi
			(*TCoordIJK)(unsafe.Pointer(h)).Fi = libc.Int32FromFloat64(float64((*TCoordIJK)(unsafe.Pointer(h)).Fi) - (2.0*float64(diff) + float64(1)))
		}
	}

	if (*TVec2d)(unsafe.Pointer(v)).Fy < 0.0 {
		(*TCoordIJK)(unsafe.Pointer(h)).Fi = (*TCoordIJK)(unsafe.Pointer(h)).Fi - (2*(*TCoordIJK)(unsafe.Pointer(h)).Fj+1)/2
		(*TCoordIJK)(unsafe.Pointer(h)).Fj = -1 * (*TCoordIJK)(unsafe.Pointer(h)).Fj
	}

	X_ijkNormalize(tls, h)
}

// *
// Find the center point in 2D cartesian coordinates of a hex.
//
// @param h The ijk coordinates of the hex.
// @param v The 2D cartesian coordinates of the hex center point.
func X_ijkToHex2d(tls *libc.TLS, h uintptr, v uintptr) { /* coordijk.c:155:6: */
	var i int32 = (*TCoordIJK)(unsafe.Pointer(h)).Fi - (*TCoordIJK)(unsafe.Pointer(h)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(h)).Fj - (*TCoordIJK)(unsafe.Pointer(h)).Fk

	(*TVec2d)(unsafe.Pointer(v)).Fx = float64(i) - 0.5*float64(j)
	(*TVec2d)(unsafe.Pointer(v)).Fy = float64(j) * 0.8660254037844386467637231707529361834714
}

// *
// Returns whether or not two ijk coordinates contain exactly the same
// component values.
//
// @param c1 The first set of ijk coordinates.
// @param c2 The second set of ijk coordinates.
// @return 1 if the two addresses match, 0 if they do not.
func X_ijkMatches(tls *libc.TLS, c1 uintptr, c2 uintptr) int32 { /* coordijk.c:171:5: */
	return libc.Bool32((*TCoordIJK)(unsafe.Pointer(c1)).Fi == (*TCoordIJK)(unsafe.Pointer(c2)).Fi && (*TCoordIJK)(unsafe.Pointer(c1)).Fj == (*TCoordIJK)(unsafe.Pointer(c2)).Fj && (*TCoordIJK)(unsafe.Pointer(c1)).Fk == (*TCoordIJK)(unsafe.Pointer(c2)).Fk)
}

// *
// Add two ijk coordinates.
//
// @param h1 The first set of ijk coordinates.
// @param h2 The second set of ijk coordinates.
// @param sum The sum of the two sets of ijk coordinates.
func X_ijkAdd(tls *libc.TLS, h1 uintptr, h2 uintptr, sum uintptr) { /* coordijk.c:182:6: */
	(*TCoordIJK)(unsafe.Pointer(sum)).Fi = (*TCoordIJK)(unsafe.Pointer(h1)).Fi + (*TCoordIJK)(unsafe.Pointer(h2)).Fi
	(*TCoordIJK)(unsafe.Pointer(sum)).Fj = (*TCoordIJK)(unsafe.Pointer(h1)).Fj + (*TCoordIJK)(unsafe.Pointer(h2)).Fj
	(*TCoordIJK)(unsafe.Pointer(sum)).Fk = (*TCoordIJK)(unsafe.Pointer(h1)).Fk + (*TCoordIJK)(unsafe.Pointer(h2)).Fk
}

// *
// Subtract two ijk coordinates.
//
// @param h1 The first set of ijk coordinates.
// @param h2 The second set of ijk coordinates.
// @param diff The difference of the two sets of ijk coordinates (h1 - h2).
func X_ijkSub(tls *libc.TLS, h1 uintptr, h2 uintptr, diff uintptr) { /* coordijk.c:195:6: */
	(*TCoordIJK)(unsafe.Pointer(diff)).Fi = (*TCoordIJK)(unsafe.Pointer(h1)).Fi - (*TCoordIJK)(unsafe.Pointer(h2)).Fi
	(*TCoordIJK)(unsafe.Pointer(diff)).Fj = (*TCoordIJK)(unsafe.Pointer(h1)).Fj - (*TCoordIJK)(unsafe.Pointer(h2)).Fj
	(*TCoordIJK)(unsafe.Pointer(diff)).Fk = (*TCoordIJK)(unsafe.Pointer(h1)).Fk - (*TCoordIJK)(unsafe.Pointer(h2)).Fk
}

// *
// Uniformly scale ijk coordinates by a scalar. Works in place.
//
// @param c The ijk coordinates to scale.
// @param factor The scaling factor.
func X_ijkScale(tls *libc.TLS, c uintptr, factor int32) { /* coordijk.c:207:6: */
	*(*int32)(unsafe.Pointer(c)) *= factor
	*(*int32)(unsafe.Pointer(c + 4)) *= factor
	*(*int32)(unsafe.Pointer(c + 8)) *= factor
}

// *
// Returns true if _ijkNormalize with the given input could have a signed
// integer overflow. Assumes k is set to 0.
func X_ijkNormalizeCouldOverflow(tls *libc.TLS, ijk uintptr) uint8 { /* coordijk.c:217:6: */
	// Check for the possibility of overflow
	var max int32
	var min int32
	if (*TCoordIJK)(unsafe.Pointer(ijk)).Fi > (*TCoordIJK)(unsafe.Pointer(ijk)).Fj {
		max = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi
		min = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj
	} else {
		max = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj
		min = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi
	}
	if min < 0 {
		// Only if the min is less than 0 will the resulting number be larger
		// than max. If min is positive, then max is also positive, and a
		// positive signed integer minus another positive signed integer will
		// not overflow.
		if sADD_INT32S_OVERFLOWS(tls, max, min) != 0 {
			// max + min would overflow
			return uint8(Dtrue)
		}
		if sSUB_INT32S_OVERFLOWS(tls, 0, min) != 0 {
			// 0 - INT32_MIN would overflow
			return uint8(Dtrue)
		}
		if sSUB_INT32S_OVERFLOWS(tls, max, min) != 0 {
			// max - min would overflow
			return uint8(Dtrue)
		}
	}
	return uint8(Dfalse)
}

// *
// Normalizes ijk coordinates by setting the components to the smallest possible
// values. Works in place.
//
// This function does not protect against signed integer overflow. The caller
// must ensure that none of (i - j), (i - k), (j - i), (j - k), (k - i), (k - j)
// will overflow. This function may be changed in the future to make that check
// itself and return an error code.
//
// @param c The ijk coordinates to normalize.
func X_ijkNormalize(tls *libc.TLS, c uintptr) { /* coordijk.c:259:6: */
	// remove any negative values
	if (*TCoordIJK)(unsafe.Pointer(c)).Fi < 0 {
		*(*int32)(unsafe.Pointer(c + 4)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fi
		*(*int32)(unsafe.Pointer(c + 8)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fi
		(*TCoordIJK)(unsafe.Pointer(c)).Fi = 0
	}

	if (*TCoordIJK)(unsafe.Pointer(c)).Fj < 0 {
		*(*int32)(unsafe.Pointer(c)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fj
		*(*int32)(unsafe.Pointer(c + 8)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fj
		(*TCoordIJK)(unsafe.Pointer(c)).Fj = 0
	}

	if (*TCoordIJK)(unsafe.Pointer(c)).Fk < 0 {
		*(*int32)(unsafe.Pointer(c)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fk
		*(*int32)(unsafe.Pointer(c + 4)) -= (*TCoordIJK)(unsafe.Pointer(c)).Fk
		(*TCoordIJK)(unsafe.Pointer(c)).Fk = 0
	}

	// remove the min value if needed
	var min int32 = (*TCoordIJK)(unsafe.Pointer(c)).Fi
	if (*TCoordIJK)(unsafe.Pointer(c)).Fj < min {
		min = (*TCoordIJK)(unsafe.Pointer(c)).Fj
	}
	if (*TCoordIJK)(unsafe.Pointer(c)).Fk < min {
		min = (*TCoordIJK)(unsafe.Pointer(c)).Fk
	}
	if min > 0 {
		*(*int32)(unsafe.Pointer(c)) -= min
		*(*int32)(unsafe.Pointer(c + 4)) -= min
		*(*int32)(unsafe.Pointer(c + 8)) -= min
	}
}

// *
// Determines the H3 digit corresponding to a unit vector or the zero vector
// in ijk coordinates.
//
// @param ijk The ijk coordinates; must be a unit vector or zero vector.
// @return The H3 digit (0-6) corresponding to the ijk unit vector, zero vector,
// or INVALID_DIGIT (7) on failure.
func X_unitIjkToDigit(tls *libc.TLS, ijk uintptr) uint32 { /* coordijk.c:298:11: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*TCoordIJK)(unsafe.Pointer(bp /* c */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
	X_ijkNormalize(tls, bp)

	var digit uint32 = INVALID_DIGIT
	{
		var i uint32 = CENTER_DIGIT
		for ; i < NUM_DIGITS; i++ {
			if X_ijkMatches(tls, bp, uintptr(unsafe.Pointer(&sUNIT_VECS3))+uintptr(i)*12) != 0 {
				digit = i
				break
			}
		}
	}

	return digit
}

// *
// Returns non-zero if _upAp7 with the given input could have a signed integer
// overflow.
//
// Assumes ijk is IJK+ coordinates (no negative numbers).
func X_upAp7Checked(tls *libc.TLS, ijk uintptr) uint32 { /* coordijk.c:319:9: */
	// Doesn't need to be checked because i, j, and k must all be non-negative
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	// <0 is checked because the input must all be non-negative, but some
	// negative inputs are used in unit tests to exercise the below.
	if i >= 2147483647/3 || j >= 2147483647/3 || i < 0 || j < 0 {
		if sADD_INT32S_OVERFLOWS(tls, i, i) != 0 {
			return E_FAILED
		}
		var i2 int32 = i + i
		if sADD_INT32S_OVERFLOWS(tls, i2, i) != 0 {
			return E_FAILED
		}
		var i3 int32 = i2 + i
		if sADD_INT32S_OVERFLOWS(tls, j, j) != 0 {
			return E_FAILED
		}
		var j2 int32 = j + j

		if sSUB_INT32S_OVERFLOWS(tls, i3, j) != 0 {
			return E_FAILED
		}
		if sADD_INT32S_OVERFLOWS(tls, i, j2) != 0 {
			return E_FAILED
		}
	}

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlround(tls, float64(i*3-j)*0.14285714285714285714285714285714285))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlround(tls, float64(i+j*2)*0.14285714285714285714285714285714285))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0

	// Expected not to be reachable, because max + min or max - min would need
	// to overflow.
	if func() int32 {
		if X_ijkNormalizeCouldOverflow(tls, ijk) != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+44, int32(354), uintptr(unsafe.Pointer(&__func__1)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return E_FAILED
	}
	X_ijkNormalize(tls, ijk)
	return E_SUCCESS
}

var __func__1 = *(*[14]int8)(unsafe.Pointer(ts + 69)) /* coordijk.c:319:38 */

// *
// Returns non-zero if _upAp7r with the given input could have a signed integer
// overflow.
//
// Assumes ijk is IJK+ coordinates (no negative numbers).
func X_upAp7rChecked(tls *libc.TLS, ijk uintptr) uint32 { /* coordijk.c:367:9: */
	// Doesn't need to be checked because i, j, and k must all be non-negative
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	// <0 is checked because the input must all be non-negative, but some
	// negative inputs are used in unit tests to exercise the below.
	if i >= 2147483647/3 || j >= 2147483647/3 || i < 0 || j < 0 {
		if sADD_INT32S_OVERFLOWS(tls, i, i) != 0 {
			return E_FAILED
		}
		var i2 int32 = i + i
		if sADD_INT32S_OVERFLOWS(tls, j, j) != 0 {
			return E_FAILED
		}
		var j2 int32 = j + j
		if sADD_INT32S_OVERFLOWS(tls, j2, j) != 0 {
			return E_FAILED
		}
		var j3 int32 = j2 + j

		if sADD_INT32S_OVERFLOWS(tls, i2, j) != 0 {
			return E_FAILED
		}
		if sSUB_INT32S_OVERFLOWS(tls, j3, i) != 0 {
			return E_FAILED
		}
	}

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlround(tls, float64(i*2+j)*0.14285714285714285714285714285714285))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlround(tls, float64(j*3-i)*0.14285714285714285714285714285714285))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0

	// Expected not to be reachable, because max + min or max - min would need
	// to overflow.
	if func() int32 {
		if X_ijkNormalizeCouldOverflow(tls, ijk) != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+44, int32(402), uintptr(unsafe.Pointer(&__func__2)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return E_FAILED
	}
	X_ijkNormalize(tls, ijk)
	return E_SUCCESS
}

var __func__2 = *(*[15]int8)(unsafe.Pointer(ts + 83)) /* coordijk.c:367:39 */

// *
// Find the normalized ijk coordinates of the indexing parent of a cell in a
// counter-clockwise aperture 7 grid. Works in place.
//
// @param ijk The ijk coordinates.
func X_upAp7(tls *libc.TLS, ijk uintptr) { /* coordijk.c:415:6: */
	// convert to CoordIJ
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlround(tls, float64(3*i-j)*0.14285714285714285714285714285714285))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlround(tls, float64(i+2*j)*0.14285714285714285714285714285714285))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the indexing parent of a cell in a
// clockwise aperture 7 grid. Works in place.
//
// @param ijk The ijk coordinates.
func X_upAp7r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:432:6: */
	// convert to CoordIJ
	var i int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	var j int32 = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = int32(Xlround(tls, float64(2*i+j)*0.14285714285714285714285714285714285))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = int32(Xlround(tls, float64(3*j-i)*0.14285714285714285714285714285714285))
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 7 counter-clockwise resolution. Works in
// place.
//
// @param ijk The ijk coordinates.
func X_downAp7(tls *libc.TLS, ijk uintptr) { /* coordijk.c:450:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 3, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 3}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 3}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 7 clockwise resolution. Works in place.
//
// @param ijk The ijk coordinates.
func X_downAp7r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:472:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 3, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 3, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 3}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex in the specified digit
// direction from the specified ijk coordinates. Works in place.
//
// @param ijk The ijk coordinates.
// @param digit The digit direction from the original ijk coordinates.
func X_neighbor(tls *libc.TLS, ijk uintptr, digit uint32) { /* coordijk.c:495:6: */
	if digit > CENTER_DIGIT && digit < NUM_DIGITS {
		X_ijkAdd(tls, ijk, uintptr(unsafe.Pointer(&sUNIT_VECS3))+uintptr(digit)*12, ijk)
		X_ijkNormalize(tls, ijk)
	}
}

// *
// Rotates ijk coordinates 60 degrees counter-clockwise. Works in place.
//
// @param ijk The ijk coordinates.
func X_ijkRotate60ccw(tls *libc.TLS, ijk uintptr) { /* coordijk.c:507:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// unit vector rotations
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 1, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 1, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 1}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Rotates ijk coordinates 60 degrees clockwise. Works in place.
//
// @param ijk The ijk coordinates.
func X_ijkRotate60cw(tls *libc.TLS, ijk uintptr) { /* coordijk.c:528:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// unit vector rotations
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 1, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 1}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Rotates indexing digit 60 degrees counter-clockwise. Returns result.
//
// @param digit Indexing digit (between 1 and 6 inclusive)
func X_rotate60ccw(tls *libc.TLS, digit uint32) uint32 { /* coordijk.c:549:11: */
	switch digit {
	case K_AXES_DIGIT:
		return IK_AXES_DIGIT
	case IK_AXES_DIGIT:
		return I_AXES_DIGIT
	case I_AXES_DIGIT:
		return IJ_AXES_DIGIT
	case IJ_AXES_DIGIT:
		return J_AXES_DIGIT
	case J_AXES_DIGIT:
		return JK_AXES_DIGIT
	case JK_AXES_DIGIT:
		return K_AXES_DIGIT
	default:
		return digit
	}
	return uint32(0)
}

// *
// Rotates indexing digit 60 degrees clockwise. Returns result.
//
// @param digit Indexing digit (between 1 and 6 inclusive)
func X_rotate60cw(tls *libc.TLS, digit uint32) uint32 { /* coordijk.c:573:11: */
	switch digit {
	case K_AXES_DIGIT:
		return JK_AXES_DIGIT
	case JK_AXES_DIGIT:
		return J_AXES_DIGIT
	case J_AXES_DIGIT:
		return IJ_AXES_DIGIT
	case IJ_AXES_DIGIT:
		return I_AXES_DIGIT
	case I_AXES_DIGIT:
		return IK_AXES_DIGIT
	case IK_AXES_DIGIT:
		return K_AXES_DIGIT
	default:
		return digit
	}
	return uint32(0)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 3 counter-clockwise resolution. Works in
// place.
//
// @param ijk The ijk coordinates.
func X_downAp3(tls *libc.TLS, ijk uintptr) { /* coordijk.c:599:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 2, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fi: 1, Fj: 2}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fj: 1, Fk: 2}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Find the normalized ijk coordinates of the hex centered on the indicated
// hex at the next finer aperture 3 clockwise resolution. Works in place.
//
// @param ijk The ijk coordinates.
func X_downAp3r(tls *libc.TLS, ijk uintptr) { /* coordijk.c:621:6: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// res r unit vectors in res r+1
	*(*TCoordIJK)(unsafe.Pointer(bp /* iVec */)) = TCoordIJK{Fi: 2, Fj: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* jVec */)) = TCoordIJK{Fj: 2, Fk: 1}
	*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* kVec */)) = TCoordIJK{Fi: 1, Fk: 2}

	X_ijkScale(tls, bp, (*TCoordIJK)(unsafe.Pointer(ijk)).Fi)
	X_ijkScale(tls, bp+12, (*TCoordIJK)(unsafe.Pointer(ijk)).Fj)
	X_ijkScale(tls, bp+24, (*TCoordIJK)(unsafe.Pointer(ijk)).Fk)

	X_ijkAdd(tls, bp, bp+12, ijk)
	X_ijkAdd(tls, ijk, bp+24, ijk)

	X_ijkNormalize(tls, ijk)
}

// *
// Finds the distance between the two coordinates. Returns result.
//
// @param c1 The first set of ijk coordinates.
// @param c2 The second set of ijk coordinates.
func XijkDistance(tls *libc.TLS, c1 uintptr, c2 uintptr) int32 { /* coordijk.c:643:5: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var diff TCoordIJK at bp, 12

	X_ijkSub(tls, c1, c2, bp)
	X_ijkNormalize(tls, bp)
	var absDiff = TCoordIJK{Fi: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fi), Fj: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fj), Fk: libc.Xabs(tls, (*TCoordIJK)(unsafe.Pointer(bp /* &diff */)).Fk)}
	return func() int32 {
		if absDiff.Fi > func() int32 {
			if absDiff.Fj > absDiff.Fk {
				return absDiff.Fj
			}
			return absDiff.Fk
		}() {
			return absDiff.Fi
		}
		return func() int32 {
			if absDiff.Fj > absDiff.Fk {
				return absDiff.Fj
			}
			return absDiff.Fk
		}()
	}()
}

// *
// Transforms coordinates from the IJK+ coordinate system to the IJ coordinate
// system.
//
// @param ijk The input IJK+ coordinates
// @param ij The output IJ coordinates
func XijkToIj(tls *libc.TLS, ijk uintptr, ij uintptr) { /* coordijk.c:658:6: */
	(*TCoordIJ)(unsafe.Pointer(ij)).Fi = (*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJ)(unsafe.Pointer(ij)).Fj = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
}

// *
// Transforms coordinates from the IJ coordinate system to the IJK+ coordinate
// system.
//
// @param ij The input IJ coordinates
// @param ijk The output IJK+ coordinates
// @returns E_SUCCESS on success, E_FAILED if signed integer overflow would have
// occurred.
func XijToIjk(tls *libc.TLS, ij uintptr, ijk uintptr) uint32 { /* coordijk.c:672:9: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = (*TCoordIJ)(unsafe.Pointer(ij)).Fi
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = (*TCoordIJ)(unsafe.Pointer(ij)).Fj
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0

	if X_ijkNormalizeCouldOverflow(tls, ijk) != 0 {
		return E_FAILED
	}

	X_ijkNormalize(tls, ijk)
	return E_SUCCESS
}

// *
// Convert IJK coordinates to cube coordinates, in place
// @param ijk Coordinate to convert
func XijkToCube(tls *libc.TLS, ijk uintptr) { /* coordijk.c:689:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi + (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = (*TCoordIJK)(unsafe.Pointer(ijk)).Fj - (*TCoordIJK)(unsafe.Pointer(ijk)).Fk
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi - (*TCoordIJK)(unsafe.Pointer(ijk)).Fj
}

// *
// Convert cube coordinates to IJK coordinates, in place
// @param ijk Coordinate to convert
func XcubeToIjk(tls *libc.TLS, ijk uintptr) { /* coordijk.c:699:6: */
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = -(*TCoordIJK)(unsafe.Pointer(ijk)).Fi
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = 0
	X_ijkNormalize(tls, ijk)
}

// Limits of integral types.

// Minimum of signed integral types.
// Maximum of signed integral types.

// Maximum of unsigned integral types.

// Minimum of signed integral types having a minimum size.
// Maximum of signed integral types having a minimum size.

// Maximum of unsigned integral types having a minimum size.

// Minimum of fast signed integral types having a minimum size.
// Maximum of fast signed integral types having a minimum size.

// Maximum of fast unsigned integral types having a minimum size.

// Values to test for integral types holding `void *' pointer.

// Minimum for largest signed integral type.
// Maximum for largest signed integral type.

// Maximum for largest unsigned integral type.

// Limits of other integer types.

// Limits of `ptrdiff_t' type.

// Limits of `sig_atomic_t'.

// Limit of `size_t' type.

// Limits of `wchar_t'.
// These constants might also be defined in <wchar.h>.

// Limits of `wint_t'.

// Signed.

// Unsigned.

// Maximal type.

// Get a definition for wchar_t.  But we must not define wchar_t itself.
type T__gwchar_t = int32 /* inttypes.h:34:24 */

// Macros for printing format specifiers.

// Decimal notation.

// Octal notation.

// Unsigned integers.

// lowercase hexadecimal notation.

// UPPERCASE hexadecimal notation.

// Macros for printing `intmax_t' and `uintmax_t'.

// Macros for printing `intptr_t' and `uintptr_t'.

// Macros for scanning format specifiers.

// Signed decimal notation.

// Signed decimal notation.

// Unsigned decimal notation.

// Octal notation.

// Hexadecimal notation.

// Macros for scanning `intmax_t' and `uintmax_t'.

// Macros for scaning `intptr_t' and `uintptr_t'.

// We have to define the `uintmax_t' type using `ldiv_t'.
type Timaxdiv_t = struct {
	Fquot int64
	Frem  int64
} /* inttypes.h:275:5 */

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file  vertex.h
//  @brief Functions for working with cell vertexes.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lng.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

// Copyright 2016-2018, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3Index.h
// @brief   H3Index functions.

//   - @struct PentagonDirectionFaces
//     @brief  The faces in each axial direction of a given pentagon base cell
type TPentagonDirectionFaces = struct {
	FbaseCell int32
	Ffaces    [5]int32
} /* vertex.h:33:3 */

// *
// Returns whether or not the provided H3Indexes are neighbors.
// @param origin The origin H3 index.
// @param destination The destination H3 index.
// @param out Set to 1 if the indexes are neighbors, 0 otherwise
// @return Error code if the origin or destination are invalid or incomparable.
func XareNeighborCells(tls *libc.TLS, origin uint64, destination uint64, out uintptr) uint32 { /* directedEdge.c:38:9: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	// Make sure they're hexagon indexes
	if int32(origin&(uint64(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_CELL_MODE || int32(destination&(uint64(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_CELL_MODE {
		return E_CELL_INVALID
	}

	// Hexagons cannot be neighbors with themselves
	if origin == destination {
		*(*int32)(unsafe.Pointer(out)) = 0
		return E_SUCCESS
	}

	// Only hexagons in the same resolution can be neighbors
	if int32(origin&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) != int32(destination&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		return E_RES_MISMATCH
	}

	// H3 Indexes that share the same parent are very likely to be neighbors
	// Child 0 is neighbor with all of its parent's 'offspring', the other
	// children are neighbors with 3 of the 7 children. So a simple comparison
	// of origin and destination parents and then a lookup table of the children
	// is a super-cheap way to possibly determine they are neighbors.
	var parentRes int32 = int32(origin&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) - 1
	if parentRes > 0 {
		// TODO: Return error codes here
		// var originParent uint64 at bp, 8

		XcellToParent(tls, origin, parentRes, bp)
		// var destinationParent uint64 at bp+8, 8

		XcellToParent(tls, destination, parentRes, bp+8)
		if *(*uint64)(unsafe.Pointer(bp)) == *(*uint64)(unsafe.Pointer(bp + 8)) {
			var originResDigit uint32 = uint32(origin >> ((DMAX_H3_RES - (parentRes + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			var destinationResDigit uint32 = uint32(destination >> ((DMAX_H3_RES - (parentRes + 1)) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			if originResDigit == CENTER_DIGIT || destinationResDigit == CENTER_DIGIT {
				*(*int32)(unsafe.Pointer(out)) = 1
				return E_SUCCESS
			}
			if originResDigit >= INVALID_DIGIT {
				// Prevent indexing off the end of the array below
				return E_CELL_INVALID
			}
			if (originResDigit == K_AXES_DIGIT || destinationResDigit == K_AXES_DIGIT) && XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp))) != 0 {
				// If these are invalid cells, fail rather than incorrectly
				// reporting neighbors. For pentagon cells that are actually
				// neighbors across the deleted subsequence, they will fail the
				// optimized check below, but they will be accepted by the
				// gridDisk check below that.
				return E_CELL_INVALID
			}
			// These sets are the relevant neighbors in the clockwise
			// and counter-clockwise
			*(*[7]uint32)(unsafe.Pointer(bp + 16 /* neighborSetClockwise */)) = [7]uint32{
				CENTER_DIGIT, JK_AXES_DIGIT, IJ_AXES_DIGIT, J_AXES_DIGIT,
				IK_AXES_DIGIT, K_AXES_DIGIT, I_AXES_DIGIT}
			*(*[7]uint32)(unsafe.Pointer(bp + 44 /* neighborSetCounterclockwise */)) = [7]uint32{
				CENTER_DIGIT, IK_AXES_DIGIT, JK_AXES_DIGIT, K_AXES_DIGIT,
				IJ_AXES_DIGIT, I_AXES_DIGIT, J_AXES_DIGIT}
			if *(*uint32)(unsafe.Pointer(bp + 16 + uintptr(originResDigit)*4)) == destinationResDigit || *(*uint32)(unsafe.Pointer(bp + 44 + uintptr(originResDigit)*4)) == destinationResDigit {
				*(*int32)(unsafe.Pointer(out)) = 1
				return E_SUCCESS
			}
		}
	}

	// Otherwise, we have to determine the neighbor relationship the "hard" way.
	*(*[7]uint64)(unsafe.Pointer(bp + 72 /* neighborRing */)) = [7]uint64{0: uint64(0)}
	XgridDisk(tls, origin, 1, bp+72)
	{
		var i int32 = 0
		for ; i < 7; i++ {
			if *(*uint64)(unsafe.Pointer(bp + 72 + uintptr(i)*8)) == destination {
				*(*int32)(unsafe.Pointer(out)) = 1
				return E_SUCCESS
			}
		}
	}

	// Made it here, they definitely aren't neighbors
	*(*int32)(unsafe.Pointer(out)) = 0
	return E_SUCCESS
}

// *
// Returns a directed edge H3 index based on the provided origin and
// destination
// @param origin The origin H3 hexagon index
// @param destination The destination H3 hexagon index
// @return The directed edge H3Index, or H3_NULL on failure.
func XcellsToDirectedEdge(tls *libc.TLS, origin uint64, destination uint64, out uintptr) uint32 { /* directedEdge.c:132:9: */
	// Determine the IJK direction from the origin to the destination
	var direction uint32 = XdirectionForNeighbor(tls, origin, destination)

	// The direction will be invalid if the cells are not neighbors
	if direction == INVALID_DIGIT {
		return E_NOT_NEIGHBORS
	}

	// Create the edge index for the neighbor direction
	var output uint64 = origin
	output = output&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_DIRECTEDEDGE_MODE))<<DH3_MODE_OFFSET
	output = output&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET) | uint64(direction)<<DH3_RESERVED_OFFSET

	*(*uint64)(unsafe.Pointer(out)) = output
	return E_SUCCESS
}

// *
// Returns the origin hexagon from the directed edge H3Index
// @param edge The edge H3 index
// @return The origin H3 hexagon index, or H3_NULL on failure
func XgetDirectedEdgeOrigin(tls *libc.TLS, edge uint64, out uintptr) uint32 { /* directedEdge.c:156:9: */
	if int32(edge&(uint64(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_DIRECTEDEDGE_MODE {
		return E_DIR_EDGE_INVALID
	}
	var origin uint64 = edge
	origin = origin&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	origin = origin&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET) | uint64(uint64(0))<<DH3_RESERVED_OFFSET
	*(*uint64)(unsafe.Pointer(out)) = origin
	return E_SUCCESS
}

// *
// Returns the destination hexagon from the directed edge H3Index
// @param edge The edge H3 index
// @return The destination H3 hexagon index, or H3_NULL on failure
func XgetDirectedEdgeDestination(tls *libc.TLS, edge uint64, out uintptr) uint32 { /* directedEdge.c:172:9: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var direction uint32 = uint32(int32(edge & (uint64(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	*(*int32)(unsafe.Pointer(bp + 8 /* rotations */)) = 0
	// var origin uint64 at bp, 8

	// Note: This call is also checking for H3_DIRECTEDEDGE_MODE
	var originResult uint32 = XgetDirectedEdgeOrigin(tls, edge, bp)
	if originResult != 0 {
		return originResult
	}
	return Xh3NeighborRotations(tls, *(*uint64)(unsafe.Pointer(bp /* origin */)), direction, bp+8, out)
}

// *
// Determines if the provided H3Index is a valid directed edge index
// @param edge The directed edge H3Index
// @return 1 if it is a directed edge H3Index, otherwise 0.
func XisValidDirectedEdge(tls *libc.TLS, edge uint64) int32 { /* directedEdge.c:189:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var neighborDirection uint32 = uint32(int32(edge & (uint64(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	if neighborDirection <= CENTER_DIGIT || neighborDirection >= NUM_DIGITS {
		return 0
	}
	// var origin uint64 at bp, 8

	// Note: This call is also checking for H3_DIRECTEDEDGE_MODE
	var originResult uint32 = XgetDirectedEdgeOrigin(tls, edge, bp)
	if originResult != 0 {
		return 0
	}
	if XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp))) != 0 && neighborDirection == K_AXES_DIGIT {
		return 0
	}

	return XisValidCell(tls, *(*uint64)(unsafe.Pointer(bp /* origin */)))
}

// *
// Returns the origin, destination pair of hexagon IDs for the given edge ID
// @param edge The directed edge H3Index
// @param originDestination Pointer to memory to store origin and destination
// IDs
func XdirectedEdgeToCells(tls *libc.TLS, edge uint64, originDestination uintptr) uint32 { /* directedEdge.c:214:9: */
	var originResult uint32 = XgetDirectedEdgeOrigin(tls, edge, originDestination)
	if originResult != 0 {
		return originResult
	}
	var destinationResult uint32 = XgetDirectedEdgeDestination(tls, edge, originDestination+1*8)
	if destinationResult != 0 {
		return destinationResult
	}
	return E_SUCCESS
}

// *
// Provides all of the directed edges from the current H3Index.
// @param origin The origin hexagon H3Index to find edges for.
// @param edges The memory to store all of the edges inside.
func XoriginToDirectedEdges(tls *libc.TLS, origin uint64, edges uintptr) uint32 { /* directedEdge.c:234:9: */
	// Determine if the origin is a pentagon and special treatment needed.
	var isPent int32 = XisPentagon(tls, origin)

	// This is actually quite simple. Just modify the bits of the origin
	// slightly for each direction, except the 'k' direction in pentagons,
	// which is zeroed.
	{
		var i int32 = 0
		for ; i < 6; i++ {
			if isPent != 0 && i == 0 {
				*(*uint64)(unsafe.Pointer(edges + uintptr(i)*8)) = uint64(DH3_NULL)
			} else {
				*(*uint64)(unsafe.Pointer(edges + uintptr(i)*8)) = origin
				*(*uint64)(unsafe.Pointer(edges + uintptr(i)*8)) = *(*uint64)(unsafe.Pointer(edges + uintptr(i)*8))&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_DIRECTEDEDGE_MODE))<<DH3_MODE_OFFSET
				*(*uint64)(unsafe.Pointer(edges + uintptr(i)*8)) = *(*uint64)(unsafe.Pointer(edges + uintptr(i)*8))&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET) | uint64(i+1)<<DH3_RESERVED_OFFSET
			}
		}
	}
	return E_SUCCESS
}

// *
// Provides the coordinates defining the directed edge.
// @param edge The directed edge H3Index
// @param cb The cellboundary object to store the edge coordinates.
func XdirectedEdgeToBoundary(tls *libc.TLS, edge uint64, cb uintptr) uint32 { /* directedEdge.c:258:9: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// Get the origin and neighbor direction from the edge
	var direction uint32 = uint32(int32(edge & (uint64(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET))
	// var origin uint64 at bp, 8

	var originResult uint32 = XgetDirectedEdgeOrigin(tls, edge, bp)
	if originResult != 0 {
		return originResult
	}

	// Get the start vertex for the edge
	var startVertex int32 = XvertexNumForDirection(tls, *(*uint64)(unsafe.Pointer(bp /* origin */)), direction)
	if startVertex == -1 {
		// This is not actually an edge (i.e. no valid direction),
		// so return no vertices.
		(*TCellBoundary)(unsafe.Pointer(cb)).FnumVerts = 0
		return E_DIR_EDGE_INVALID
	}

	// Get the geo boundary for the appropriate vertexes of the origin. Note
	// that while there are always 2 topological vertexes per edge, the
	// resulting edge boundary may have an additional distortion vertex if it
	// crosses an edge of the icosahedron.
	// var fijk TFaceIJK at bp+8, 16

	var fijkResult uint32 = X_h3ToFaceIjk(tls, *(*uint64)(unsafe.Pointer(bp /* origin */)), bp+8)
	if func() int32 {
		if fijkResult != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+98, int32(282), uintptr(unsafe.Pointer(&__func__3)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return fijkResult
	}
	var res int32 = int32(*(*uint64)(unsafe.Pointer(bp)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var isPent int32 = XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp /* origin */)))

	if isPent != 0 {
		X_faceIjkPentToCellBoundary(tls, bp+8, res, startVertex, 2, cb)
	} else {
		X_faceIjkToCellBoundary(tls, bp+8, res, startVertex, 2, cb)
	}
	return E_SUCCESS
}

var __func__3 = *(*[23]int8)(unsafe.Pointer(ts + 127)) /* directedEdge.c:258:75 */

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file vec3d.h
// @brief   3D floating point vector functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

//   - @struct Vec3D
//     @brief 3D floating point structure
type TVec3d = struct {
	Fx float64
	Fy float64
	Fz float64
} /* vec3d.h:32:3 */

//* square root of 7 and inverse square root of 7

// * @brief icosahedron face centers in lat/lng radians
var XfaceCenterGeo = [20]TLatLng{
	{Flat: 0.803582649718989942, Flng: 1.248397419617396099},   // face  0
	{Flat: 1.307747883455638156, Flng: 2.536945009877921159},   // face  1
	{Flat: 1.054751253523952054, Flng: -1.347517358900396623},  // face  2
	{Flat: 0.600191595538186799, Flng: -0.450603909469755746},  // face  3
	{Flat: 0.491715428198773866, Flng: 0.401988202911306943},   // face  4
	{Flat: 0.172745327415618701, Flng: 1.678146885280433686},   // face  5
	{Flat: 0.605929321571350690, Flng: 2.953923329812411617},   // face  6
	{Flat: 0.427370518328979641, Flng: -1.888876200336285401},  // face  7
	{Flat: -0.079066118549212831, Flng: -0.733429513380867741}, // face  8
	{Flat: -0.230961644455383637, Flng: 0.506495587332349035},  // face  9
	{Flat: 0.079066118549212831, Flng: 2.408163140208925497},   // face 10
	{Flat: 0.230961644455383637, Flng: -2.635097066257444203},  // face 11
	{Flat: -0.172745327415618701, Flng: -1.463445768309359553}, // face 12
	{Flat: -0.605929321571350690, Flng: -0.187669323777381622}, // face 13
	{Flat: -0.427370518328979641, Flng: 1.252716453253507838},  // face 14
	{Flat: -0.600191595538186799, Flng: 2.690988744120037492},  // face 15
	{Flat: -0.491715428198773866, Flng: -2.739604450678486295}, // face 16
	{Flat: -0.803582649718989942, Flng: -1.893195233972397139}, // face 17
	{Flat: -1.307747883455638156, Flng: -0.604647643711872080}, // face 18
	{Flat: -1.054751253523952054, Flng: 1.794075294689396615},  // face 19
} /* faceijk.c:40:14 */

// * @brief icosahedron face centers in x/y/z on the unit sphere
var faceCenterPoint = [20]TVec3d{
	{Fx: 0.2199307791404606, Fy: 0.6583691780274996, Fz: 0.7198475378926182},    // face  0
	{Fx: -0.2139234834501421, Fy: 0.1478171829550703, Fz: 0.9656017935214205},   // face  1
	{Fx: 0.1092625278784797, Fy: -0.4811951572873210, Fz: 0.8697775121287253},   // face  2
	{Fx: 0.7428567301586791, Fy: -0.3593941678278028, Fz: 0.5648005936517033},   // face  3
	{Fx: 0.8112534709140969, Fy: 0.3448953237639384, Fz: 0.4721387736413930},    // face  4
	{Fx: -0.1055498149613921, Fy: 0.9794457296411413, Fz: 0.1718874610009365},   // face  5
	{Fx: -0.8075407579970092, Fy: 0.1533552485898818, Fz: 0.5695261994882688},   // face  6
	{Fx: -0.2846148069787907, Fy: -0.8644080972654206, Fz: 0.4144792552473539},  // face  7
	{Fx: 0.7405621473854482, Fy: -0.6673299564565524, Fz: -0.0789837646326737},  // face  8
	{Fx: 0.8512303986474293, Fy: 0.4722343788582681, Fz: -0.2289137388687808},   // face  9
	{Fx: -0.7405621473854481, Fy: 0.6673299564565524, Fz: 0.0789837646326737},   // face 10
	{Fx: -0.8512303986474292, Fy: -0.4722343788582682, Fz: 0.2289137388687808},  // face 11
	{Fx: 0.1055498149613919, Fy: -0.9794457296411413, Fz: -0.1718874610009365},  // face 12
	{Fx: 0.8075407579970092, Fy: -0.1533552485898819, Fz: -0.5695261994882688},  // face 13
	{Fx: 0.2846148069787908, Fy: 0.8644080972654204, Fz: -0.4144792552473539},   // face 14
	{Fx: -0.7428567301586791, Fy: 0.3593941678278027, Fz: -0.5648005936517033},  // face 15
	{Fx: -0.8112534709140971, Fy: -0.3448953237639382, Fz: -0.4721387736413930}, // face 16
	{Fx: -0.2199307791404607, Fy: -0.6583691780274996, Fz: -0.7198475378926182}, // face 17
	{Fx: 0.2139234834501420, Fy: -0.1478171829550704, Fz: -0.9656017935214205},  // face 18
	{Fx: -0.1092625278784796, Fy: 0.4811951572873210, Fz: -0.8697775121287253},  // face 19
} /* faceijk.c:64:20 */

// * @brief icosahedron face ijk axes as azimuth in radians from face center to
// vertex 0/1/2 respectively
var faceAxesAzRadsCII = [20][3]float64{
	{5.619958268523939882, 3.525563166130744542,
		1.431168063737548730}, // face  0
	{5.760339081714187279, 3.665943979320991689,
		1.571548876927796127}, // face  1
	{0.780213654393430055, 4.969003859179821079,
		2.874608756786625655}, // face  2
	{0.430469363979999913, 4.619259568766391033,
		2.524864466373195467}, // face  3
	{6.130269123335111400, 4.035874020941915804,
		1.941478918548720291}, // face  4
	{2.692877706530642877, 0.598482604137447119,
		4.787272808923838195}, // face  5
	{2.982963003477243874, 0.888567901084048369,
		5.077358105870439581}, // face  6
	{3.532912002790141181, 1.438516900396945656,
		5.627307105183336758}, // face  7
	{3.494305004259568154, 1.399909901866372864,
		5.588700106652763840}, // face  8
	{3.003214169499538391, 0.908819067106342928,
		5.097609271892733906}, // face  9
	{5.930472956509811562, 3.836077854116615875,
		1.741682751723420374}, // face 10
	{0.138378484090254847, 4.327168688876645809,
		2.232773586483450311}, // face 11
	{0.448714947059150361, 4.637505151845541521,
		2.543110049452346120}, // face 12
	{0.158629650112549365, 4.347419854898940135,
		2.253024752505744869}, // face 13
	{5.891865957979238535, 3.797470855586042958,
		1.703075753192847583}, // face 14
	{2.711123289609793325, 0.616728187216597771,
		4.805518392002988683}, // face 15
	{3.294508837434268316, 1.200113735041072948,
		5.388903939827463911}, // face 16
	{3.804819692245439833, 1.710424589852244509,
		5.899214794638635174}, // face 17
	{3.664438879055192436, 1.570043776661997111,
		5.758833981448388027}, // face 18
	{2.361378999196363184, 0.266983896803167583,
		4.455774101589558636}, // face 19
} /* faceijk.c:90:21 */

// * @brief Definition of which faces neighbor each other.
var faceNeighbors = [20][4]TFaceOrientIJK{{
	{}, // central face
	{Fface: 4, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
	{Fface: 1, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
	{Fface: 5, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 1
		{Fface: 1}, // central face
		{Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1},           // ij quadrant
		{Fface: 2, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 6, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 2
		{Fface: 2}, // central face
		{Fface: 1, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 3, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 7, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 3
		{Fface: 3}, // central face
		{Fface: 2, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 4, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 8, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 4
		{Fface: 4}, // central face
		{Fface: 3, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5},           // ki quadrant
		{Fface: 9, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 5
		{Fface: 5}, // central face
		{Fface: 10, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 14, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 6
		{Fface: 6}, // central face
		{Fface: 11, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 10, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 1, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 7
		{Fface: 7}, // central face
		{Fface: 12, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 11, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 2, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 8
		{Fface: 8}, // central face
		{Fface: 13, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 12, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 3, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 9
		{Fface: 9}, // central face
		{Fface: 14, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 13, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 4, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 10
		{Fface: 10}, // central face
		{Fface: 5, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 6, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 15, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 11
		{Fface: 11}, // central face
		{Fface: 6, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 7, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 16, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 12
		{Fface: 12}, // central face
		{Fface: 7, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 8, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 17, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 13
		{Fface: 13}, // central face
		{Fface: 8, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 9, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 18, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 14
		{Fface: 14}, // central face
		{Fface: 9, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 3}, // ij quadrant
		{Fface: 5, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 3}, // ki quadrant
		{Fface: 19, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 15
		{Fface: 15}, // central face
		{Fface: 16, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 19, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 10, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 16
		{Fface: 16}, // central face
		{Fface: 17, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 15, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 11, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 17
		{Fface: 17}, // central face
		{Fface: 18, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 16, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 12, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 18
		{Fface: 18}, // central face
		{Fface: 19, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1}, // ij quadrant
		{Fface: 17, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5}, // ki quadrant
		{Fface: 13, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}},
	{
		// face 19
		{Fface: 19}, // central face
		{Fface: 15, Ftranslate: TCoordIJK{Fi: 2, Fk: 2}, FccwRot60: 1},  // ij quadrant
		{Fface: 18, Ftranslate: TCoordIJK{Fi: 2, Fj: 2}, FccwRot60: 5},  // ki quadrant
		{Fface: 14, Ftranslate: TCoordIJK{Fj: 2, Fk: 2}, FccwRot60: 3}}} /* faceijk.c:134:28 */

// * @brief direction from the origin face to the destination face, relative to
// the origin face's coordinate system, or -1 if not adjacent.
var adjacentFaceDir = [20][20]int32{
	{0, DKI, -1, -1, DIJ, DJK, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 0
	{DIJ, 0, DKI, -1, -1, -1, DJK, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 1
	{-1, DIJ, 0, DKI, -1, -1, -1, DJK, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 2
	{-1, -1, DIJ, 0, DKI, -1, -1, -1, DJK, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 3
	{DKI, -1, -1, DIJ, 0, -1, -1, -1, -1, DJK,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // face 4
	{DJK, -1, -1, -1, -1, 0, -1, -1, -1, -1,
		DIJ, -1, -1, -1, DKI, -1, -1, -1, -1, -1}, // face 5
	{-1, DJK, -1, -1, -1, -1, 0, -1, -1, -1,
		DKI, DIJ, -1, -1, -1, -1, -1, -1, -1, -1}, // face 6
	{-1, -1, DJK, -1, -1, -1, -1, 0, -1, -1,
		-1, DKI, DIJ, -1, -1, -1, -1, -1, -1, -1}, // face 7
	{-1, -1, -1, DJK, -1, -1, -1, -1, 0, -1,
		-1, -1, DKI, DIJ, -1, -1, -1, -1, -1, -1}, // face 8
	{-1, -1, -1, -1, DJK, -1, -1, -1, -1, 0,
		-1, -1, -1, DKI, DIJ, -1, -1, -1, -1, -1}, // face 9
	{-1, -1, -1, -1, -1, DIJ, DKI, -1, -1, -1,
		0, -1, -1, -1, -1, DJK, -1, -1, -1, -1}, // face 10
	{-1, -1, -1, -1, -1, -1, DIJ, DKI, -1, -1,
		-1, 0, -1, -1, -1, -1, DJK, -1, -1, -1}, // face 11
	{-1, -1, -1, -1, -1, -1, -1, DIJ, DKI, -1,
		-1, -1, 0, -1, -1, -1, -1, DJK, -1, -1}, // face 12
	{-1, -1, -1, -1, -1, -1, -1, -1, DIJ, DKI,
		-1, -1, -1, 0, -1, -1, -1, -1, DJK, -1}, // face 13
	{-1, -1, -1, -1, -1, DKI, -1, -1, -1, DIJ,
		-1, -1, -1, -1, 0, -1, -1, -1, -1, DJK}, // face 14
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		DJK, -1, -1, -1, -1, 0, DIJ, -1, -1, DKI}, // face 15
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, DJK, -1, -1, -1, DKI, 0, DIJ, -1, -1}, // face 16
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, DJK, -1, -1, -1, DKI, 0, DIJ, -1}, // face 17
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, DJK, -1, -1, -1, DKI, 0, DIJ}, // face 18
	{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, DJK, DIJ, -1, -1, DKI, 0}, // face 19
} /* faceijk.c:279:18 */

// * @brief overage distance table
var maxDimByCIIres = [17]int32{
	2,        // res  0
	-1,       // res  1
	14,       // res  2
	-1,       // res  3
	98,       // res  4
	-1,       // res  5
	686,      // res  6
	-1,       // res  7
	4802,     // res  8
	-1,       // res  9
	33614,    // res 10
	-1,       // res 11
	235298,   // res 12
	-1,       // res 13
	1647086,  // res 14
	-1,       // res 15
	11529602, // res 16
} /* faceijk.c:323:18 */

// * @brief unit scale distance table
var unitScaleByCIIres = [17]int32{
	1,       // res  0
	-1,      // res  1
	7,       // res  2
	-1,      // res  3
	49,      // res  4
	-1,      // res  5
	343,     // res  6
	-1,      // res  7
	2401,    // res  8
	-1,      // res  9
	16807,   // res 10
	-1,      // res 11
	117649,  // res 12
	-1,      // res 13
	823543,  // res 14
	-1,      // res 15
	5764801, // res 16
} /* faceijk.c:344:18 */

// *
// Encodes a coordinate on the sphere to the FaceIJK address of the containing
// cell at the specified resolution.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @param h The FaceIJK address of the containing cell at resolution res.
func X_geoToFaceIjk(tls *libc.TLS, g uintptr, res int32, h uintptr) { /* faceijk.c:372:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// first convert to hex2d
	// var v TVec2d at bp, 16

	X_geoToHex2d(tls, g, res, h, bp)

	// then convert to ijk+
	X_hex2dToCoordIJK(tls, bp, h+4)
}

// *
// Encodes a coordinate on the sphere to the corresponding icosahedral face and
// containing 2D hex coordinates relative to that face center.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @param face The icosahedral face containing the spherical coordinates.
// @param v The 2D hex coordinates of the cell containing the point.
func X_geoToHex2d(tls *libc.TLS, g uintptr, res int32, face uintptr, v uintptr) { /* faceijk.c:390:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// determine the icosahedron face
	// var sqd float64 at bp, 8

	X_geoToClosestFace(tls, g, face, bp)

	// cos(r) = 1 - 2 * sin^2(r/2) = 1 - 2 * (sqd / 4) = 1 - sqd/2
	var r float64 = libc.Xacos(tls, float64(1)-*(*float64)(unsafe.Pointer(bp))*0.5)

	if r < 0.0000000000000001 {
		(*TVec2d)(unsafe.Pointer(v)).Fx = libc.AssignPtrFloat64(v+8, 0.0)
		return
	}

	// now have face and r, now find CCW theta from CII i-axis
	var theta float64 = X_posAngleRads(tls, *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceAxesAzRadsCII)) + uintptr(*(*int32)(unsafe.Pointer(face)))*24))-X_posAngleRads(tls, X_geoAzimuthRads(tls, uintptr(unsafe.Pointer(&XfaceCenterGeo))+uintptr(*(*int32)(unsafe.Pointer(face)))*16, g)))

	// adjust theta for Class III (odd resolutions)
	if XisResolutionClassIII(tls, res) != 0 {
		theta = X_posAngleRads(tls, theta-0.333473172251832115336090755351601070065900389)
	}

	// perform gnomonic scaling of r
	r = libc.Xtan(tls, r)

	// scale for current resolution length u
	r = r * 2.61803398874989588842
	{
		var i int32 = 0
		for ; i < res; i++ {
			r = r * 2.6457513110645905905016157536392604257102
		}
	}

	// we now have (r, theta) in hex2d with theta ccw from x-axes

	// convert to local x,y
	(*TVec2d)(unsafe.Pointer(v)).Fx = r * libc.Xcos(tls, theta)
	(*TVec2d)(unsafe.Pointer(v)).Fy = r * libc.Xsin(tls, theta)
}

// *
// Determines the center point in spherical coordinates of a cell given by 2D
// hex coordinates on a particular icosahedral face.
//
// @param v The 2D hex coordinates of the cell.
// @param face The icosahedral face upon which the 2D hex coordinate system is
//
//	centered.
//
// @param res The H3 resolution of the cell.
// @param substrate Indicates whether or not this grid is actually a substrate
//
//	grid relative to the specified resolution.
//
// @param g The spherical coordinates of the cell center point.
func X_hex2dToGeo(tls *libc.TLS, v uintptr, face int32, res int32, substrate int32, g uintptr) { /* faceijk.c:438:6: */
	// calculate (r, theta) in hex2d
	var r float64 = X_v2dMag(tls, v)

	if r < 0.0000000000000001 {
		*(*TLatLng)(unsafe.Pointer(g)) = XfaceCenterGeo[face]
		return
	}

	var theta float64 = libc.Xatan2(tls, (*TVec2d)(unsafe.Pointer(v)).Fy, (*TVec2d)(unsafe.Pointer(v)).Fx)

	// scale for current resolution length u
	{
		var i int32 = 0
		for ; i < res; i++ {
			r = r * 0.37796447300922722721451653623418006081576
		}
	}

	// scale accordingly if this is a substrate grid
	if substrate != 0 {
		r = r * 0.333333333333333333333333333333333333333
		if XisResolutionClassIII(tls, res) != 0 {
			r = r * 0.37796447300922722721451653623418006081576
		}
	}

	r = r * 0.38196601125010500003

	// perform inverse gnomonic scaling of r
	r = libc.Xatan(tls, r)

	// adjust theta for Class III
	// if a substrate grid, then it's already been adjusted for Class III
	if !(substrate != 0) && XisResolutionClassIII(tls, res) != 0 {
		theta = X_posAngleRads(tls, theta+0.333473172251832115336090755351601070065900389)
	}

	// find theta as an azimuth
	theta = X_posAngleRads(tls, *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer(&faceAxesAzRadsCII)) + uintptr(face)*24))-theta)

	// now find the point at (r,theta) from the face center
	X_geoAzDistanceRads(tls, uintptr(unsafe.Pointer(&XfaceCenterGeo))+uintptr(face)*16, theta, r, g)
}

// *
// Determines the center point in spherical coordinates of a cell given by
// a FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param g The spherical coordinates of the cell center point.
func X_faceIjkToGeo(tls *libc.TLS, h uintptr, res int32, g uintptr) { /* faceijk.c:483:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var v TVec2d at bp, 16

	X_ijkToHex2d(tls, h+4, bp)
	X_hex2dToGeo(tls, bp, (*TFaceIJK)(unsafe.Pointer(h)).Fface, res, 0, g)
}

// *
// Generates the cell boundary in spherical coordinates for a pentagonal cell
// given by a FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the pentagonal cell.
// @param res The H3 resolution of the cell.
// @param start The first topological vertex to return.
// @param length The number of topological vertexes to return.
// @param g The spherical coordinates of the cell boundary.
func X_faceIjkPentToCellBoundary(tls *libc.TLS, h uintptr, res int32, start int32, length int32, g uintptr) { /* faceijk.c:499:6: */
	bp := tls.Alloc(280)
	defer tls.Free(280)

	*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)) = res
	*(*TFaceIJK)(unsafe.Pointer(bp /* centerIJK */)) = *(*TFaceIJK)(unsafe.Pointer(h))
	// var fijkVerts [5]TFaceIJK at bp+20, 80

	X_faceIjkPentToVerts(tls, bp, bp+16, bp+20)

	// If we're returning the entire loop, we need one more iteration in case
	// of a distortion vertex on the last edge
	var additionalIteration int32
	if length == DNUM_PENT_VERTS {
		additionalIteration = 1
	} else {
		additionalIteration = 0
	}

	// convert each vertex to lat/lng
	// adjust the face of each vertex as appropriate and introduce
	// edge-crossing vertices as needed
	(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts = 0
	// var lastFijk TFaceIJK at bp+116, 16

	{
		var vert int32 = start
		for ; vert < start+length+additionalIteration; vert++ {
			var v int32 = vert % DNUM_PENT_VERTS

			*(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 20 + uintptr(v)*16))

			X_adjustPentVertOverage(tls, bp+100, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)))

			// all Class III pentagon edges cross icosa edges
			// note that Class II pentagons have vertices on the edge,
			// not edge intersections
			if XisResolutionClassIII(tls, res) != 0 && vert > start {
				// find hex2d of the two vertexes on the last face

				*(*TFaceIJK)(unsafe.Pointer(bp + 152 /* tmpFijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */))
				// var orig2d0 TVec2d at bp+136, 16

				X_ijkToHex2d(tls, bp+116+4, bp+136)

				var currentToLastDir int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+116 /* &lastFijk */)).Fface)*4))

				var fijkOrient uintptr = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr(currentToLastDir)*20

				(*TFaceIJK)(unsafe.Pointer(bp + 152 /* &tmpFijk */)).Fface = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Fface
				var ijk uintptr = bp + 152 + 4

				// rotate and translate for adjacent face
				{
					var i int32 = 0
					for ; i < (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).FccwRot60; i++ {
						X_ijkRotate60ccw(tls, ijk)
					}
				}

				*(*TCoordIJK)(unsafe.Pointer(bp + 168 /* transVec */)) = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Ftranslate
				X_ijkScale(tls, bp+168, unitScaleByCIIres[*(*int32)(unsafe.Pointer(bp + 16))]*3)
				X_ijkAdd(tls, ijk, bp+168, ijk)
				X_ijkNormalize(tls, ijk)
				// var orig2d1 TVec2d at bp+184, 16

				X_ijkToHex2d(tls, ijk, bp+184)

				// find the appropriate icosa face edge vertexes
				var maxDim int32 = maxDimByCIIres[*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */))]
				*(*TVec2d)(unsafe.Pointer(bp + 200 /* v0 */)) = TVec2d{Fx: 3.0 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 216 /* v1 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 232 /* v2 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(-3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				var edge0 uintptr
				var edge1 uintptr
				switch *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+100 /* &fijk */)).Fface)*4)) {
				case DIJ:
					edge0 = bp + 200 /* &v0 */
					edge1 = bp + 216 /* &v1 */
					break
					fallthrough
				case DJK:
					edge0 = bp + 216 /* &v1 */
					edge1 = bp + 232 /* &v2 */
					break
					fallthrough
				case DKI:
					fallthrough
				default:
					if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp+152)).Fface)*80 + uintptr((*TFaceIJK)(unsafe.Pointer(bp+100)).Fface)*4)) == DKI {
					} else {
						libc.X__assert_fail(tls, ts+150, ts+197, int32(572), uintptr(unsafe.Pointer(&__func__4)))
					}
					edge0 = bp + 232 /* &v2 */
					edge1 = bp + 200 /* &v0 */
					break
				}

				// find the intersection and add the lat/lng point to the result
				// var inter TVec2d at bp+248, 16

				X_v2dIntersect(tls, bp+136, bp+184, edge0, edge1, bp+248)
				X_hex2dToGeo(tls, bp+248, (*TFaceIJK)(unsafe.Pointer(bp+152 /* &tmpFijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1,
					g+8+uintptr((*TCellBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			// convert vertex to lat/lng and add to the result
			// vert == start + NUM_PENT_VERTS is only used to test for possible
			// intersection on last edge
			if vert < start+DNUM_PENT_VERTS {
				// var vec TVec2d at bp+264, 16

				X_ijkToHex2d(tls, bp+100+4, bp+264)
				X_hex2dToGeo(tls, bp+264, (*TFaceIJK)(unsafe.Pointer(bp+100 /* &fijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1, g+8+uintptr((*TCellBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			*(*TFaceIJK)(unsafe.Pointer(bp + 116 /* lastFijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 100 /* fijk */))
		}
	}
}

var __func__4 = *(*[27]int8)(unsafe.Pointer(ts + 221)) /* faceijk.c:500:62 */

// *
// Get the vertices of a pentagon cell as substrate FaceIJK addresses
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell. This may be adjusted if
//
//	necessary for the substrate grid resolution.
//
// @param fijkVerts Output array for the vertices
func X_faceIjkPentToVerts(tls *libc.TLS, fijk uintptr, res uintptr, fijkVerts uintptr) { /* faceijk.c:608:6: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// the vertexes of an origin-centered pentagon in a Class II resolution on a
	// substrate grid with aperture sequence 33r. The aperture 3 gets us the
	// vertices, and the 3r gets us back to Class II.
	// vertices listed ccw from the i-axes
	*(*[5]TCoordIJK)(unsafe.Pointer(bp + 60 /* vertsCII */)) = [5]TCoordIJK{
		{Fi: 2, Fj: 1}, // 0
		{Fi: 1, Fj: 2}, // 1
		{Fj: 2, Fk: 1}, // 2
		{Fj: 1, Fk: 2}, // 3
		{Fi: 1, Fk: 2}, // 4
	}

	// the vertexes of an origin-centered pentagon in a Class III resolution on
	// a substrate grid with aperture sequence 33r7r. The aperture 3 gets us the
	// vertices, and the 3r7r gets us to Class II. vertices listed ccw from the
	// i-axes
	*(*[5]TCoordIJK)(unsafe.Pointer(bp /* vertsCIII */)) = [5]TCoordIJK{
		{Fi: 5, Fj: 4}, // 0
		{Fi: 1, Fj: 5}, // 1
		{Fj: 5, Fk: 4}, // 2
		{Fj: 1, Fk: 5}, // 3
		{Fi: 4, Fk: 5}, // 4
	}

	// get the correct set of substrate vertices for this resolution
	var verts uintptr
	if XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		verts = bp /* &vertsCIII[0] */
	} else {
		verts = bp + 60 /* &vertsCII[0] */
	}

	// adjust the center point to be in an aperture 33r substrate grid
	// these should be composed for speed
	X_downAp3(tls, fijk+4)
	X_downAp3r(tls, fijk+4)

	// if res is Class III we need to add a cw aperture 7 to get to
	// icosahedral Class II
	if XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		X_downAp7r(tls, fijk+4)
		*(*int32)(unsafe.Pointer(res)) += 1
	}

	// The center point is now in the same substrate grid as the origin
	// cell vertices. Add the center point substate coordinates
	// to each vertex to translate the vertices to that cell.
	{
		var v int32 = 0
		for ; v < DNUM_PENT_VERTS; v++ {
			(*TFaceIJK)(unsafe.Pointer(fijkVerts + uintptr(v)*16)).Fface = (*TFaceIJK)(unsafe.Pointer(fijk)).Fface
			X_ijkAdd(tls, fijk+4, verts+uintptr(v)*12, fijkVerts+uintptr(v)*16+4)
			X_ijkNormalize(tls, fijkVerts+uintptr(v)*16+4)
		}
	}
}

// *
// Generates the cell boundary in spherical coordinates for a cell given by a
// FaceIJK address at a specified resolution.
//
// @param h The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param start The first topological vertex to return.
// @param length The number of topological vertexes to return.
// @param g The spherical coordinates of the cell boundary.
func X_faceIjkToCellBoundary(tls *libc.TLS, h uintptr, res int32, start int32, length int32, g uintptr) { /* faceijk.c:672:6: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)) = res
	*(*TFaceIJK)(unsafe.Pointer(bp /* centerIJK */)) = *(*TFaceIJK)(unsafe.Pointer(h))
	// var fijkVerts [6]TFaceIJK at bp+20, 96

	X_faceIjkToVerts(tls, bp, bp+16, bp+20)

	// If we're returning the entire loop, we need one more iteration in case
	// of a distortion vertex on the last edge
	var additionalIteration int32
	if length == DNUM_HEX_VERTS {
		additionalIteration = 1
	} else {
		additionalIteration = 0
	}

	// convert each vertex to lat/lng
	// adjust the face of each vertex as appropriate and introduce
	// edge-crossing vertices as needed
	(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts = 0
	var lastFace int32 = -1
	var lastOverage uint32 = NO_OVERAGE
	{
		var vert int32 = start
		for ; vert < start+length+additionalIteration; vert++ {
			var v int32 = vert % DNUM_HEX_VERTS

			*(*TFaceIJK)(unsafe.Pointer(bp + 116 /* fijk */)) = *(*TFaceIJK)(unsafe.Pointer(bp + 20 + uintptr(v)*16))

			var pentLeading4 int32 = 0
			var overage uint32 = X_adjustOverageClassII(tls, bp+116, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), pentLeading4, 1)

			//
			//         Check for edge-crossing. Each face of the underlying icosahedron is a
			//         different projection plane. So if an edge of the hexagon crosses an
			//         icosahedron edge, an additional vertex must be introduced at that
			//         intersection point. Then each half of the cell edge can be projected
			//         to geographic coordinates using the appropriate icosahedron face
			//         projection. Note that Class II cell edges have vertices on the face
			//         edge, with no edge line intersections.
			//
			if XisResolutionClassIII(tls, res) != 0 && vert > start && (*TFaceIJK)(unsafe.Pointer(bp+116)).Fface != lastFace && lastOverage != FACE_EDGE {
				// find hex2d of the two vertexes on original face
				var lastV int32 = (v + 5) % DNUM_HEX_VERTS
				// var orig2d0 TVec2d at bp+136, 16

				X_ijkToHex2d(tls, bp+20+uintptr(lastV)*16+4, bp+136)
				// var orig2d1 TVec2d at bp+152, 16

				X_ijkToHex2d(tls, bp+20+uintptr(v)*16+4, bp+152)

				// find the appropriate icosa face edge vertexes
				var maxDim int32 = maxDimByCIIres[*(*int32)(unsafe.Pointer(bp + 16 /* adjRes */))]
				*(*TVec2d)(unsafe.Pointer(bp + 168 /* v0 */)) = TVec2d{Fx: 3.0 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 184 /* v1 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}
				*(*TVec2d)(unsafe.Pointer(bp + 200 /* v2 */)) = TVec2d{Fx: -1.5 * float64(maxDim), Fy: float64(-3.0) * 0.8660254037844386467637231707529361834714 * float64(maxDim)}

				var face2 int32 = func() int32 {
					if lastFace == (*TFaceIJK)(unsafe.Pointer(bp)).Fface {
						return (*TFaceIJK)(unsafe.Pointer(bp + 116)).Fface
					}
					return lastFace
				}()
				var edge0 uintptr
				var edge1 uintptr
				switch *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp)).Fface)*80 + uintptr(face2)*4)) {
				case DIJ:
					edge0 = bp + 168 /* &v0 */
					edge1 = bp + 184 /* &v1 */
					break
					fallthrough
				case DJK:
					edge0 = bp + 184 /* &v1 */
					edge1 = bp + 200 /* &v2 */
					break
					fallthrough
				// case KI:
				default:
					if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&adjacentFaceDir)) + uintptr((*TFaceIJK)(unsafe.Pointer(bp)).Fface)*80 + uintptr(face2)*4)) == DKI {
					} else {
						libc.X__assert_fail(tls, ts+248, ts+197, int32(737), uintptr(unsafe.Pointer(&__func__5)))
					}
					edge0 = bp + 200 /* &v2 */
					edge1 = bp + 168 /* &v0 */
					break
				}

				// find the intersection and add the lat/lng point to the result
				// var inter TVec2d at bp+216, 16

				X_v2dIntersect(tls, bp+136, bp+152, edge0, edge1, bp+216)
				//
				//             If a point of intersection occurs at a hexagon vertex, then each
				//             adjacent hexagon edge will lie completely on a single icosahedron
				//             face, and no additional vertex is required.
				//
				var isIntersectionAtVertex uint8 = uint8(libc.Bool32(X_v2dAlmostEquals(tls, bp+136, bp+216) != 0 || X_v2dAlmostEquals(tls, bp+152, bp+216) != 0))
				if !(isIntersectionAtVertex != 0) {
					X_hex2dToGeo(tls, bp+216, (*TFaceIJK)(unsafe.Pointer(bp /* &centerIJK */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1,
						g+8+uintptr((*TCellBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
					(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts++
				}
			}

			// convert vertex to lat/lng and add to the result
			// vert == start + NUM_HEX_VERTS is only used to test for possible
			// intersection on last edge
			if vert < start+DNUM_HEX_VERTS {
				// var vec TVec2d at bp+232, 16

				X_ijkToHex2d(tls, bp+116+4, bp+232)
				X_hex2dToGeo(tls, bp+232, (*TFaceIJK)(unsafe.Pointer(bp+116 /* &fijk */)).Fface, *(*int32)(unsafe.Pointer(bp + 16 /* adjRes */)), 1, g+8+uintptr((*TCellBoundary)(unsafe.Pointer(g)).FnumVerts)*16)
				(*TCellBoundary)(unsafe.Pointer(g)).FnumVerts++
			}

			lastFace = (*TFaceIJK)(unsafe.Pointer(bp + 116 /* &fijk */)).Fface
			lastOverage = overage
		}
	}
}

var __func__5 = *(*[23]int8)(unsafe.Pointer(ts + 293)) /* faceijk.c:673:46 */

// *
// Get the vertices of a cell as substrate FaceIJK addresses
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell. This may be adjusted if
//
//	necessary for the substrate grid resolution.
//
// @param fijkVerts Output array for the vertices
func X_faceIjkToVerts(tls *libc.TLS, fijk uintptr, res uintptr, fijkVerts uintptr) { /* faceijk.c:783:6: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	// the vertexes of an origin-centered cell in a Class II resolution on a
	// substrate grid with aperture sequence 33r. The aperture 3 gets us the
	// vertices, and the 3r gets us back to Class II.
	// vertices listed ccw from the i-axes
	*(*[6]TCoordIJK)(unsafe.Pointer(bp + 72 /* vertsCII */)) = [6]TCoordIJK{
		{Fi: 2, Fj: 1}, // 0
		{Fi: 1, Fj: 2}, // 1
		{Fj: 2, Fk: 1}, // 2
		{Fj: 1, Fk: 2}, // 3
		{Fi: 1, Fk: 2}, // 4
		{Fi: 2, Fk: 1}, // 5
	}

	// the vertexes of an origin-centered cell in a Class III resolution on a
	// substrate grid with aperture sequence 33r7r. The aperture 3 gets us the
	// vertices, and the 3r7r gets us to Class II.
	// vertices listed ccw from the i-axes
	*(*[6]TCoordIJK)(unsafe.Pointer(bp /* vertsCIII */)) = [6]TCoordIJK{
		{Fi: 5, Fj: 4}, // 0
		{Fi: 1, Fj: 5}, // 1
		{Fj: 5, Fk: 4}, // 2
		{Fj: 1, Fk: 5}, // 3
		{Fi: 4, Fk: 5}, // 4
		{Fi: 5, Fk: 1}, // 5
	}

	// get the correct set of substrate vertices for this resolution
	var verts uintptr
	if XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		verts = bp /* &vertsCIII[0] */
	} else {
		verts = bp + 72 /* &vertsCII[0] */
	}

	// adjust the center point to be in an aperture 33r substrate grid
	// these should be composed for speed
	X_downAp3(tls, fijk+4)
	X_downAp3r(tls, fijk+4)

	// if res is Class III we need to add a cw aperture 7 to get to
	// icosahedral Class II
	if XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(res))) != 0 {
		X_downAp7r(tls, fijk+4)
		*(*int32)(unsafe.Pointer(res)) += 1
	}

	// The center point is now in the same substrate grid as the origin
	// cell vertices. Add the center point substate coordinates
	// to each vertex to translate the vertices to that cell.
	{
		var v int32 = 0
		for ; v < DNUM_HEX_VERTS; v++ {
			(*TFaceIJK)(unsafe.Pointer(fijkVerts + uintptr(v)*16)).Fface = (*TFaceIJK)(unsafe.Pointer(fijk)).Fface
			X_ijkAdd(tls, fijk+4, verts+uintptr(v)*12, fijkVerts+uintptr(v)*16+4)
			X_ijkNormalize(tls, fijkVerts+uintptr(v)*16+4)
		}
	}
}

// *
// Adjusts a FaceIJK address in place so that the resulting cell address is
// relative to the correct icosahedral face.
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
// @param pentLeading4 Whether or not the cell is a pentagon with a leading
//
//	digit 4.
//
// @param substrate Whether or not the cell is in a substrate grid.
// @return 0 if on original face (no overage); 1 if on face edge (only occurs
//
//	on substrate grids); 2 if overage on new face interior
func X_adjustOverageClassII(tls *libc.TLS, fijk uintptr, res int32, pentLeading4 int32, substrate int32) uint32 { /* faceijk.c:851:9: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var overage uint32 = NO_OVERAGE

	var ijk uintptr = fijk + 4

	// get the maximum dimension value; scale if a substrate grid
	var maxDim int32 = maxDimByCIIres[res]
	if substrate != 0 {
		maxDim = maxDim * 3
	}

	// check for overage
	if substrate != 0 && (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk == maxDim { // on edge
		overage = FACE_EDGE
	} else if (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk > maxDim {
		overage = NEW_FACE
		var fijkOrient uintptr
		if (*TCoordIJK)(unsafe.Pointer(ijk)).Fk > 0 {
			if (*TCoordIJK)(unsafe.Pointer(ijk)).Fj > 0 { // jk "quadrant"
				fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 3*20
			} else {
				fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 2*20

				// adjust for the pentagonal missing sequence
				if pentLeading4 != 0 {
					// translate origin to center of pentagon
					// var origin TCoordIJK at bp, 12

					X_setIJK(tls, bp, maxDim, 0, 0)
					// var tmp TCoordIJK at bp+12, 12

					X_ijkSub(tls, ijk, bp, bp+12)
					// rotate to adjust for the missing sequence
					X_ijkRotate60cw(tls, bp+12)
					// translate the origin back to the center of the triangle
					X_ijkAdd(tls, bp+12, bp, ijk)
				}
			}
		} else { // ij "quadrant"
			fijkOrient = uintptr(unsafe.Pointer(&faceNeighbors)) + uintptr((*TFaceIJK)(unsafe.Pointer(fijk)).Fface)*80 + 1*20
		}

		(*TFaceIJK)(unsafe.Pointer(fijk)).Fface = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Fface

		// rotate and translate for adjacent face
		{
			var i int32 = 0
			for ; i < (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).FccwRot60; i++ {
				X_ijkRotate60ccw(tls, ijk)
			}
		}

		*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* transVec */)) = (*TFaceOrientIJK)(unsafe.Pointer(fijkOrient)).Ftranslate
		var unitScale int32 = unitScaleByCIIres[res]
		if substrate != 0 {
			unitScale = unitScale * 3
		}
		X_ijkScale(tls, bp+24, unitScale)
		X_ijkAdd(tls, ijk, bp+24, ijk)
		X_ijkNormalize(tls, ijk)

		// overage points on pentagon boundaries can end up on edges
		if substrate != 0 && (*TCoordIJK)(unsafe.Pointer(ijk)).Fi+(*TCoordIJK)(unsafe.Pointer(ijk)).Fj+(*TCoordIJK)(unsafe.Pointer(ijk)).Fk == maxDim { // on edge
			overage = FACE_EDGE
		}
	}

	return overage
}

// *
// Adjusts a FaceIJK address for a pentagon vertex in a substrate grid in
// place so that the resulting cell address is relative to the correct
// icosahedral face.
//
// @param fijk The FaceIJK address of the cell.
// @param res The H3 resolution of the cell.
func X_adjustPentVertOverage(tls *libc.TLS, fijk uintptr, res int32) uint32 { /* faceijk.c:920:9: */
	var pentLeading4 int32 = 0
	var overage uint32
	for __ccgo := true; __ccgo; __ccgo = overage == NEW_FACE {
		overage = X_adjustOverageClassII(tls, fijk, res, pentLeading4, 1)
	}
	return overage
}

// *
// Encodes a coordinate on the sphere to the corresponding icosahedral face and
// containing the squared euclidean distance to that face center.
//
// @param g The spherical coordinates to encode.
// @param face The icosahedral face containing the spherical coordinates.
// @param sqd The squared euclidean distance to its icosahedral face center.
func X_geoToClosestFace(tls *libc.TLS, g uintptr, face uintptr, sqd uintptr) { /* faceijk.c:937:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var v3d TVec3d at bp, 24

	X_geoToVec3d(tls, g, bp)

	// determine the icosahedron face
	*(*int32)(unsafe.Pointer(face)) = 0
	// The distance between two farthest points is 2.0, therefore the square of
	// the distance between two points should always be less or equal than 4.0 .
	*(*float64)(unsafe.Pointer(sqd)) = 5.0
	{
		var f int32 = 0
		for ; f < DNUM_ICOSA_FACES; f++ {
			var sqdT float64 = X_pointSquareDist(tls, uintptr(unsafe.Pointer(&faceCenterPoint))+uintptr(f)*24, bp)
			if sqdT < *(*float64)(unsafe.Pointer(sqd)) {
				*(*int32)(unsafe.Pointer(face)) = f
				*(*float64)(unsafe.Pointer(sqd)) = sqdT
			}
		}
	}
}

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// The testcase() macro is used to aid in coverage testing.  When
// doing coverage testing, the condition inside the argument to
// testcase() must be evaluated both true and false in order to
// get full branch coverage.  The testcase() macro is inserted
// to help ensure adequate test coverage in places where simple
// condition/decision coverage is inadequate.  For example, testcase()
// can be used to make sure boundary values are tested.  For
// bitmask tests, testcase() can be used to make sure each bit
// is significant and used at least once.  On switch statements
// where multiple cases go to the same block of code, testcase()
// can insure that all cases are evaluated.

// Disable ALWAYS() and NEVER() (make them pass-throughs) for coverage
// and mutation testing

// The TESTONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within testcase() and assert() macros.

// The DEFENSEONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within ALWAYS() or NEVER() macros.

// The ALWAYS and NEVER macros surround boolean expressions which
// are intended to always be true or false, respectively.  Such
// expressions could be omitted from the code completely.  But they
// are included in a few cases in order to enhance the resilience
// of the H3 library to unexpected behavior - to make the code "self-healing"
// or "ductile" rather than being "brittle" and crashing at the first
// hint of unplanned behavior.
//
// In other words, ALWAYS and NEVER are added for defensive code.
//
// When doing coverage testing ALWAYS and NEVER are hard-coded to
// be true and false so that the unreachable code they specify will
// not be counted as untested code.

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// The testcase() macro is used to aid in coverage testing.  When
// doing coverage testing, the condition inside the argument to
// testcase() must be evaluated both true and false in order to
// get full branch coverage.  The testcase() macro is inserted
// to help ensure adequate test coverage in places where simple
// condition/decision coverage is inadequate.  For example, testcase()
// can be used to make sure boundary values are tested.  For
// bitmask tests, testcase() can be used to make sure each bit
// is significant and used at least once.  On switch statements
// where multiple cases go to the same block of code, testcase()
// can insure that all cases are evaluated.

// Disable ALWAYS() and NEVER() (make them pass-throughs) for coverage
// and mutation testing

// The TESTONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within testcase() and assert() macros.

// The DEFENSEONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within ALWAYS() or NEVER() macros.

// The ALWAYS and NEVER macros surround boolean expressions which
// are intended to always be true or false, respectively.  Such
// expressions could be omitted from the code completely.  But they
// are included in a few cases in order to enhance the resilience
// of the H3 library to unexpected behavior - to make the code "self-healing"
// or "ductile" rather than being "brittle" and crashing at the first
// hint of unplanned behavior.
//
// In other words, ALWAYS and NEVER are added for defensive code.
//
// When doing coverage testing ALWAYS and NEVER are hard-coded to
// be true and false so that the unreachable code they specify will
// not be counted as untested code.

// Copyright 2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// * @file iterators.h
// @brief Iterator structs and functions for the children of a cell,
// or cells at a given resolution.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// *
// IterCellsChildren: struct for iterating through the descendants of
// a given cell.
//
// Constructors:
//
// Initialize with either `iterInitParent` or `iterInitBaseCellNum`.
// `iterInitParent` sets up an iterator for all the children of a given
// parent cell at a given resolution.
//
// `iterInitBaseCellNum` sets up an iterator for children cells, given
// a base cell number (0--121).
//
// Iteration:
//
// Step iterator with `iterStepChild`.
// During the lifetime of the `IterCellsChildren`, the current iterate
// is accessed via the `IterCellsChildren.h` member.
// When the iterator is exhausted or if there was an error in initialization,
// `IterCellsChildren.h` will be `H3_NULL` even after calling `iterStepChild`.
type TIterCellsChildren = struct {
	Fh          uint64
	F_parentRes int32
	F_skipDigit int32
} /* iterators.h:54:3 */

// *
// IterCellsResolution: struct for iterating through all cells at a given
// resolution
//
// Constructor:
//
// Initialize with `IterCellsResolution`.
//
// Iteration:
//
// Step iterator with `iterStepRes`.
// During the lifetime of the iterator the current iterate
// is accessed via the `IterCellsResolution.h` member.
// When the iterator is exhausted or if there was an error in initialization,
// `IterCellsResolution.h` will be `H3_NULL` even after calling `iterStepRes`.
type TIterCellsResolution = struct {
	Fh            uint64
	F_baseCellNum int32
	F_res         int32
	F_itC         TIterCellsChildren
} /* iterators.h:82:3 */

//   - @var H3ErrorDescriptions
//     @brief An array of strings describing each of the H3ErrorCodes enum values
var sH3ErrorDescriptions = [16]uintptr{
	ts + 316,

	ts + 324,
	ts + 388,

	ts + 429,
	ts + 494,
	ts + 546,
	ts + 574,
	ts + 611,
	ts + 650,
	ts + 680,
	ts + 716,
	ts + 732,
	ts + 766,
	ts + 810,
	ts + 835,
	ts + 879} /* h3Index.c:39:13 */

// *
// Returns the string describing the H3Error. This string is internally
// allocated and should not be `free`d.
// @param err The H3 error.
// @return The string describing the H3Error
func XdescribeH3Error(tls *libc.TLS, err uint32) uintptr { /* h3Index.c:65:12: */
	if err >= uint32(0) && err <= uint32(15) { // TODO: Better way to bounds check here?
		return sH3ErrorDescriptions[err]
	} else {
		return ts + 916 /* "Invalid error co..." */
	}
	return uintptr(0)
}

// *
// Returns the H3 resolution of an H3 index.
// @param h The H3 index.
// @return The resolution of the H3 index argument.
func XgetResolution(tls *libc.TLS, h uint64) int32 { /* h3Index.c:78:5: */
	return int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
}

// *
// Returns the H3 base cell "number" of an H3 cell (hexagon or pentagon).
//
// Note: Technically works on H3 edges, but will return base cell of the
// origin cell.
//
// @param h The H3 cell.
// @return The base cell "number" of the H3 cell argument.
func XgetBaseCellNumber(tls *libc.TLS, h uint64) int32 { /* h3Index.c:89:5: */
	return int32(h & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
}

// *
// Converts a string representation of an H3 index into an H3 index.
// @param str The string representation of an H3 index.
// @return The H3 index corresponding to the string argument, or H3_NULL if
// invalid.
func XstringToH3(tls *libc.TLS, str uintptr, out uintptr) uint32 { /* h3Index.c:97:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*uint64)(unsafe.Pointer(bp + 8 /* h */)) = uint64(DH3_NULL)
	// If failed, h will be unmodified and we should return H3_NULL anyways.
	var read int32 = libc.Xsscanf(tls, str, ts+935, libc.VaList(bp, bp+8))
	if read != 1 {
		return E_FAILED
	}
	*(*uint64)(unsafe.Pointer(out)) = *(*uint64)(unsafe.Pointer(bp + 8 /* h */))
	return E_SUCCESS
}

// *
// Converts an H3 index into a string representation.
// @param h The H3 index to convert.
// @param str The string representation of the H3 index.
// @param sz Size of the buffer `str`
func Xh3ToString(tls *libc.TLS, h uint64, str uintptr, sz uint64) uint32 { /* h3Index.c:114:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// An unsigned 64 bit integer will be expressed in at most
	// 16 digits plus 1 for the null terminator.
	if sz < uint64(17) {
		// Buffer is potentially not large enough.
		return E_MEMORY_BOUNDS
	}
	libc.Xsprintf(tls, str, ts+935, libc.VaList(bp, h))
	return E_SUCCESS
}

// *
// Returns whether or not an H3 index is a valid cell (hexagon or pentagon).
// @param h The H3 index to validate.
// @return 1 if the H3 index if valid, and 0 if it is not.
func XisValidCell(tls *libc.TLS, h uint64) int32 { /* h3Index.c:130:5: */
	if int32(h&(uint64(uint64(1))<<DH3_MAX_OFFSET)>>DH3_MAX_OFFSET) != 0 {
		return 0
	}

	if int32(h&(uint64(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_CELL_MODE {
		return 0
	}

	if int32(h&(uint64(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) != 0 {
		return 0
	}

	var baseCell int32 = int32(h & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if func() int32 {
		if baseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+939, int32(138), uintptr(unsafe.Pointer(&__func__6)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || baseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return 0
	}

	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if func() int32 {
		if res < 0 || res > DMAX_H3_RES {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+939, int32(144), uintptr(unsafe.Pointer(&__func__6)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// Resolutions less than zero can not be represented in an index
		return 0
	}

	var foundFirstNonZeroDigit uint8 = uint8(Dfalse)
	{
		var r int32 = 1
		for ; r <= res; r++ {
			var digit uint32 = uint32(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))

			if !(foundFirstNonZeroDigit != 0) && digit != CENTER_DIGIT {
				foundFirstNonZeroDigit = uint8(Dtrue)
				if X_isBaseCellPentagon(tls, baseCell) != 0 && digit == K_AXES_DIGIT {
					return 0
				}
			}

			if func() int32 {
				if digit < CENTER_DIGIT {
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+939, int32(160), uintptr(unsafe.Pointer(&__func__6)))
						}
						return 1
					}()
				}
				return 0
			}() != 0 || digit >= NUM_DIGITS {
				return 0
			}
		}
	}

	{
		var r1 int32 = res + 1
		for ; r1 <= DMAX_H3_RES; r1++ {
			var digit uint32 = uint32(h >> ((DMAX_H3_RES - r1) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			if digit != INVALID_DIGIT {
				return 0
			}
		}
	}

	return 1
}

var __func__6 = *(*[12]int8)(unsafe.Pointer(ts + 963)) /* h3Index.c:130:39 */

// *
// Initializes an H3 index.
// @param hp The H3 index to initialize.
// @param res The H3 resolution to initialize the index to.
// @param baseCell The H3 base cell to initialize the index to.
// @param initDigit The H3 digit (0-7) to initialize all of the index digits to.
func XsetH3Index(tls *libc.TLS, hp uintptr, res int32, baseCell int32, initDigit uint32) { /* h3Index.c:178:6: */
	var h uint64 = 35184372088831
	h = h&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	h = h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | uint64(res)<<DH3_RES_OFFSET
	h = h&libc.CplUint64(uint64(uint64(127))<<DH3_BC_OFFSET) | uint64(baseCell)<<DH3_BC_OFFSET
	{
		var r int32 = 1
		for ; r <= res; r++ {
			h = h & ^(uint64(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | uint64(initDigit)<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)
		}
	}
	*(*uint64)(unsafe.Pointer(hp)) = h
}

// *
// cellToParent produces the parent index for a given H3 index
//
// @param h H3Index to find parent of
// @param parentRes The resolution to switch to (parent, grandparent, etc)
//
// @return H3Index of the parent, or H3_NULL if you actually asked for a child
func XcellToParent(tls *libc.TLS, h uint64, parentRes int32, out uintptr) uint32 { /* h3Index.c:195:9: */
	var childRes int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if parentRes < 0 || parentRes > DMAX_H3_RES {
		return E_RES_DOMAIN
	} else if parentRes > childRes {
		return E_RES_MISMATCH
	} else if parentRes == childRes {
		*(*uint64)(unsafe.Pointer(out)) = h
		return E_SUCCESS
	}
	var parentH uint64 = libc.AssignUint64(&h, h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET)|uint64(parentRes)<<DH3_RES_OFFSET)
	{
		var i int32 = parentRes + 1
		for ; i <= childRes; i++ {
			parentH = parentH & ^(uint64(uint64(7))<<((DMAX_H3_RES-i)*DH3_PER_DIGIT_OFFSET)) | uint64(uint64(7))<<((DMAX_H3_RES-i)*DH3_PER_DIGIT_OFFSET)
		}
	}
	*(*uint64)(unsafe.Pointer(out)) = parentH
	return E_SUCCESS
}

// *
// Determines whether one resolution is a valid child resolution for a cell.
// Each resolution is considered a valid child resolution of itself.
//
// @param h         h3Index  parent cell
// @param childRes  int      resolution of the child
//
// @return The validity of the child resolution
func _hasChildAtRes(tls *libc.TLS, h uint64, childRes int32) uint8 { /* h3Index.c:222:13: */
	var parentRes int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if childRes < parentRes || childRes > DMAX_H3_RES {
		return uint8(Dfalse)
	}
	return uint8(Dtrue)
}

// *
// cellToChildrenSize returns the exact number of children for a cell at a
// given child resolution.
//
// @param h         H3Index to find the number of children of
// @param childRes  The child resolution you're interested in
//
// @return int      Exact number of children (handles hexagons and pentagons
//
//	correctly)
func XcellToChildrenSize(tls *libc.TLS, h uint64, childRes int32, out uintptr) uint32 { /* h3Index.c:240:9: */
	if !(_hasChildAtRes(tls, h, childRes) != 0) {
		return E_RES_DOMAIN
	}

	var n int32 = childRes - int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET)

	if XisPentagon(tls, h) != 0 {
		*(*int64)(unsafe.Pointer(out)) = int64(1) + int64(5)*(X_ipow(tls, int64(7), int64(n))-int64(1))/int64(6)
	} else {
		*(*int64)(unsafe.Pointer(out)) = X_ipow(tls, int64(7), int64(n))
	}
	return E_SUCCESS
}

// *
// makeDirectChild takes an index and immediately returns the immediate child
// index based on the specified cell number. Bit operations only, could generate
// invalid indexes if not careful (deleted cell under a pentagon).
//
// @param h H3Index to find the direct child of
// @param cellNumber int id of the direct child (0-6)
//
// @return The new H3Index for the child
func XmakeDirectChild(tls *libc.TLS, h uint64, cellNumber int32) uint64 { /* h3Index.c:263:9: */
	var childRes int32 = int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) + 1
	var childH uint64 = libc.AssignUint64(&h, h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET)|uint64(childRes)<<DH3_RES_OFFSET)
	childH = childH & ^(uint64(uint64(7))<<((DMAX_H3_RES-childRes)*DH3_PER_DIGIT_OFFSET)) | uint64(cellNumber)<<((DMAX_H3_RES-childRes)*DH3_PER_DIGIT_OFFSET)
	return childH
}

// *
// cellToChildren takes the given hexagon id and generates all of the children
// at the specified resolution storing them into the provided memory pointer.
// It's assumed that cellToChildrenSize was used to determine the allocation.
//
// @param h H3Index to find the children of
// @param childRes int the child level to produce
// @param children H3Index* the memory to store the resulting addresses in
func XcellToChildren(tls *libc.TLS, h uint64, childRes int32, children uintptr) uint32 { /* h3Index.c:279:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int64 = int64(0)
	{
		*(*TIterCellsChildren)(unsafe.Pointer(bp /* iter */)) = XiterInitParent(tls, h, childRes)
		for ; (*TIterCellsChildren)(unsafe.Pointer(bp)).Fh != 0; XiterStepChild(tls, bp) {
			*(*uint64)(unsafe.Pointer(children + uintptr(i)*8)) = (*TIterCellsChildren)(unsafe.Pointer(bp /* &iter */)).Fh
			i++
		}
	}
	return E_SUCCESS
}

// *
// Zero out index digits from start to end, inclusive.
// No-op if start > end.
func X_zeroIndexDigits(tls *libc.TLS, h uint64, start int32, end int32) uint64 { /* h3Index.c:293:9: */
	if start > end {
		return h
	}

	var m uint64 = uint64(0)

	m = ^m
	m <<= DH3_PER_DIGIT_OFFSET * (end - start + 1)
	m = ^m
	m <<= DH3_PER_DIGIT_OFFSET * (DMAX_H3_RES - end)
	m = ^m

	return h & m
}

// *
// cellToCenterChild produces the center child index for a given H3 index at
// the specified resolution
//
// @param h H3Index to find center child of
// @param childRes The resolution to switch to
// @param child H3Index of the center child
// @return 0 (E_SUCCESS) on success
func XcellToCenterChild(tls *libc.TLS, h uint64, childRes int32, child uintptr) uint32 { /* h3Index.c:316:9: */
	if !(_hasChildAtRes(tls, h, childRes) != 0) {
		return E_RES_DOMAIN
	}

	h = X_zeroIndexDigits(tls, h, int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET)+1, childRes)
	h = h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | uint64(childRes)<<DH3_RES_OFFSET
	*(*uint64)(unsafe.Pointer(child)) = h
	return E_SUCCESS
}

// *
// compactCells takes a set of hexagons all at the same resolution and
// compresses them by pruning full child branches to the parent level. This is
// also done for all parents recursively to get the minimum number of hex
// addresses that perfectly cover the defined space.
// @param h3Set Set of hexagons
// @param compactedSet The output array of compressed hexagons (preallocated)
// @param numHexes The size of the input and output arrays (possible that no
// contiguous regions exist in the set at all and no compression possible)
// @return an error code on bad input data
func XcompactCells(tls *libc.TLS, h3Set uintptr, compactedSet uintptr, numHexes int64) uint32 { /* h3Index.c:336:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if numHexes == int64(0) {
		return E_SUCCESS
	}
	var res int32 = int32(*(*uint64)(unsafe.Pointer(h3Set)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if res == 0 {
		// No compaction possible, just copy the set to output
		{
			var i int64 = int64(0)
			for ; i < numHexes; i++ {
				*(*uint64)(unsafe.Pointer(compactedSet + uintptr(i)*8)) = *(*uint64)(unsafe.Pointer(h3Set + uintptr(i)*8))
			}
		}
		return E_SUCCESS
	}
	var remainingHexes uintptr = libc.Xmalloc(tls, uint64(numHexes)*uint64(unsafe.Sizeof(uint64(0))))
	if !(remainingHexes != 0) {
		return E_MEMORY_ALLOC
	}
	libc.Xmemcpy(tls, remainingHexes, h3Set, uint64(numHexes)*uint64(unsafe.Sizeof(uint64(0))))
	var hashSetArray uintptr = libc.Xcalloc(tls, uint64(numHexes), uint64(unsafe.Sizeof(uint64(0))))
	if !(hashSetArray != 0) {
		libc.Xfree(tls, remainingHexes)
		return E_MEMORY_ALLOC
	}
	var compactedSetOffset uintptr = compactedSet
	var numRemainingHexes int64 = numHexes
	for numRemainingHexes != 0 {
		res = int32(*(*uint64)(unsafe.Pointer(remainingHexes)) & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		var parentRes int32 = res - 1

		// If parentRes is less than zero, we've compacted all the way up to the
		// base cells. Time to process the remaining cells.
		if parentRes >= 0 {
			// Put the parents of the hexagons into the temp array
			// via a hashing mechanism, and use the reserved bits
			// to track how many times a parent is duplicated
			{
				var i int64 = int64(0)
				for ; i < numRemainingHexes; i++ {
					var currIndex uint64 = *(*uint64)(unsafe.Pointer(remainingHexes + uintptr(i)*8))
					// TODO: This case is coverable (reachable by fuzzer)
					if currIndex != uint64(0) {
						// If the reserved bits were set by the caller, the
						// algorithm below may encounter undefined behavior
						// because it expects to have set the reserved bits
						// itself.
						if int32(currIndex&(uint64(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) != 0 {
							libc.Xfree(tls, remainingHexes)
							libc.Xfree(tls, hashSetArray)
							return E_CELL_INVALID
						}
						// var parent uint64 at bp, 8

						var parentError uint32 = XcellToParent(tls, currIndex, parentRes, bp)
						// Should never be reachable as a result of the compact
						// algorithm. Can happen if cellToParent errors e.g.
						// because of incompatible resolutions.
						if parentError != 0 {
							libc.Xfree(tls, remainingHexes)
							libc.Xfree(tls, hashSetArray)
							return parentError
						}
						// Modulus hash the parent into the temp array
						var loc int64 = int64(*(*uint64)(unsafe.Pointer(bp)) % uint64(numRemainingHexes))
						var loopCount int64 = int64(0)
						for *(*uint64)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) != uint64(0) {
							if func() int32 {
								if loopCount > numRemainingHexes {
									return func() int32 {
										if 0 != 0 {
										} else {
											libc.X__assert_fail(tls, ts, ts+939, int32(400), uintptr(unsafe.Pointer(&__func__7)))
										}
										return 1
									}()
								}
								return 0
							}() != 0 {
								// This case should not be possible because at
								// most one index is placed into hashSetArray
								// per numRemainingHexes.
								libc.Xfree(tls, remainingHexes)
								libc.Xfree(tls, hashSetArray)
								return E_FAILED
							}
							var tempIndex uint64 = *(*uint64)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) & libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET)
							if tempIndex == *(*uint64)(unsafe.Pointer(bp)) {
								var count int32 = int32(*(*uint64)(unsafe.Pointer(hashSetArray + uintptr(loc)*8))&(uint64(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
								var limitCount int32 = 7
								if XisPentagon(tls,
									tempIndex&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET)) != 0 {
									limitCount--
								}
								// One is added to count for this check to match
								// one being added to count later in this
								// function when checking for all children being
								// present.
								if count+1 > limitCount {
									// Only possible on duplicate input
									libc.Xfree(tls, remainingHexes)
									libc.Xfree(tls, hashSetArray)
									return E_DUPLICATE_INPUT
								}
								*(*uint64)(unsafe.Pointer(bp)) = *(*uint64)(unsafe.Pointer(bp))&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET) | uint64(count)<<DH3_RESERVED_OFFSET
								*(*uint64)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) = uint64(DH3_NULL)
							} else {
								loc = (loc + int64(1)) % numRemainingHexes
							}
							loopCount++
						}
						*(*uint64)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) = *(*uint64)(unsafe.Pointer(bp /* parent */))
					}
				}
			}
		}

		// Determine which parent hexagons have a complete set
		// of children and put them in the compactableHexes array
		var compactableCount int64 = int64(0)
		var maxCompactableCount int64 = numRemainingHexes / int64(6) // Somehow all pentagons; conservative
		if maxCompactableCount == int64(0) {
			libc.Xmemcpy(tls, compactedSetOffset, remainingHexes,
				uint64(numRemainingHexes)*uint64(unsafe.Sizeof(uint64(0))))
			break
		}
		var compactableHexes uintptr = libc.Xcalloc(tls, uint64(maxCompactableCount), uint64(unsafe.Sizeof(uint64(0))))
		if !(compactableHexes != 0) {
			libc.Xfree(tls, remainingHexes)
			libc.Xfree(tls, hashSetArray)
			return E_MEMORY_ALLOC
		}
		{
			var i int64 = int64(0)
			for ; i < numRemainingHexes; i++ {
				if *(*uint64)(unsafe.Pointer(hashSetArray + uintptr(i)*8)) == uint64(0) {
					continue
				}
				var count int32 = int32(*(*uint64)(unsafe.Pointer(hashSetArray + uintptr(i)*8))&(uint64(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
				// Include the deleted direction for pentagons as implicitly "there"
				if XisPentagon(tls, *(*uint64)(unsafe.Pointer(hashSetArray + uintptr(i)*8))&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET)) != 0 {
					// We need this later on, no need to recalculate
					*(*uint64)(unsafe.Pointer(hashSetArray + uintptr(i)*8)) = *(*uint64)(unsafe.Pointer(hashSetArray + uintptr(i)*8))&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET) | uint64(count)<<DH3_RESERVED_OFFSET
					// Increment count after setting the reserved bits,
					// since count is already incremented above, so it
					// will be the expected value for a complete hexagon.
					count++
				}
				if count == 7 {
					// Bingo! Full set!
					*(*uint64)(unsafe.Pointer(compactableHexes + uintptr(compactableCount)*8)) = *(*uint64)(unsafe.Pointer(hashSetArray + uintptr(i)*8)) & libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET)
					compactableCount++
				}
			}
		}
		// Uncompactable hexes are immediately copied into the
		// output compactedSetOffset
		var uncompactableCount int64 = int64(0)
		{
			var i1 int64 = int64(0)
			for ; i1 < numRemainingHexes; i1++ {
				var currIndex uint64 = *(*uint64)(unsafe.Pointer(remainingHexes + uintptr(i1)*8))
				// TODO: This case is coverable (reachable by fuzzer)
				if currIndex != uint64(DH3_NULL) {
					var isUncompactable uint8 = uint8(Dtrue)
					// Resolution 0 cells always uncompactable, and trying to take
					// the res -1 parent of a cell is invalid.
					if parentRes >= 0 {
						// var parent uint64 at bp+8, 8

						var parentError uint32 = XcellToParent(tls, currIndex, parentRes, bp+8)
						if func() int32 {
							if parentError != 0 {
								return func() int32 {
									if 0 != 0 {
									} else {
										libc.X__assert_fail(tls, ts, ts+939, int32(491), uintptr(unsafe.Pointer(&__func__7)))
									}
									return 1
								}()
							}
							return 0
						}() != 0 {
							libc.Xfree(tls, compactableHexes)
							libc.Xfree(tls, remainingHexes)
							libc.Xfree(tls, hashSetArray)
							return parentError
						}
						// Modulus hash the parent into the temp array
						// to determine if this index was included in
						// the compactableHexes array
						var loc int64 = int64(*(*uint64)(unsafe.Pointer(bp + 8)) % uint64(numRemainingHexes))
						var loopCount int64 = int64(0)
						for __ccgo := true; __ccgo; __ccgo = *(*uint64)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) != *(*uint64)(unsafe.Pointer(bp + 8)) {
							if func() int32 {
								if loopCount > numRemainingHexes {
									return func() int32 {
										if 0 != 0 {
										} else {
											libc.X__assert_fail(tls, ts, ts+939, int32(503), uintptr(unsafe.Pointer(&__func__7)))
										}
										return 1
									}()
								}
								return 0
							}() != 0 {
								// This case should not be possible because at most
								// one index is placed into hashSetArray per input
								// hexagon.
								libc.Xfree(tls, compactableHexes)
								libc.Xfree(tls, remainingHexes)
								libc.Xfree(tls, hashSetArray)
								return E_FAILED
							}
							var tempIndex uint64 = *(*uint64)(unsafe.Pointer(hashSetArray + uintptr(loc)*8)) & libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET)
							if tempIndex == *(*uint64)(unsafe.Pointer(bp + 8)) {
								var count int32 = int32(*(*uint64)(unsafe.Pointer(hashSetArray + uintptr(loc)*8))&(uint64(uint64(7))<<DH3_RESERVED_OFFSET)>>DH3_RESERVED_OFFSET) + 1
								if count == 7 {
									isUncompactable = uint8(Dfalse)
								}
								break
							} else {
								loc = (loc + int64(1)) % numRemainingHexes
							}
							loopCount++
						}
					}
					if isUncompactable != 0 {
						*(*uint64)(unsafe.Pointer(compactedSetOffset + uintptr(uncompactableCount)*8)) = *(*uint64)(unsafe.Pointer(remainingHexes + uintptr(i1)*8))
						uncompactableCount++
					}
				}
			}
		}
		// Set up for the next loop
		libc.Xmemset(tls, hashSetArray, 0, uint64(numHexes)*uint64(unsafe.Sizeof(uint64(0))))
		compactedSetOffset += 8 * uintptr(uncompactableCount)
		libc.Xmemcpy(tls, remainingHexes, compactableHexes,
			uint64(compactableCount)*uint64(unsafe.Sizeof(uint64(0))))
		numRemainingHexes = compactableCount
		libc.Xfree(tls, compactableHexes)
	}
	libc.Xfree(tls, remainingHexes)
	libc.Xfree(tls, hashSetArray)
	return E_SUCCESS
}

var __func__7 = *(*[13]int8)(unsafe.Pointer(ts + 975)) /* h3Index.c:337:57 */

// *
// uncompactCells takes a compressed set of cells and expands back to the
// original set of cells.
//
// Skips elements that are H3_NULL (i.e., 0).
//
// @param   compactSet  Set of compacted cells
// @param   numCompact  The number of cells in the input compacted set
// @param   outSet      Output array for decompressed cells (preallocated)
// @param   numOut      The size of the output array to bound check against
// @param   res         The H3 resolution to decompress to
// @return              An error code if output array is too small or any cell
//
//	is smaller than the output resolution.
func XuncompactCells(tls *libc.TLS, compactedSet uintptr, numCompacted int64, outSet uintptr, numOut int64, res int32) uint32 { /* h3Index.c:560:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int64 = int64(0)

	{
		var j int64 = int64(0)
		for ; j < numCompacted; j++ {
			if !(_hasChildAtRes(tls, *(*uint64)(unsafe.Pointer(compactedSet + uintptr(j)*8)), res) != 0) {
				return E_RES_MISMATCH
			}

			{
				*(*TIterCellsChildren)(unsafe.Pointer(bp /* iter */)) = XiterInitParent(tls, *(*uint64)(unsafe.Pointer(compactedSet + uintptr(j)*8)), res)
			__1:
				if !((*TIterCellsChildren)(unsafe.Pointer(bp)).Fh != 0) {
					goto __3
				}
				{
					if i >= numOut {
						return E_MEMORY_BOUNDS
					} // went too far; abort!
					*(*uint64)(unsafe.Pointer(outSet + uintptr(i)*8)) = (*TIterCellsChildren)(unsafe.Pointer(bp /* &iter */)).Fh

				}
				goto __2
			__2:
				i++
				XiterStepChild(tls, bp)
				goto __1
				goto __3
			__3:
			}
		}
	}
	return E_SUCCESS
}

// *
// uncompactCellsSize takes a compacted set of hexagons and provides
// the exact size of the uncompacted set of hexagons.
//
// @param   compactedSet  Set of hexagons
// @param   numHexes      The number of hexes in the input set
// @param   res           The hexagon resolution to decompress to
// @param   out           The number of hexagons to allocate memory for
// @returns E_SUCCESS on success, or another value on error
func XuncompactCellsSize(tls *libc.TLS, compactedSet uintptr, numCompacted int64, res int32, out uintptr) uint32 { /* h3Index.c:587:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var numOut int64 = int64(0)
	{
		var i int64 = int64(0)
		for ; i < numCompacted; i++ {
			if *(*uint64)(unsafe.Pointer(compactedSet + uintptr(i)*8)) == uint64(DH3_NULL) {
				continue
			}
			// var childrenSize int64 at bp, 8

			var childrenError uint32 = XcellToChildrenSize(tls, *(*uint64)(unsafe.Pointer(compactedSet + uintptr(i)*8)), res, bp)
			if childrenError != 0 {
				// The parent res does not contain `res`.
				return E_RES_MISMATCH
			}
			numOut = numOut + *(*int64)(unsafe.Pointer(bp))
		}
	}
	*(*int64)(unsafe.Pointer(out)) = numOut
	return E_SUCCESS
}

// *
// isResClassIII takes a hexagon ID and determines if it is in a
// Class III resolution (rotated versus the icosahedron and subject
// to shape distortion adding extra points on icosahedron edges, making
// them not true hexagons).
// @param h The H3Index to check.
// @return Returns 1 if the hexagon is class III, otherwise 0.
func XisResClassIII(tls *libc.TLS, h uint64) int32 { /* h3Index.c:615:5: */
	return int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) % 2
}

// *
// isPentagon takes an H3Index and determines if it is actually a pentagon.
// @param h The H3Index to check.
// @return Returns 1 if it is a pentagon, otherwise 0.
func XisPentagon(tls *libc.TLS, h uint64) int32 { /* h3Index.c:622:5: */
	return libc.Bool32(X_isBaseCellPentagon(tls, int32(h&(uint64(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET)) != 0 && !(X_h3LeadingNonZeroDigit(tls, h) != 0))
}

// *
// Returns the highest resolution non-zero digit in an H3Index.
// @param h The H3Index.
// @return The highest resolution non-zero digit in the H3Index.
func X_h3LeadingNonZeroDigit(tls *libc.TLS, h uint64) uint32 { /* h3Index.c:632:11: */
	{
		var r int32 = 1
		for ; r <= int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET); r++ {
			if int32(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != 0 {
				return uint32(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			}
		}
	}

	// if we're here it's all 0's
	return CENTER_DIGIT
}

// *
// Rotate an H3Index 60 degrees counter-clockwise about a pentagonal center.
// @param h The H3Index.
func X_h3RotatePent60ccw(tls *libc.TLS, h uint64) uint64 { /* h3Index.c:644:9: */
	// rotate in place; skips any leading 1 digits (k-axis)

	var foundFirstNonZeroDigit int32 = 0
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		for ; r <= res; r++ {
			// rotate this digit
			h = h & ^(uint64(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | uint64(X_rotate60ccw(tls, uint32(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)

			// look for the first non-zero digit so we
			// can adjust for deleted k-axes sequence
			// if necessary
			if !(foundFirstNonZeroDigit != 0) && int32(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != int32(0) {
				foundFirstNonZeroDigit = 1

				// adjust for deleted k-axes sequence
				if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
					h = X_h3Rotate60ccw(tls, h)
				}
			}
		}
	}
	return h
}

// *
// Rotate an H3Index 60 degrees clockwise about a pentagonal center.
// @param h The H3Index.
func X_h3RotatePent60cw(tls *libc.TLS, h uint64) uint64 { /* h3Index.c:670:9: */
	// rotate in place; skips any leading 1 digits (k-axis)

	var foundFirstNonZeroDigit int32 = 0
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		for ; r <= res; r++ {
			// rotate this digit
			h = h & ^(uint64(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | uint64(X_rotate60cw(tls, uint32(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)

			// look for the first non-zero digit so we
			// can adjust for deleted k-axes sequence
			// if necessary
			if !(foundFirstNonZeroDigit != 0) && int32(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != int32(0) {
				foundFirstNonZeroDigit = 1

				// adjust for deleted k-axes sequence
				if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
					h = X_h3Rotate60cw(tls, h)
				}
			}
		}
	}
	return h
}

// *
// Rotate an H3Index 60 degrees counter-clockwise.
// @param h The H3Index.
func X_h3Rotate60ccw(tls *libc.TLS, h uint64) uint64 { /* h3Index.c:695:9: */
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		for ; r <= res; r++ {
			var oldDigit uint32 = uint32(h >> ((DMAX_H3_RES - r) * DH3_PER_DIGIT_OFFSET) & uint64(7))
			h = h & ^(uint64(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | uint64(X_rotate60ccw(tls, oldDigit))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)
		}
	}

	return h
}

// *
// Rotate an H3Index 60 degrees clockwise.
// @param h The H3Index.
func X_h3Rotate60cw(tls *libc.TLS, h uint64) uint64 { /* h3Index.c:708:9: */
	{
		var r int32 = 1
		var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
		for ; r <= res; r++ {
			h = h & ^(uint64(uint64(7))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)) | uint64(X_rotate60cw(tls, uint32(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7))))<<((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)
		}
	}

	return h
}

// *
// Convert an FaceIJK address to the corresponding H3Index.
// @param fijk The FaceIJK address.
// @param res The cell resolution.
// @return The encoded H3Index (or H3_NULL on failure).
func X_faceIjkToH3(tls *libc.TLS, fijk uintptr, res int32) uint64 { /* h3Index.c:722:9: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// initialize the index
	var h uint64 = 35184372088831
	h = h&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	h = h&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | uint64(res)<<DH3_RES_OFFSET

	// check for res 0/base cell
	if res == 0 {
		if (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fi > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fj > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fk > DMAX_FACE_COORD {
			// out of range input
			return uint64(DH3_NULL)
		}

		h = h&libc.CplUint64(uint64(uint64(127))<<DH3_BC_OFFSET) | uint64(X_faceIjkToBaseCell(tls, fijk))<<DH3_BC_OFFSET
		return h
	}

	// we need to find the correct base cell FaceIJK for this H3 index;
	// start with the passed in face and resolution res ijk coordinates
	// in that face's coordinate system
	*(*TFaceIJK)(unsafe.Pointer(bp /* fijkBC */)) = *(*TFaceIJK)(unsafe.Pointer(fijk))

	// build the H3Index from finest res up
	// adjust r for the fact that the res 0 base cell offsets the indexing
	// digits
	var ijk uintptr = bp + 4
	{
		var r int32 = res - 1
		for ; r >= 0; r-- {
			*(*TCoordIJK)(unsafe.Pointer(bp + 28 /* lastIJK */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
			// var lastCenter TCoordIJK at bp+16, 12

			if XisResolutionClassIII(tls, r+1) != 0 {
				// rotate ccw
				X_upAp7(tls, ijk)
				*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
				X_downAp7(tls, bp+16)
			} else {
				// rotate cw
				X_upAp7r(tls, ijk)
				*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))
				X_downAp7r(tls, bp+16)
			}
			// var diff TCoordIJK at bp+40, 12

			X_ijkSub(tls, bp+28, bp+16, bp+40)
			X_ijkNormalize(tls, bp+40)

			h = h & ^(uint64(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | uint64(X_unitIjkToDigit(tls, bp+40))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
		}
	}

	// fijkBC should now hold the IJK of the base cell in the
	// coordinate system of the current face

	if (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fi > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fj > DMAX_FACE_COORD || (*TFaceIJK)(unsafe.Pointer(bp)).Fcoord.Fk > DMAX_FACE_COORD {
		// out of range input
		return uint64(DH3_NULL)
	}

	// lookup the correct base cell
	var baseCell int32 = X_faceIjkToBaseCell(tls, bp)
	h = h&libc.CplUint64(uint64(uint64(127))<<DH3_BC_OFFSET) | uint64(baseCell)<<DH3_BC_OFFSET

	// rotate if necessary to get canonical base cell orientation
	// for this base cell
	var numRots int32 = X_faceIjkToBaseCellCCWrot60(tls, bp)
	if X_isBaseCellPentagon(tls, baseCell) != 0 {
		// force rotation out of missing k-axes sub-sequence
		if X_h3LeadingNonZeroDigit(tls, h) == K_AXES_DIGIT {
			// check for a cw/ccw offset face; default is ccw
			if X_baseCellIsCwOffset(tls, baseCell, (*TFaceIJK)(unsafe.Pointer(bp)).Fface) != 0 {
				h = X_h3Rotate60cw(tls, h)
			} else {
				h = X_h3Rotate60ccw(tls, h)
			}
		}

		{
			var i int32 = 0
			for ; i < numRots; i++ {
				h = X_h3RotatePent60ccw(tls, h)
			}
		}
	} else {
		{
			var i int32 = 0
			for ; i < numRots; i++ {
				h = X_h3Rotate60ccw(tls, h)
			}
		}
	}

	return h
}

// *
// Encodes a coordinate on the sphere to the H3 index of the containing cell at
// the specified resolution.
//
// Returns 0 on invalid input.
//
// @param g The spherical coordinates to encode.
// @param res The desired H3 resolution for the encoding.
// @param out The encoded H3Index.
// @returns E_SUCCESS (0) on success, another value otherwise
func XlatLngToCell(tls *libc.TLS, g uintptr, res int32, out uintptr) uint32 { /* h3Index.c:819:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	if !(XisXfinite(tls, (*TLatLng)(unsafe.Pointer(g)).Flat) != 0) || !(XisXfinite(tls, (*TLatLng)(unsafe.Pointer(g)).Flng) != 0) {
		return E_LATLNG_DOMAIN
	}
	// var fijk TFaceIJK at bp, 16

	X_geoToFaceIjk(tls, g, res, bp)
	*(*uint64)(unsafe.Pointer(out)) = X_faceIjkToH3(tls, bp, res)
	if func() int32 {
		if *(*uint64)(unsafe.Pointer(out)) != 0 {
			return 1
		}
		return func() int32 {
			if 0 != 0 {
			} else {
				libc.X__assert_fail(tls, ts, ts+939, int32(830), uintptr(unsafe.Pointer(&__func__8)))
			}
			return 0
		}()
	}() != 0 {
		return E_SUCCESS
	} else {
		return E_FAILED
	}
	return uint32(0)
}

var __func__8 = *(*[13]int8)(unsafe.Pointer(ts + 988)) /* h3Index.c:819:73 */

// *
// Convert an H3Index to the FaceIJK address on a specified icosahedral face.
// @param h The H3Index.
// @param fijk The FaceIJK address, initialized with the desired face
//
//	and normalized base cell coordinates.
//
// @return Returns 1 if the possibility of overage exists, otherwise 0.
func X_h3ToFaceIjkWithInitializedFijk(tls *libc.TLS, h uint64, fijk uintptr) int32 { /* h3Index.c:844:5: */
	var ijk uintptr = fijk + 4
	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	// center base cell hierarchy is entirely on this face
	var possibleOverage int32 = 1
	if !(X_isBaseCellPentagon(tls, int32(h&(uint64(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET)) != 0) && (res == 0 || (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fi == 0 && (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fj == 0 && (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fk == 0) {
		possibleOverage = 0
	}

	{
		var r int32 = 1
		for ; r <= res; r++ {
			if XisResolutionClassIII(tls, r) != 0 {
				// Class III == rotate ccw
				X_downAp7(tls, ijk)
			} else {
				// Class II == rotate cw
				X_downAp7r(tls, ijk)
			}

			X_neighbor(tls, ijk, uint32(h>>((DMAX_H3_RES-r)*DH3_PER_DIGIT_OFFSET)&uint64(7)))
		}
	}

	return possibleOverage
}

// *
// Convert an H3Index to a FaceIJK address.
// @param h The H3Index.
// @param fijk The corresponding FaceIJK address.
func X_h3ToFaceIjk(tls *libc.TLS, h uint64, fijk uintptr) uint32 { /* h3Index.c:875:9: */
	var baseCell int32 = int32(h & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if func() int32 {
		if baseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+939, int32(877), uintptr(unsafe.Pointer(&__func__9)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || baseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		// To prevent reading uninitialized memory, we zero the output.
		(*TFaceIJK)(unsafe.Pointer(fijk)).Fface = 0
		(*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord.Fi = libc.AssignPtrInt32(fijk+4+4, libc.AssignPtrInt32(fijk+4+8, 0))
		return E_CELL_INVALID
	}
	// adjust for the pentagonal missing sequence; all of sub-sequence 5 needs
	// to be adjusted (and some of sub-sequence 4 below)
	if X_isBaseCellPentagon(tls, baseCell) != 0 && X_h3LeadingNonZeroDigit(tls, h) == uint32(5) {
		h = X_h3Rotate60cw(tls, h)
	}

	// start with the "home" face and ijk+ coordinates for the base cell of c
	*(*TFaceIJK)(unsafe.Pointer(fijk)) = XbaseCellData[baseCell].FhomeFijk
	if !(X_h3ToFaceIjkWithInitializedFijk(tls, h, fijk) != 0) {
		return E_SUCCESS
	} // no overage is possible; h lies on this face

	// if we're here we have the potential for an "overage"; i.e., it is
	// possible that c lies on an adjacent face

	var origIJK = (*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord

	// if we're in Class III, drop into the next finer Class II grid
	var res int32 = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if XisResolutionClassIII(tls, res) != 0 {
		// Class III
		X_downAp7r(tls, fijk+4)
		res++
	}

	// adjust for overage if needed
	// a pentagon base cell with a leading 4 digit requires special handling
	var pentLeading4 int32 = libc.Bool32(X_isBaseCellPentagon(tls, baseCell) != 0 && X_h3LeadingNonZeroDigit(tls, h) == uint32(4))
	if X_adjustOverageClassII(tls, fijk, res, pentLeading4, 0) != NO_OVERAGE {
		// if the base cell is a pentagon we have the potential for secondary
		// overages
		if X_isBaseCellPentagon(tls, baseCell) != 0 {
			for X_adjustOverageClassII(tls, fijk, res, 0, 0) != NO_OVERAGE {
				continue
			}
		}

		if res != int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
			X_upAp7r(tls, fijk+4)
		}
	} else if res != int32(h&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		(*TFaceIJK)(unsafe.Pointer(fijk)).Fcoord = origIJK
	}
	return E_SUCCESS
}

var __func__9 = *(*[13]int8)(unsafe.Pointer(ts + 1001)) /* h3Index.c:875:48 */

// *
// Determines the spherical coordinates of the center point of an H3 index.
//
// @param h3 The H3 index.
// @param g The spherical coordinates of the H3 cell center.
func XcellToLatLng(tls *libc.TLS, h3 uint64, g uintptr) uint32 { /* h3Index.c:932:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var fijk TFaceIJK at bp, 16

	var e uint32 = X_h3ToFaceIjk(tls, h3, bp)
	if e != 0 {
		return e
	}
	X_faceIjkToGeo(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), g)
	return E_SUCCESS
}

// *
// Determines the cell boundary in spherical coordinates for an H3 index.
//
// @param h3 The H3 index.
// @param cb The boundary of the H3 cell in spherical coordinates.
func XcellToBoundary(tls *libc.TLS, h3 uint64, cb uintptr) uint32 { /* h3Index.c:948:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var fijk TFaceIJK at bp, 16

	var e uint32 = X_h3ToFaceIjk(tls, h3, bp)
	if e != 0 {
		return e
	}
	if XisPentagon(tls, h3) != 0 {
		X_faceIjkPentToCellBoundary(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), 0,
			DNUM_PENT_VERTS, cb)
	} else {
		X_faceIjkToCellBoundary(tls, bp, int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET), 0, DNUM_HEX_VERTS,
			cb)
	}
	return E_SUCCESS
}

// *
// Returns the max number of possible icosahedron faces an H3 index
// may intersect.
//
// @return int count of faces
func XmaxFaceCount(tls *libc.TLS, h3 uint64, out uintptr) uint32 { /* h3Index.c:970:9: */
	// a pentagon always intersects 5 faces, a hexagon never intersects more
	// than 2 (but may only intersect 1)
	*(*int32)(unsafe.Pointer(out)) = func() int32 {
		if XisPentagon(tls, h3) != 0 {
			return 5
		}
		return 2
	}()
	return E_SUCCESS
}

// *
// Find all icosahedron faces intersected by a given H3 index, represented
// as integers from 0-19. The array is sparse; since 0 is a valid value,
// invalid array values are represented as -1. It is the responsibility of
// the caller to filter out invalid values.
//
// @param h3 The H3 index
// @param out Output array. Must be of size maxFaceCount(h3).
func XgetIcosahedronFaces(tls *libc.TLS, h3 uint64, out uintptr) uint32 { /* h3Index.c:986:9: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	*(*int32)(unsafe.Pointer(bp + 16 /* res */)) = int32(h3 & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var isPent int32 = XisPentagon(tls, h3)

	// We can't use the vertex-based approach here for class II pentagons,
	// because all their vertices are on the icosahedron edges. Their
	// direct child pentagons cross the same faces, so use those instead.
	if isPent != 0 && !(XisResolutionClassIII(tls, *(*int32)(unsafe.Pointer(bp + 16))) != 0) {
		// Note that this would not work for res 15, but this is only run on
		// Class II pentagons, it should never be invoked for a res 15 index.
		var childPentagon uint64 = XmakeDirectChild(tls, h3, 0)
		return XgetIcosahedronFaces(tls, childPentagon, out)
	}

	// convert to FaceIJK
	// var fijk TFaceIJK at bp, 16

	var err uint32 = X_h3ToFaceIjk(tls, h3, bp)
	if err != 0 {
		return err
	}

	// Get all vertices as FaceIJK addresses. For simplicity, always
	// initialize the array with 6 verts, ignoring the last one for pentagons
	// var fijkVerts [6]TFaceIJK at bp+20, 96

	var vertexCount int32

	if isPent != 0 {
		vertexCount = DNUM_PENT_VERTS
		X_faceIjkPentToVerts(tls, bp, bp+16, bp+20)
	} else {
		vertexCount = DNUM_HEX_VERTS
		X_faceIjkToVerts(tls, bp, bp+16, bp+20)
	}

	// We may not use all of the slots in the output array,
	// so fill with invalid values to indicate unused slots
	// var faceCount int32 at bp+116, 4

	var maxFaceCountError uint32 = XmaxFaceCount(tls, h3, bp+116)
	if func() int32 {
		if maxFaceCountError != E_SUCCESS {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+939, int32(1024), uintptr(unsafe.Pointer(&__func__10)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return maxFaceCountError
	}
	{
		var i int32 = 0
		for ; i < *(*int32)(unsafe.Pointer(bp + 116)); i++ {
			*(*int32)(unsafe.Pointer(out + uintptr(i)*4)) = -1
		}
	}

	// add each vertex face, using the output array as a hash set
	{
		var i1 int32 = 0
		for ; i1 < vertexCount; i1++ {
			var vert uintptr = bp + 20 + uintptr(i1)*16

			// Adjust overage, determining whether this vertex is
			// on another face
			if isPent != 0 {
				X_adjustPentVertOverage(tls, vert, *(*int32)(unsafe.Pointer(bp + 16 /* res */)))
			} else {
				X_adjustOverageClassII(tls, vert, *(*int32)(unsafe.Pointer(bp + 16 /* res */)), 0, 1)
			}

			// Save the face to the output array
			var face int32 = (*TFaceIJK)(unsafe.Pointer(vert)).Fface
			var pos int32 = 0
			// Find the first empty output position, or the first position
			// matching the current face
			for *(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) != -1 && *(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) != face {
				pos++
				if pos >= *(*int32)(unsafe.Pointer(bp + 116)) {
					// Mismatch between the heuristic used in maxFaceCount and
					// calculation here - indicates an invalid index.
					return E_FAILED
				}
			}
			*(*int32)(unsafe.Pointer(out + uintptr(pos)*4)) = face
		}
	}
	return E_SUCCESS
}

var __func__10 = *(*[20]int8)(unsafe.Pointer(ts + 1014)) /* h3Index.c:986:62 */

// *
// pentagonCount returns the number of pentagons (same at any resolution)
//
// @return int count of pentagon indexes
func XpentagonCount(tls *libc.TLS) int32 { /* h3Index.c:1066:5: */
	return DNUM_PENTAGONS
}

// *
// Generates all pentagons at the specified resolution
//
// @param res The resolution to produce pentagons at.
// @param out Output array. Must be of size pentagonCount().
func XgetPentagons(tls *libc.TLS, res int32, out uintptr) uint32 { /* h3Index.c:1074:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	var i int32 = 0
	{
		var bc int32 = 0
		for ; bc < DNUM_BASE_CELLS; bc++ {
			if X_isBaseCellPentagon(tls, bc) != 0 {
				// var pentagon uint64 at bp, 8

				XsetH3Index(tls, bp, res, bc, uint32(0))
				*(*uint64)(unsafe.Pointer(out + uintptr(libc.PostIncInt32(&i, 1))*8)) = *(*uint64)(unsafe.Pointer(bp /* pentagon */))
			}
		}
	}
	return E_SUCCESS
}

// *
// Returns whether or not a resolution is a Class III grid. Note that odd
// resolutions are Class III and even resolutions are Class II.
// @param res The H3 resolution.
// @return 1 if the resolution is a Class III grid, and 0 if the resolution is
//
//	a Class II grid.
func XisResolutionClassIII(tls *libc.TLS, res int32) int32 { /* h3Index.c:1096:5: */
	return res % 2
}

// *
// Validate a child position in the context of a given parent, returning
// an error if validation fails.
func validateChildPos(tls *libc.TLS, childPos int64, parent uint64, childRes int32) uint32 { /* h3Index.c:1102:16: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var maxChildCount int64 at bp, 8

	var sizeError uint32 = XcellToChildrenSize(tls, parent, childRes, bp)
	if func() int32 {
		if sizeError != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+939, int32(1107), uintptr(unsafe.Pointer(&__func__11)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		return sizeError
	}
	if childPos < int64(0) || childPos >= *(*int64)(unsafe.Pointer(bp)) {
		return E_DOMAIN
	}
	return E_SUCCESS
}

var __func__11 = *(*[17]int8)(unsafe.Pointer(ts + 1034)) /* h3Index.c:1103:47 */

// *
// Returns the position of the cell within an ordered list of all children of
// the cell's parent at the specified resolution
func XcellToChildPos(tls *libc.TLS, child uint64, parentRes int32, out uintptr) uint32 { /* h3Index.c:1120:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var childRes int32 = int32(child & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	// Get the parent at res. This will catch any resolution errors
	// var originalParent uint64 at bp, 8

	var parentError uint32 = XcellToParent(tls, child, parentRes, bp)
	if parentError != 0 {
		return parentError
	}

	// Define the initial parent. Note that these variables are reassigned
	// within the loop.
	*(*uint64)(unsafe.Pointer(bp + 8 /* parent */)) = *(*uint64)(unsafe.Pointer(bp /* originalParent */))
	var parentIsPentagon int32 = XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp + 8 /* parent */)))

	// Walk up the resolution digits, incrementing the index
	*(*int64)(unsafe.Pointer(out)) = int64(0)
	if parentIsPentagon != 0 {
		// Pentagon logic. Pentagon parents skip the 1 digit, so the offsets are
		// different from hexagons
		{
			var res int32 = childRes
			for ; res > parentRes; res-- {
				var parentError uint32 = XcellToParent(tls, child, res-1, bp+8)
				if func() int32 {
					if parentError != 0 {
						return func() int32 {
							if 0 != 0 {
							} else {
								libc.X__assert_fail(tls, ts, ts+939, int32(1143), uintptr(unsafe.Pointer(&__func__12)))
							}
							return 1
						}()
					}
					return 0
				}() != 0 {
					return parentError
				}

				parentIsPentagon = XisPentagon(tls, *(*uint64)(unsafe.Pointer(bp + 8 /* parent */)))
				var rawDigit int32 = int32(int32(child >> ((DMAX_H3_RES - res) * DH3_PER_DIGIT_OFFSET) & uint64(7)))
				// Validate the digit before proceeding
				if rawDigit == INVALID_DIGIT || parentIsPentagon != 0 && rawDigit == K_AXES_DIGIT {
					return E_CELL_INVALID
				}
				var digit int32
				if parentIsPentagon != 0 && rawDigit > 0 {
					digit = rawDigit - 1
				} else {
					digit = rawDigit
				}
				if digit != CENTER_DIGIT {
					var hexChildCount int64 = X_ipow(tls, int64(7), int64(childRes-res))
					// The offset for the 0-digit slot depends on whether the
					// current index is the child of a pentagon. If so, the offset
					// is based on the count of pentagon children, otherwise,
					// hexagon children.
					*(*int64)(unsafe.Pointer(out)) += func() int64 {
						if parentIsPentagon != 0 {
							return int64(1) + int64(5)*(hexChildCount-int64(1))/int64(6)
						}
						return hexChildCount
					}() + int64(digit-1)*hexChildCount
				}
			}
		}
	} else {
		// Hexagon logic. Offsets are simple powers of 7
		{
			var res int32 = childRes
			for ; res > parentRes; res-- {
				var digit int32 = int32(int32(child >> ((DMAX_H3_RES - res) * DH3_PER_DIGIT_OFFSET) & uint64(7)))
				if digit == INVALID_DIGIT {
					return E_CELL_INVALID
				}
				*(*int64)(unsafe.Pointer(out)) += int64(digit) * X_ipow(tls, int64(7), int64(childRes-res))
			}
		}
	}

	if func() int32 {
		if validateChildPos(tls, *(*int64)(unsafe.Pointer(out)), *(*uint64)(unsafe.Pointer(bp)), childRes) != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+939, int32(1183), uintptr(unsafe.Pointer(&__func__12)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// This is the result of an internal error, so return E_FAILED
		// instead of the validation error
		return E_FAILED
	}

	return E_SUCCESS
}

var __func__12 = *(*[15]int8)(unsafe.Pointer(ts + 1051)) /* h3Index.c:1120:79 */

// *
// Returns the child cell at a given position within an ordered list of all
// children at the specified resolution
func XchildPosToCell(tls *libc.TLS, childPos int64, parent uint64, childRes int32, child uintptr) uint32 { /* h3Index.c:1195:9: */
	// Validate resolution
	if childRes < 0 || childRes > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	// Validate parent resolution
	var parentRes int32 = int32(parent & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	if childRes < parentRes {
		return E_RES_MISMATCH
	}
	// Validate child pos
	var childPosErr uint32 = validateChildPos(tls, childPos, parent, childRes)
	if childPosErr != 0 {
		return childPosErr
	}

	var resOffset int32 = childRes - parentRes

	*(*uint64)(unsafe.Pointer(child)) = parent
	var idx int64 = childPos

	*(*uint64)(unsafe.Pointer(child)) = *(*uint64)(unsafe.Pointer(child))&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | uint64(childRes)<<DH3_RES_OFFSET

	if XisPentagon(tls, parent) != 0 {
		// Pentagon tile logic. Pentagon tiles skip the 1 digit, so the offsets
		// are different
		var inPent uint8 = uint8(Dtrue)
		{
			var res int32 = 1
			for ; res <= resOffset; res++ {
				var resWidth int64 = X_ipow(tls, int64(7), int64(resOffset-res))
				if inPent != 0 {
					// While we are inside a parent pentagon, we need to check if
					// this cell is a pentagon, and if not, we need to offset its
					// digit to account for the skipped direction
					var pentWidth int64 = int64(1) + int64(5)*(resWidth-int64(1))/int64(6)
					if idx < pentWidth {
						*(*uint64)(unsafe.Pointer(child)) = *(*uint64)(unsafe.Pointer(child)) & ^(uint64(uint64(7))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)) | uint64(uint64(0))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)
					} else {
						idx = idx - pentWidth
						inPent = uint8(Dfalse)
						*(*uint64)(unsafe.Pointer(child)) = *(*uint64)(unsafe.Pointer(child)) & ^(uint64(uint64(7))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)) | uint64(idx/resWidth+int64(2))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)
						idx = idx % resWidth
					}
				} else {
					// We're no longer inside a pentagon, continue as for hex
					*(*uint64)(unsafe.Pointer(child)) = *(*uint64)(unsafe.Pointer(child)) & ^(uint64(uint64(7))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)) | uint64(idx/resWidth)<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)
					idx = idx % resWidth
				}
			}
		}
	} else {
		// Hexagon tile logic. Offsets are simple powers of 7
		{
			var res int32 = 1
			for ; res <= resOffset; res++ {
				var resWidth int64 = X_ipow(tls, int64(7), int64(resOffset-res))
				*(*uint64)(unsafe.Pointer(child)) = *(*uint64)(unsafe.Pointer(child)) & ^(uint64(uint64(7))<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)) | uint64(idx/resWidth)<<((DMAX_H3_RES-(parentRes+res))*DH3_PER_DIGIT_OFFSET)
				idx = idx % resWidth
			}
		}
	}

	return E_SUCCESS
}

func XisXfinite(tls *libc.TLS, f float64) uint8 { /* isfinite.c:3:6: */
	return libc.BoolUint8(!(libc.X__builtin_isnan(tls, f-f) != 0))
}

// extract the `res` digit (0--7) of the current cell
func _getResDigit(tls *libc.TLS, it uintptr, res int32) int32 { /* iterators.c:27:12: */
	return int32(int32((*TIterCellsChildren)(unsafe.Pointer(it)).Fh >> ((DMAX_H3_RES - res) * DH3_PER_DIGIT_OFFSET) & uint64(7)))
}

// increment the digit (0--7) at location `res`
// H3_PER_DIGIT_OFFSET == 3
func _incrementResDigit(tls *libc.TLS, it uintptr, res int32) { /* iterators.c:33:13: */
	var val uint64 = uint64(1)
	val <<= DH3_PER_DIGIT_OFFSET * (DMAX_H3_RES - res)
	*(*uint64)(unsafe.Pointer(it)) += val
}

// *
// Create a fully nulled-out child iterator for when an iterator is exhausted.
// This helps minimize the chance that a user will depend on the iterator
// internal state after it's exhausted, like the child resolution, for
// example.
func _null_iter(tls *libc.TLS) TIterCellsChildren { /* iterators.c:45:26: */
	return TIterCellsChildren{F_parentRes: -1, F_skipDigit: -1}
}

//*
//
// ## Logic for iterating through the children of a cell
//
// We'll describe the logic for ....
//
// - normal (non pentagon iteration)
// - pentagon iteration. define "pentagon digit"
//
//
// ### Cell Index Component Diagrams
//
// The lower 56 bits of an H3 Cell Index describe the following index components:
//
// - the cell resolution (4 bits)
// - the base cell number (7 bits)
// - the child cell digit for each resolution from 1 to 15 (3*15 = 45 bits)
//
// These are the bits we'll be focused on when iterating through child cells.
// To help describe the iteration logic, we'll use diagrams displaying the
// (decimal) values for each component like:
//
//                             child digit for resolution 2
//                            /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 | ... |
// |-----|-------------|---|---|---|---|---|---|-----|
// |   9 |          17 | 5 | 3 | 0 | 6 | 2 | 1 | ... |
//
//
// ### Iteration through children of a hexagon (but not a pentagon)
//
// Iteration through the children of a *hexagon* (but not a pentagon)
// simply involves iterating through all the children values (0--6)
// for each child digit (up to the child's resolution).
//
// For example, suppose a resolution 3 hexagon index has the following
// components:
//                                 parent resolution
//                                /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 | ... |
// |-----|-------------|---|---|---|---|---|---|-----|
// |   3 |          17 | 3 | 5 | 1 | 7 | 7 | 7 | ... |
//
// The iteration through all children of resolution 6 would look like:
//
//
//                                 parent res  child res
//                                /           /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | ... |
// |-----|-------------|---|---|---|---|---|---|---|---|-----|
// | 6   |          17 | 3 | 5 | 1 | 0 | 0 | 0 | 7 | 7 | ... |
// | 6   |          17 | 3 | 5 | 1 | 0 | 0 | 1 | 7 | 7 | ... |
// | ... |             |   |   |   |   |   |   |   |   |     |
// | 6   |          17 | 3 | 5 | 1 | 0 | 0 | 6 | 7 | 7 | ... |
// | 6   |          17 | 3 | 5 | 1 | 0 | 1 | 0 | 7 | 7 | ... |
// | 6   |          17 | 3 | 5 | 1 | 0 | 1 | 1 | 7 | 7 | ... |
// | ... |             |   |   |   |   |   |   |   |   |     |
// | 6   |          17 | 3 | 5 | 1 | 6 | 6 | 6 | 7 | 7 | ... |
//
//
// ### Step sequence on a *pentagon* cell
//
// Pentagon cells have a base cell number (e.g., 97) corresponding to a
// resolution 0 pentagon, and have all zeros from digit 1 to the digit
// corresponding to the cell's resolution.
// (We'll drop the ellipses from now on, knowing that digits should contain
// 7's beyond the cell resolution.)
//
//                             parent res      child res
//                            /               /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 0 | 0 |
//
// Iteration through children of a *pentagon* is almost the same
// as *hexagon* iteration, except that we skip the *first* 1 value
// that appears in the "skip digit". This corresponds to the fact
// that a pentagon only has 6 children, which are denoted with
// the numbers {0,2,3,4,5,6}.
//
// The skip digit starts at the child resolution position.
// When iterating through children more than one resolution below
// the parent, we move the skip digit to the left
// (up to the next coarser resolution) each time we skip the 1 value
// in that digit.
//
// Iteration would start like:
//
//                             parent res      child res
//                            /               /
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 0 | 0 |
//                                                                                        skip digit
//
// Noticing we skip the 1 value and move the skip digit,
// the next iterate would be:
//
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 0 | 2 |
//                                                                                skip digit
//
// Iteration continues normally until we get to:
//
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 0 | 6 |
//                                                                                skip digit
//
// which is followed by (skipping the 1):
//
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 2 | 0 |
//                                                                        skip digit
//
// For the next iterate, we won't skip the `1` in the previous digit
// because it is no longer the skip digit:
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 2 | 1 |
//                                                                        skip digit
//
// Iteration continues normally until we're right before the next skip
// digit:
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 0 | 6 | 6 |
//                                                                        skip digit
//
// Which is followed by
//
// | res | base cell # | 1 | 2 | 3 | 4 | 5 | 6 |
// |-----|-------------|---|---|---|---|---|---|
// |   6 |          97 | 0 | 0 | 0 | 2 | 0 | 0 |
//                                                                skip digit
//
// and so on.
//
//

// *
// Initialize a IterCellsChildren struct representing the sequence giving
// the children of cell `h` at resolution `childRes`.
//
// At any point in the iteration, starting once
// the struct is initialized, IterCellsChildren.h gives the current child.
//
// Also, IterCellsChildren.h == H3_NULL when all the children have been iterated
// through, or if the input to `iterInitParent` was invalid.
func XiterInitParent(tls *libc.TLS, h uint64, childRes int32) TIterCellsChildren { /* iterators.c:214:19: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var it TIterCellsChildren at bp, 16

	X_iterInitParent(tls, h, childRes, bp)
	return *(*TIterCellsChildren)(unsafe.Pointer(bp /* it */))
}

// *
// Internal function - initialize a parent iterator in-place
func X_iterInitParent(tls *libc.TLS, h uint64, childRes int32, iter uintptr) { /* iterators.c:223:6: */
	(*TIterCellsChildren)(unsafe.Pointer(iter)).F_parentRes = int32(h & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	if childRes < (*TIterCellsChildren)(unsafe.Pointer(iter)).F_parentRes || childRes > DMAX_H3_RES || h == uint64(DH3_NULL) {
		*(*TIterCellsChildren)(unsafe.Pointer(iter)) = _null_iter(tls)
		return
	}

	(*TIterCellsChildren)(unsafe.Pointer(iter)).Fh = X_zeroIndexDigits(tls, h, (*TIterCellsChildren)(unsafe.Pointer(iter)).F_parentRes+1, childRes)
	(*TIterCellsChildren)(unsafe.Pointer(iter)).Fh = (*TIterCellsChildren)(unsafe.Pointer(iter)).Fh&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | uint64(childRes)<<DH3_RES_OFFSET

	if XisPentagon(tls, (*TIterCellsChildren)(unsafe.Pointer(iter)).Fh) != 0 {
		// The skip digit skips `1` for pentagons.
		// The "_skipDigit" moves to the left as we count up from the
		// child resolution to the parent resolution.
		(*TIterCellsChildren)(unsafe.Pointer(iter)).F_skipDigit = childRes
	} else {
		// if not a pentagon, we can ignore "skip digit" logic
		(*TIterCellsChildren)(unsafe.Pointer(iter)).F_skipDigit = -1
	}
}

// *
// Step a IterCellsChildren to the next child cell.
// When the iteration is over, IterCellsChildren.h will be H3_NULL.
// Handles iterating through hexagon and pentagon cells.
func XiterStepChild(tls *libc.TLS, it uintptr) { /* iterators.c:250:6: */
	// once h == H3_NULL, the iterator returns an infinite sequence of H3_NULL
	if (*TIterCellsChildren)(unsafe.Pointer(it)).Fh == uint64(DH3_NULL) {
		return
	}

	var childRes int32 = int32((*TIterCellsChildren)(unsafe.Pointer(it)).Fh & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	_incrementResDigit(tls, it, childRes)

	{
		var i int32 = childRes
		for ; i >= (*TIterCellsChildren)(unsafe.Pointer(it)).F_parentRes; i-- {
			if i == (*TIterCellsChildren)(unsafe.Pointer(it)).F_parentRes {
				// if we're modifying the parent resolution digit, then we're done
				*(*TIterCellsChildren)(unsafe.Pointer(it)) = _null_iter(tls)
				return
			}

			// PENTAGON_SKIPPED_DIGIT == 1
			if i == (*TIterCellsChildren)(unsafe.Pointer(it)).F_skipDigit && _getResDigit(tls, it, i) == PENTAGON_SKIPPED_DIGIT {
				// Then we are iterating through the children of a pentagon cell.
				// All children of a pentagon have the property that the first
				// nonzero digit between the parent and child resolutions is
				// not 1.
				// I.e., we never see a sequence like 00001.
				// Thus, we skip the `1` in this digit.
				_incrementResDigit(tls, it, i)
				*(*int32)(unsafe.Pointer(it + 12)) -= 1
				return
			}

			// INVALID_DIGIT == 7
			if _getResDigit(tls, it, i) == INVALID_DIGIT {
				_incrementResDigit(tls,
					it, i) // zeros out it[i] and increments it[i-1] by 1
			} else {
				break
			}
		}
	}
}

// create iterator for children of base cell at given resolution
func XiterInitBaseCellNum(tls *libc.TLS, baseCellNum int32, childRes int32) TIterCellsChildren { /* iterators.c:290:19: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if baseCellNum < 0 || baseCellNum >= DNUM_BASE_CELLS || childRes < 0 || childRes > DMAX_H3_RES {
		return _null_iter(tls)
	}
	// var baseCell uint64 at bp, 8

	XsetH3Index(tls, bp, 0, baseCellNum, uint32(0))

	return XiterInitParent(tls, *(*uint64)(unsafe.Pointer(bp /* baseCell */)), childRes)
}

// create iterator for all cells at given resolution
func XiterInitRes(tls *libc.TLS, res int32) TIterCellsResolution { /* iterators.c:303:21: */
	var itC = XiterInitBaseCellNum(tls, 0, res)

	var itR = TIterCellsResolution{Fh: itC.Fh, F_res: res, F_itC: itC}

	return itR
}

func XiterStepRes(tls *libc.TLS, itR uintptr) { /* iterators.c:312:6: */
	// reached the end of over iterator; emits H3_NULL from now on
	if (*TIterCellsResolution)(unsafe.Pointer(itR)).Fh == uint64(DH3_NULL) {
		return
	}

	// step child iterator
	XiterStepChild(tls, itR+16)

	// If the child iterator is exhausted and there are still
	// base cells remaining, we initialize the next base cell child iterator
	if (*TIterCellsResolution)(unsafe.Pointer(itR)).F_itC.Fh == uint64(DH3_NULL) && (*TIterCellsResolution)(unsafe.Pointer(itR)).F_baseCellNum+1 < DNUM_BASE_CELLS {
		*(*int32)(unsafe.Pointer(itR + 8)) += 1
		(*TIterCellsResolution)(unsafe.Pointer(itR)).F_itC = XiterInitBaseCellNum(tls, (*TIterCellsResolution)(unsafe.Pointer(itR)).F_baseCellNum, (*TIterCellsResolution)(unsafe.Pointer(itR)).F_res)
	}

	// This overall iterator reflects the next cell in the child iterator.
	// Note: This sets itR->h = H3_NULL if the base cells were
	// exhausted in the check above.
	(*TIterCellsResolution)(unsafe.Pointer(itR)).Fh = (*TIterCellsResolution)(unsafe.Pointer(itR)).F_itC.Fh
}

// *
// Normalizes radians to a value between 0.0 and two PI.
//
// @param rads The input radians value.
// @return The normalized radians value.
func X_posAngleRads(tls *libc.TLS, rads float64) float64 { /* latLng.c:36:8: */
	var tmp float64 = func() float64 {
		if rads < 0.0 {
			return rads + 6.28318530717958647692528676655900576839433
		}
		return rads
	}()
	if rads >= 6.28318530717958647692528676655900576839433 {
		tmp = tmp - 6.28318530717958647692528676655900576839433
	}
	return tmp
}

// *
// Determines if the components of two spherical coordinates are within some
// threshold distance of each other.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @param threshold The threshold distance.
// @return Whether or not the two coordinates are within the threshold distance
//
//	of each other.
func XgeoAlmostEqualThreshold(tls *libc.TLS, p1 uintptr, p2 uintptr, threshold float64) uint8 { /* latLng.c:52:6: */
	return uint8(libc.Bool32(libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat-(*TLatLng)(unsafe.Pointer(p2)).Flat) < threshold && libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p1)).Flng-(*TLatLng)(unsafe.Pointer(p2)).Flng) < threshold))
}

// *
// Determines if the components of two spherical coordinates are within our
// standard epsilon distance of each other.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @return Whether or not the two coordinates are within the epsilon distance
//
//	of each other.
func XgeoAlmostEqual(tls *libc.TLS, p1 uintptr, p2 uintptr) uint8 { /* latLng.c:67:6: */
	return XgeoAlmostEqualThreshold(tls, p1, p2, float64(.000000001)*0.0174532925199432957692369076848861271111)
}

// *
// Set the components of spherical coordinates in decimal degrees.
//
// @param p The spherical coordinates.
// @param latDegs The desired latitude in decimal degrees.
// @param lngDegs The desired longitude in decimal degrees.
func XsetGeoDegs(tls *libc.TLS, p uintptr, latDegs float64, lngDegs float64) { /* latLng.c:78:6: */
	X_setGeoRads(tls, p, XdegsToRads(tls, latDegs),
		XdegsToRads(tls, lngDegs))
}

// *
// Set the components of spherical coordinates in radians.
//
// @param p The spherical coordinates.
// @param latRads The desired latitude in decimal radians.
// @param lngRads The desired longitude in decimal radians.
func X_setGeoRads(tls *libc.TLS, p uintptr, latRads float64, lngRads float64) { /* latLng.c:90:6: */
	(*TLatLng)(unsafe.Pointer(p)).Flat = latRads
	(*TLatLng)(unsafe.Pointer(p)).Flng = lngRads
}

// *
// Convert from decimal degrees to radians.
//
// @param degrees The decimal degrees.
// @return The corresponding radians.
func XdegsToRads(tls *libc.TLS, degrees float64) float64 { /* latLng.c:101:8: */
	return degrees * 0.0174532925199432957692369076848861271111
}

// *
// Convert from radians to decimal degrees.
//
// @param radians The radians.
// @return The corresponding decimal degrees.
func XradsToDegs(tls *libc.TLS, radians float64) float64 { /* latLng.c:109:8: */
	return radians * 57.29577951308232087679815481410517033240547
}

// *
// constrainLat makes sure latitudes are in the proper bounds
//
// @param lat The original lat value
// @return The corrected lat value
func XconstrainLat(tls *libc.TLS, lat float64) float64 { /* latLng.c:117:8: */
	for lat > 1.57079632679489661923 {
		lat = lat - 3.14159265358979323846
	}
	return lat
}

// *
// constrainLng makes sure longitudes are in the proper bounds
//
// @param lng The origin lng value
// @return The corrected lng value
func XconstrainLng(tls *libc.TLS, lng float64) float64 { /* latLng.c:130:8: */
	for lng > 3.14159265358979323846 {
		lng = lng - float64(float64(2))*3.14159265358979323846
	}
	for lng < -3.14159265358979323846 {
		lng = lng + float64(float64(2))*3.14159265358979323846
	}
	return lng
}

// *
// Normalize an input longitude according to the specified normalization
// @param  lng           Input longitude
// @param  normalization Longitude normalization strategy
// @return               Normalized longitude
func XnormalizeLng(tls *libc.TLS, lng float64, normalization uint32) float64 { /* latLng.c:146:8: */
	switch normalization {
	case NORMALIZE_EAST:
		if lng < float64(0) {
			return lng + 6.28318530717958647692528676655900576839433
		}
		return lng
	case NORMALIZE_WEST:
		if lng > float64(0) {
			return lng - 6.28318530717958647692528676655900576839433
		}
		return lng
	default:
		return lng
	}
	return float64(0)
}

// *
// The great circle distance in radians between two spherical coordinates.
//
// This function uses the Haversine formula.
// For math details, see:
//
//	https://en.wikipedia.org/wiki/Haversine_formula
//	https://www.movable-type.co.uk/scripts/latlong.html
//
// @param  a  the first lat/lng pair (in radians)
// @param  b  the second lat/lng pair (in radians)
//
// @return    the great circle distance in radians between a and b
func XgreatCircleDistanceRads(tls *libc.TLS, a uintptr, b uintptr) float64 { /* latLng.c:171:8: */
	var sinLat float64 = libc.Xsin(tls, ((*TLatLng)(unsafe.Pointer(b)).Flat-(*TLatLng)(unsafe.Pointer(a)).Flat)*0.5)
	var sinLng float64 = libc.Xsin(tls, ((*TLatLng)(unsafe.Pointer(b)).Flng-(*TLatLng)(unsafe.Pointer(a)).Flng)*0.5)

	var A float64 = sinLat*sinLat + libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(a)).Flat)*libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(b)).Flat)*sinLng*sinLng

	return float64(2) * libc.Xatan2(tls, libc.Xsqrt(tls, A), libc.Xsqrt(tls, float64(1)-A))
}

// *
// The great circle distance in kilometers between two spherical coordinates.
func XgreatCircleDistanceKm(tls *libc.TLS, a uintptr, b uintptr) float64 { /* latLng.c:183:8: */
	return XgreatCircleDistanceRads(tls, a, b) * 6371.007180918475
}

// *
// The great circle distance in meters between two spherical coordinates.
func XgreatCircleDistanceM(tls *libc.TLS, a uintptr, b uintptr) float64 { /* latLng.c:190:8: */
	return XgreatCircleDistanceKm(tls, a, b) * float64(1000)
}

// *
// Determines the azimuth to p2 from p1 in radians.
//
// @param p1 The first spherical coordinates.
// @param p2 The second spherical coordinates.
// @return The azimuth in radians from p1 to p2.
func X_geoAzimuthRads(tls *libc.TLS, p1 uintptr, p2 uintptr) float64 { /* latLng.c:201:8: */
	return libc.Xatan2(tls, libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)*libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p2)).Flng-(*TLatLng)(unsafe.Pointer(p1)).Flng),
		libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)-libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)*libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flng-(*TLatLng)(unsafe.Pointer(p1)).Flng))
}

// *
// Computes the point on the sphere a specified azimuth and distance from
// another point.
//
// @param p1 The first spherical coordinates.
// @param az The desired azimuth from p1.
// @param distance The desired distance from p1, must be non-negative.
// @param p2 The spherical coordinates at the desired azimuth and distance from
// p1.
func X_geoAzDistanceRads(tls *libc.TLS, p1 uintptr, az float64, distance float64, p2 uintptr) { /* latLng.c:217:6: */
	if distance < 0.0000000000000001 {
		*(*TLatLng)(unsafe.Pointer(p2)) = *(*TLatLng)(unsafe.Pointer(p1))
		return
	}
	var sinlat float64
	var sinlng float64
	var coslng float64

	az = X_posAngleRads(tls, az)

	// check for due north/south azimuth
	if az < 0.0000000000000001 || libc.Xfabs(tls, az-3.14159265358979323846) < 0.0000000000000001 {
		if az < 0.0000000000000001 { // due north
			(*TLatLng)(unsafe.Pointer(p2)).Flat = (*TLatLng)(unsafe.Pointer(p1)).Flat + distance
		} else { // due south
			(*TLatLng)(unsafe.Pointer(p2)).Flat = (*TLatLng)(unsafe.Pointer(p1)).Flat - distance
		}

		if libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat-1.57079632679489661923) < 0.0000000000000001 {
			(*TLatLng)(unsafe.Pointer(p2)).Flat = 1.57079632679489661923
			(*TLatLng)(unsafe.Pointer(p2)).Flng = 0.0
		} else if libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat+1.57079632679489661923) < 0.0000000000000001 {
			(*TLatLng)(unsafe.Pointer(p2)).Flat = -1.57079632679489661923
			(*TLatLng)(unsafe.Pointer(p2)).Flng = 0.0
		} else {
			(*TLatLng)(unsafe.Pointer(p2)).Flng = XconstrainLng(tls, (*TLatLng)(unsafe.Pointer(p1)).Flng)
		}
	} else {
		sinlat = libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xcos(tls, distance) + libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, distance)*libc.Xcos(tls, az)
		if sinlat > 1.0 {
			sinlat = 1.0
		}
		if sinlat < -1.0 {
			sinlat = -1.0
		}
		(*TLatLng)(unsafe.Pointer(p2)).Flat = libc.Xasin(tls, sinlat)
		if libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat-1.57079632679489661923) < 0.0000000000000001 {
			(*TLatLng)(unsafe.Pointer(p2)).Flat = 1.57079632679489661923
			(*TLatLng)(unsafe.Pointer(p2)).Flng = 0.0
		} else if libc.Xfabs(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat+1.57079632679489661923) < 0.0000000000000001 {
			(*TLatLng)(unsafe.Pointer(p2)).Flat = -1.57079632679489661923
			(*TLatLng)(unsafe.Pointer(p2)).Flng = 0.0
		} else {
			var invcosp2lat float64 = 1.0 / libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)
			sinlng = libc.Xsin(tls, az) * libc.Xsin(tls, distance) * invcosp2lat
			coslng = (libc.Xcos(tls, distance) - libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat)*libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(p2)).Flat)) / libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(p1)).Flat) * invcosp2lat
			if sinlng > 1.0 {
				sinlng = 1.0
			}
			if sinlng < -1.0 {
				sinlng = -1.0
			}
			if coslng > 1.0 {
				coslng = 1.0
			}
			if coslng < -1.0 {
				coslng = -1.0
			}
			(*TLatLng)(unsafe.Pointer(p2)).Flng = XconstrainLng(tls, (*TLatLng)(unsafe.Pointer(p1)).Flng+libc.Xatan2(tls, sinlng, coslng))
		}
	}
}

// The following functions provide meta information about the H3 hexagons at
// each zoom level. Since there are only 16 total levels, these are current
// handled with hardwired static values, but it may be worthwhile to put these
// static values into another file that can be autogenerated by source code in
// the future.

func XgetHexagonAreaAvgKm2(tls *libc.TLS, res int32, out uintptr) uint32 { /* latLng.c:282:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*float64)(unsafe.Pointer(out)) = areas[res]
	return E_SUCCESS
}

var areas = [16]float64{
	4.357449416078383e+06, 6.097884417941332e+05, 8.680178039899720e+04,
	1.239343465508816e+04, 1.770347654491307e+03, 2.529038581819449e+02,
	3.612906216441245e+01, 5.161293359717191e+00, 7.373275975944177e-01,
	1.053325134272067e-01, 1.504750190766435e-02, 2.149643129451879e-03,
	3.070918756316060e-04, 4.387026794728296e-05, 6.267181135324313e-06,
	8.953115907605790e-07} /* latLng.c:283:25 */

func XgetHexagonAreaAvgM2(tls *libc.TLS, res int32, out uintptr) uint32 { /* latLng.c:297:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*float64)(unsafe.Pointer(out)) = areas1[res]
	return E_SUCCESS
}

var areas1 = [16]float64{
	4.357449416078390e+12, 6.097884417941339e+11, 8.680178039899731e+10,
	1.239343465508818e+10, 1.770347654491309e+09, 2.529038581819452e+08,
	3.612906216441250e+07, 5.161293359717198e+06, 7.373275975944188e+05,
	1.053325134272069e+05, 1.504750190766437e+04, 2.149643129451882e+03,
	3.070918756316063e+02, 4.387026794728301e+01, 6.267181135324322e+00,
	8.953115907605802e-01} /* latLng.c:298:25 */

func XgetHexagonEdgeLengthAvgKm(tls *libc.TLS, res int32, out uintptr) uint32 { /* latLng.c:312:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*float64)(unsafe.Pointer(out)) = lens[res]
	return E_SUCCESS
}

var lens = [16]float64{
	1281.256011, 483.0568391, 182.5129565, 68.97922179,
	26.07175968, 9.854090990, 3.724532667, 1.406475763,
	0.531414010, 0.200786148, 0.075863783, 0.028663897,
	0.010830188, 0.004092010, 0.001546100, 0.000584169} /* latLng.c:313:25 */

func XgetHexagonEdgeLengthAvgM(tls *libc.TLS, res int32, out uintptr) uint32 { /* latLng.c:325:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*float64)(unsafe.Pointer(out)) = lens1[res]
	return E_SUCCESS
}

var lens1 = [16]float64{
	1281256.011, 483056.8391, 182512.9565, 68979.22179,
	26071.75968, 9854.090990, 3724.532667, 1406.475763,
	531.4140101, 200.7861476, 75.86378287, 28.66389748,
	10.83018784, 4.092010473, 1.546099657, 0.584168630} /* latLng.c:326:25 */

func XgetNumCells(tls *libc.TLS, res int32, out uintptr) uint32 { /* latLng.c:338:9: */
	if res < 0 || res > DMAX_H3_RES {
		return E_RES_DOMAIN
	}
	*(*int64)(unsafe.Pointer(out)) = int64(2) + int64(120)*X_ipow(tls, int64(7), int64(res))
	return E_SUCCESS
}

// *
// Surface area in radians^2 of spherical triangle on unit sphere.
//
// For the math, see:
// https://en.wikipedia.org/wiki/Spherical_trigonometry#Area_and_spherical_excess
//
// @param   a  length of triangle side A in radians
// @param   b  length of triangle side B in radians
// @param   c  length of triangle side C in radians
//
// @return     area in radians^2 of triangle on unit sphere
func XtriangleEdgeLengthsToArea(tls *libc.TLS, a float64, b float64, c float64) float64 { /* latLng.c:358:8: */
	var s float64 = (a + b + c) * 0.5

	a = (s - a) * 0.5
	b = (s - b) * 0.5
	c = (s - c) * 0.5
	s = s * 0.5

	return float64(4) * libc.Xatan(tls, libc.Xsqrt(tls, libc.Xtan(tls, s)*libc.Xtan(tls, a)*libc.Xtan(tls, b)*libc.Xtan(tls, c)))
}

// *
// Compute area in radians^2 of a spherical triangle, given its vertices.
//
// @param   a  vertex lat/lng in radians
// @param   b  vertex lat/lng in radians
// @param   c  vertex lat/lng in radians
//
// @return     area of triangle on unit sphere, in radians^2
func XtriangleArea(tls *libc.TLS, a uintptr, b uintptr, c uintptr) float64 { /* latLng.c:378:8: */
	return XtriangleEdgeLengthsToArea(tls, XgreatCircleDistanceRads(tls, a, b),
		XgreatCircleDistanceRads(tls, b, c),
		XgreatCircleDistanceRads(tls, c, a))
}

// *
// Area of H3 cell in radians^2.
//
// The area is calculated by breaking the cell into spherical triangles and
// summing up their areas. Note that some H3 cells (hexagons and pentagons)
// are irregular, and have more than 6 or 5 sides.
//
// todo: optimize the computation by re-using the edges shared between triangles
//
// @param   cell  H3 cell
// @param    out  cell area in radians^2
// @return        E_SUCCESS on success, or an error code otherwise
func XcellAreaRads2(tls *libc.TLS, cell uint64, out uintptr) uint32 { /* latLng.c:397:9: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// var c TLatLng at bp, 16

	// var cb TCellBoundary at bp+16, 168

	var err uint32 = XcellToLatLng(tls, cell, bp)
	if err != 0 {
		return err
	}
	err = XcellToBoundary(tls, cell, bp+16)
	if func() int32 {
		if err != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+1066, int32(405), uintptr(unsafe.Pointer(&__func__13)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// Uncoverable because cellToLatLng will have returned an error already
		return err
	}

	var area float64 = 0.0
	{
		var i int32 = 0
		for ; i < (*TCellBoundary)(unsafe.Pointer(bp+16)).FnumVerts; i++ {
			var j int32 = (i + 1) % (*TCellBoundary)(unsafe.Pointer(bp+16)).FnumVerts
			area = area + XtriangleArea(tls, bp+16+8+uintptr(i)*16, bp+16+8+uintptr(j)*16, bp)
		}
	}

	*(*float64)(unsafe.Pointer(out)) = area
	return E_SUCCESS
}

var __func__13 = *(*[14]int8)(unsafe.Pointer(ts + 1089)) /* latLng.c:397:61 */

// *
// Area of H3 cell in kilometers^2.
func XcellAreaKm2(tls *libc.TLS, cell uint64, out uintptr) uint32 { /* latLng.c:423:9: */
	var err uint32 = XcellAreaRads2(tls, cell, out)
	if !(err != 0) {
		*(*float64)(unsafe.Pointer(out)) = *(*float64)(unsafe.Pointer(out)) * 6371.007180918475 * 6371.007180918475
	}
	return err
}

// *
// Area of H3 cell in meters^2.
func XcellAreaM2(tls *libc.TLS, cell uint64, out uintptr) uint32 { /* latLng.c:434:9: */
	var err uint32 = XcellAreaKm2(tls, cell, out)
	if !(err != 0) {
		*(*float64)(unsafe.Pointer(out)) = *(*float64)(unsafe.Pointer(out)) * float64(1000) * float64(1000)
	}
	return err
}

// *
// Length of a directed edge in radians.
//
// @param   edge  H3 directed edge
//
// @return        length in radians
func XedgeLengthRads(tls *libc.TLS, edge uint64, length uintptr) uint32 { /* latLng.c:449:9: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var cb TCellBoundary at bp, 168

	var err uint32 = XdirectedEdgeToBoundary(tls, edge, bp)
	if err != 0 {
		return err
	}

	*(*float64)(unsafe.Pointer(length)) = 0.0
	{
		var i int32 = 0
		for ; i < (*TCellBoundary)(unsafe.Pointer(bp)).FnumVerts-1; i++ {
			*(*float64)(unsafe.Pointer(length)) += XgreatCircleDistanceRads(tls, bp+8+uintptr(i)*16, bp+8+uintptr(i+1)*16)
		}
	}

	return E_SUCCESS
}

// *
// Length of a directed edge in kilometers.
func XedgeLengthKm(tls *libc.TLS, edge uint64, length uintptr) uint32 { /* latLng.c:469:9: */
	var err uint32 = XedgeLengthRads(tls, edge, length)
	*(*float64)(unsafe.Pointer(length)) = *(*float64)(unsafe.Pointer(length)) * 6371.007180918475
	return err
}

// *
// Length of a directed edge in meters.
func XedgeLengthM(tls *libc.TLS, edge uint64, length uintptr) uint32 { /* latLng.c:478:9: */
	var err uint32 = XedgeLengthKm(tls, edge, length)
	*(*float64)(unsafe.Pointer(length)) = *(*float64)(unsafe.Pointer(length)) * float64(1000)
	return err
}

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// *
// Add a linked polygon to the current polygon
// @param  polygon Polygon to add link to
// @return         Pointer to new polygon
func XaddNewLinkedPolygon(tls *libc.TLS, polygon uintptr) uintptr { /* linkedGeo.c:34:18: */
	if (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext == uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1103, ts+1125, int32(35), uintptr(unsafe.Pointer(&__func__14)))
	}
	var next uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(TLinkedGeoPolygon{})))
	if next != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1151, ts+1125, int32(37), uintptr(unsafe.Pointer(&__func__14)))
	}
	(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext = next
	return next
}

var __func__14 = *(*[20]int8)(unsafe.Pointer(ts + 1164)) /* linkedGeo.c:34:66 */

// *
// Add a new linked loop to the current polygon
// @param  polygon Polygon to add loop to
// @return         Pointer to loop
func XaddNewLinkedLoop(tls *libc.TLS, polygon uintptr) uintptr { /* linkedGeo.c:47:15: */
	var loop uintptr = libc.Xcalloc(tls, uint64(1), uint64(unsafe.Sizeof(TLinkedGeoLoop{})))
	if loop != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1184, ts+1125, int32(49), uintptr(unsafe.Pointer(&__func__15)))
	}
	return XaddLinkedLoop(tls, polygon, loop)
}

var __func__15 = *(*[17]int8)(unsafe.Pointer(ts + 1197)) /* linkedGeo.c:47:60 */

// *
// Add an existing linked loop to the current polygon
// @param  polygon Polygon to add loop to
// @return         Pointer to loop
func XaddLinkedLoop(tls *libc.TLS, polygon uintptr, loop uintptr) uintptr { /* linkedGeo.c:58:15: */
	var last uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Flast
	if last == uintptr(0) {
		if (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst == uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+1214, ts+1125, int32(61), uintptr(unsafe.Pointer(&__func__16)))
		}
		(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst = loop
	} else {
		(*TLinkedGeoLoop)(unsafe.Pointer(last)).Fnext = loop
	}
	(*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Flast = loop
	return loop
}

var __func__16 = *(*[14]int8)(unsafe.Pointer(ts + 1237)) /* linkedGeo.c:58:78 */

// *
// Add a new linked coordinate to the current loop
// @param  loop   Loop to add coordinate to
// @param  vertex Coordinate to add
// @return        Pointer to the coordinate
func XaddLinkedCoord(tls *libc.TLS, loop uintptr, vertex uintptr) uintptr { /* linkedGeo.c:76:14: */
	var coord uintptr = libc.Xmalloc(tls, uint64(unsafe.Sizeof(TLinkedLatLng{})))
	if coord != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1251, ts+1125, int32(78), uintptr(unsafe.Pointer(&__func__17)))
	}
	*(*TLinkedLatLng)(unsafe.Pointer(coord)) = TLinkedLatLng{Fvertex: *(*TLatLng)(unsafe.Pointer(vertex))}
	var last uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Flast
	if last == uintptr(0) {
		if (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst == uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+1265, ts+1125, int32(82), uintptr(unsafe.Pointer(&__func__17)))
		}
		(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst = coord
	} else {
		(*TLinkedLatLng)(unsafe.Pointer(last)).Fnext = coord
	}
	(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Flast = coord
	return coord
}

var __func__17 = *(*[15]int8)(unsafe.Pointer(ts + 1285)) /* linkedGeo.c:76:73 */

// *
// Free all allocated memory for a linked geo loop. The caller is
// responsible for freeing memory allocated to input loop struct.
// @param loop Loop to free
func XdestroyLinkedGeoLoop(tls *libc.TLS, loop uintptr) { /* linkedGeo.c:96:6: */
	var nextCoord uintptr
	{
		var currentCoord uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		for ; currentCoord != uintptr(0); currentCoord = nextCoord {
			nextCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
			libc.Xfree(tls, currentCoord)
		}
	}
}

// *
// Free all allocated memory for a linked geo structure. The caller is
// responsible for freeing memory allocated to input polygon struct.
// @param polygon Pointer to the first polygon in the structure
func XdestroyLinkedMultiPolygon(tls *libc.TLS, polygon uintptr) { /* linkedGeo.c:110:6: */
	// flag to skip the input polygon
	var skip uint8 = uint8(Dtrue)
	var nextPolygon uintptr
	var nextLoop uintptr
	{
		var currentPolygon uintptr = polygon
		for ; currentPolygon != uintptr(0); currentPolygon = nextPolygon {
			{
				var currentLoop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(currentPolygon)).Ffirst
				for ; currentLoop != uintptr(0); currentLoop = nextLoop {
					XdestroyLinkedGeoLoop(tls, currentLoop)
					nextLoop = (*TLinkedGeoLoop)(unsafe.Pointer(currentLoop)).Fnext
					libc.Xfree(tls, currentLoop)
				}
			}
			nextPolygon = (*TLinkedGeoPolygon)(unsafe.Pointer(currentPolygon)).Fnext
			if skip != 0 {
				// do not free the input polygon
				skip = uint8(Dfalse)
			} else {
				libc.Xfree(tls, currentPolygon)
			}
		}
	}
}

// *
// Count the number of polygons in a linked list
// @param  polygon Starting polygon
// @return         Count
func XcountLinkedPolygons(tls *libc.TLS, polygon uintptr) int32 { /* linkedGeo.c:138:5: */
	var count int32 = 0
	for polygon != uintptr(0) {
		count++
		polygon = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext
	}
	return count
}

// *
// Count the number of linked loops in a polygon
// @param  polygon Polygon to count loops for
// @return         Count
func XcountLinkedLoops(tls *libc.TLS, polygon uintptr) int32 { /* linkedGeo.c:152:5: */
	var loop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst
	var count int32 = 0
	for loop != uintptr(0) {
		count++
		loop = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext
	}
	return count
}

// *
// Count the number of coordinates in a loop
// @param  loop Loop to count coordinates for
// @return      Count
func XcountLinkedCoords(tls *libc.TLS, loop uintptr) int32 { /* linkedGeo.c:167:5: */
	var coord uintptr = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
	var count int32 = 0
	for coord != uintptr(0) {
		count++
		coord = (*TLinkedLatLng)(unsafe.Pointer(coord)).Fnext
	}
	return count
}

// *
// Count the number of polygons containing a given loop.
// @param  loop         Loop to count containers for
// @param  polygons     Polygons to test
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons in the test array
// @return              Number of polygons containing the loop
func countContainers(tls *libc.TLS, loop uintptr, polygons uintptr, bboxes uintptr, polygonCount int32) int32 { /* linkedGeo.c:185:12: */
	var containerCount int32 = 0
	{
		var i int32 = 0
		for ; i < polygonCount; i++ {
			if loop != (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst && XpointInsideLinkedGeoLoop(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst, *(*uintptr)(unsafe.Pointer(bboxes + uintptr(i)*8)),
				(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst) != 0 {
				containerCount++
			}
		}
	}
	return containerCount
}

// *
// Given a list of nested containers, find the one most deeply nested.
// @param  polygons     Polygon containers to check
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons in the list
// @return              Deepest container, or null if list is empty
func findDeepestContainer(tls *libc.TLS, polygons uintptr, bboxes uintptr, polygonCount int32) uintptr { /* linkedGeo.c:206:31: */
	// Set the initial return value to the first candidate
	var parent uintptr
	if polygonCount > 0 {
		parent = *(*uintptr)(unsafe.Pointer(polygons))
	} else {
		parent = uintptr(0)
	}

	// If we have multiple polygons, they must be nested inside each other.
	// Find the innermost polygon by taking the one with the most containers
	// in the list.
	if polygonCount > 1 {
		var max int32 = -1
		{
			var i int32 = 0
			for ; i < polygonCount; i++ {
				var count int32 = countContainers(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8)))).Ffirst, polygons, bboxes,
					polygonCount)
				if count > max {
					parent = *(*uintptr)(unsafe.Pointer(polygons + uintptr(i)*8))
					max = count
				}
			}
		}
	}

	return parent
}

// *
// Find the polygon to which a given hole should be allocated. Note that this
// function will return null if no parent is found.
// @param  loop         Inner loop describing a hole
// @param  polygon      Head of a linked list of polygons to check
// @param  bboxes       Bounding boxes for polygons, used in point-in-poly check
// @param  polygonCount Number of polygons to check
// @return              Pointer to parent polygon, or null if not found
func findPolygonForHole(tls *libc.TLS, loop uintptr, polygon uintptr, bboxes uintptr, polygonCount int32) uintptr { /* linkedGeo.c:239:31: */
	// Early exit with no polygons
	if polygonCount == 0 {
		return uintptr(0)
	}
	// Initialize arrays for candidate loops and their bounding boxes
	var candidates uintptr = libc.Xmalloc(tls, uint64(polygonCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if candidates != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1300, ts+1125, int32(249), uintptr(unsafe.Pointer(&__func__18)))
	}
	var candidateBBoxes uintptr = libc.Xmalloc(tls, uint64(polygonCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if candidateBBoxes != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1319, ts+1125, int32(252), uintptr(unsafe.Pointer(&__func__18)))
	}

	// Find all polygons that contain the loop
	var candidateCount int32 = 0
	var index int32 = 0
	for polygon != 0 {
		// We are guaranteed not to overlap, so just test the first point
		if XpointInsideLinkedGeoLoop(tls, (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Ffirst, bboxes+uintptr(index)*32,
			(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst) != 0 {
			*(*uintptr)(unsafe.Pointer(candidates + uintptr(candidateCount)*8)) = polygon
			*(*uintptr)(unsafe.Pointer(candidateBBoxes + uintptr(candidateCount)*8)) = bboxes + uintptr(index)*32
			candidateCount++
		}
		polygon = (*TLinkedGeoPolygon)(unsafe.Pointer(polygon)).Fnext
		index++
	}

	// The most deeply nested container is the immediate parent
	var parent uintptr = findDeepestContainer(tls, candidates, candidateBBoxes, candidateCount)

	// Free allocated memory
	libc.Xfree(tls, candidates)
	libc.Xfree(tls, candidateBBoxes)

	return parent
}

var __func__18 = *(*[19]int8)(unsafe.Pointer(ts + 1343)) /* linkedGeo.c:241:49 */

// *
// Normalize a LinkedGeoPolygon in-place into a structure following GeoJSON
// MultiPolygon rules: Each polygon must have exactly one outer loop, which
// must be first in the list, followed by any holes. Holes in this algorithm
// are identified by winding order (holes are clockwise), which is guaranteed
// by the h3SetToVertexGraph algorithm.
//
// Input to this function is assumed to be a single polygon including all
// loops to normalize. It's assumed that a valid arrangement is possible.
//
// @param root Root polygon including all loops
// @return     0 on success, or an error code > 0 for invalid input
func XnormalizeMultiPolygon(tls *libc.TLS, root uintptr) uint32 { /* linkedGeo.c:293:9: */
	// We assume that the input is a single polygon with loops;
	// if it has multiple polygons, don't touch it
	if (*TLinkedGeoPolygon)(unsafe.Pointer(root)).Fnext != 0 {
		return E_FAILED
	}

	// Count loops, exiting early if there's only one
	var loopCount int32 = XcountLinkedLoops(tls, root)
	if loopCount <= 1 {
		return E_SUCCESS
	}

	var resultCode uint32 = E_SUCCESS
	var polygon uintptr = uintptr(0)
	var next uintptr
	var innerCount int32 = 0
	var outerCount int32 = 0

	// Create an array to hold all of the inner loops. Note that
	// this array will never be full, as there will always be fewer
	// inner loops than outer loops.
	var innerLoops uintptr = libc.Xmalloc(tls, uint64(loopCount)*uint64(unsafe.Sizeof(uintptr(0))))
	if innerLoops != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1362, ts+1125, int32(317), uintptr(unsafe.Pointer(&__func__19)))
	}

	// Create an array to hold the bounding boxes for the outer loops
	var bboxes uintptr = libc.Xmalloc(tls, uint64(loopCount)*uint64(unsafe.Sizeof(TBBox{})))
	if bboxes != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1381, ts+1125, int32(321), uintptr(unsafe.Pointer(&__func__19)))
	}

	// Get the first loop and unlink it from root
	var loop uintptr = (*TLinkedGeoPolygon)(unsafe.Pointer(root)).Ffirst
	*(*TLinkedGeoPolygon)(unsafe.Pointer(root)) = TLinkedGeoPolygon{}

	// Iterate over all loops, moving inner loops into an array and
	// assigning outer loops to new polygons
	for loop != 0 {
		if XisClockwiseLinkedGeoLoop(tls, loop) != 0 {
			*(*uintptr)(unsafe.Pointer(innerLoops + uintptr(innerCount)*8)) = loop
			innerCount++
		} else {
			if polygon == uintptr(0) {
				polygon = root
			} else {
				polygon = XaddNewLinkedPolygon(tls, polygon)
			}
			XaddLinkedLoop(tls, polygon, loop)
			XbboxFromLinkedGeoLoop(tls, loop, bboxes+uintptr(outerCount)*32)
			outerCount++
		}
		// get the next loop and unlink it from this one
		next = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext
		(*TLinkedGeoLoop)(unsafe.Pointer(loop)).Fnext = uintptr(0)
		loop = next
	}

	// Find polygon for each inner loop and assign the hole to it
	{
		var i int32 = 0
		for ; i < innerCount; i++ {
			polygon = findPolygonForHole(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)), root,
				bboxes, outerCount)
			if polygon != 0 {
				XaddLinkedLoop(tls, polygon, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
			} else {
				// If we can't find a polygon (possible with invalid input), then
				// we need to release the memory for the hole, because the loop has
				// been unlinked from the root and the caller will no longer have
				// a way to destroy it with destroyLinkedMultiPolygon.
				XdestroyLinkedGeoLoop(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
				libc.Xfree(tls, *(*uintptr)(unsafe.Pointer(innerLoops + uintptr(i)*8)))
				resultCode = E_FAILED
			}
		}
	}

	// Free allocated memory
	libc.Xfree(tls, innerLoops)
	libc.Xfree(tls, bboxes)

	return resultCode
}

var __func__19 = *(*[22]int8)(unsafe.Pointer(ts + 1396)) /* linkedGeo.c:293:55 */

//* Macro: Normalize longitude, dealing with transmeridian arcs

// *
// pointInside is the core loop of the point-in-poly algorithm
// @param loop  The loop to check
// @param bbox  The bbox for the loop being tested
// @param coord The coordinate to check
// @return      Whether the point is contained
func XpointInsideLinkedGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr, coord uintptr) uint8 { /* polygonAlgos.h:67:6: */
	// fail fast if we're outside the bounding box
	if !(XbboxContains(tls, bbox, coord) != 0) {
		return uint8(Dfalse)
	}
	var isTransmeridian uint8 = XbboxIsTransmeridian(tls, bbox)
	var contains uint8 = uint8(Dfalse)

	var lat float64 = (*TLatLng)(unsafe.Pointer(coord)).Flat
	var lng float64 = func() float64 {
		if isTransmeridian != 0 && (*TLatLng)(unsafe.Pointer(coord)).Flng < float64(0) {
			return (*TLatLng)(unsafe.Pointer(coord)).Flng + 6.28318530717958647692528676655900576839433
		}
		return (*TLatLng)(unsafe.Pointer(coord)).Flng
	}()
	var a TLatLng
	var b TLatLng

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)

	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		a = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		b = (*TLinkedLatLng)(unsafe.Pointer(nextCoord)).Fvertex

		// Ray casting algo requires the second point to always be higher
		// than the first, so swap if needed
		if a.Flat > b.Flat {
			var tmp = a
			a = b
			b = tmp
		}

		// If the latitude matches exactly, we'll hit an edge case where
		// the ray passes through the vertex twice on successive segment
		// checks. To avoid this, adjust the latiude northward if needed.
		//
		// NOTE: This currently means that a point at the north pole cannot
		// be contained in any polygon. This is acceptable in current usage,
		// because the point we test in this function at present is always
		// a cell center or vertex, and no cell has a center or vertex on the
		// north pole. If we need to expand this algo to more generic uses we
		// might need to handle this edge case.
		if lat == a.Flat || lat == b.Flat {
			lat = lat + 2.22044604925031308084726333618164062e-16
		}

		// If we're totally above or below the latitude ranges, the test
		// ray cannot intersect the line segment, so let's move on
		if lat < a.Flat || lat > b.Flat {
			continue
		}

		var aLng float64 = func() float64 {
			if isTransmeridian != 0 && a.Flng < float64(0) {
				return a.Flng + 6.28318530717958647692528676655900576839433
			}
			return a.Flng
		}()
		var bLng float64 = func() float64 {
			if isTransmeridian != 0 && b.Flng < float64(0) {
				return b.Flng + 6.28318530717958647692528676655900576839433
			}
			return b.Flng
		}()

		// Rays are cast in the longitudinal direction, in case a point
		// exactly matches, to decide tiebreakers, bias westerly
		if aLng == lng || bLng == lng {
			lng = lng - 2.22044604925031308084726333618164062e-16
		}

		// For the latitude of the point, compute the longitude of the
		// point that lies on the line segment defined by a and b
		// This is done by computing the percent above a the lat is,
		// and traversing the same percent in the longitudinal direction
		// of a to b
		var ratio float64 = (lat - a.Flat) / (b.Flat - a.Flat)
		var testLng float64 = func() float64 {
			if isTransmeridian != 0 && aLng+(bLng-aLng)*ratio < float64(0) {
				return aLng + (bLng-aLng)*ratio + 6.28318530717958647692528676655900576839433
			}
			return aLng + (bLng-aLng)*ratio
		}()

		// Intersection of the ray
		if testLng > lng {
			contains = libc.BoolUint8(!(contains != 0))
		}
	}

	return contains
}

// *
// Create a bounding box from a simple polygon loop.
// Known limitations:
//   - Does not support polygons with two adjacent points > 180 degrees of
//     longitude apart. These will be interpreted as crossing the antimeridian.
//   - Does not currently support polygons containing a pole.
//
// @param loop     Loop of coordinates
// @param bbox     Output bbox
func XbboxFromLinkedGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr) { /* polygonAlgos.h:151:6: */
	// Early exit if there are no vertices
	if (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst == uintptr(0) {
		*(*TBBox)(unsafe.Pointer(bbox)) = TBBox{}
		return
	}

	(*TBBox)(unsafe.Pointer(bbox)).Fsouth = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fwest = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fnorth = -1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Feast = -1.79769313486231570814527423731704357e+308
	var minPosLng float64 = 1.79769313486231570814527423731704357e+308
	var maxNegLng float64 = -1.79769313486231570814527423731704357e+308
	var isTransmeridian uint8 = uint8(Dfalse)
	var lat float64
	var lng float64
	var coord TLatLng
	var next TLatLng

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)

	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		coord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		next = (*TLinkedLatLng)(unsafe.Pointer(nextCoord)).Fvertex

		lat = coord.Flat
		lng = coord.Flng
		if lat < (*TBBox)(unsafe.Pointer(bbox)).Fsouth {
			(*TBBox)(unsafe.Pointer(bbox)).Fsouth = lat
		}
		if lng < (*TBBox)(unsafe.Pointer(bbox)).Fwest {
			(*TBBox)(unsafe.Pointer(bbox)).Fwest = lng
		}
		if lat > (*TBBox)(unsafe.Pointer(bbox)).Fnorth {
			(*TBBox)(unsafe.Pointer(bbox)).Fnorth = lat
		}
		if lng > (*TBBox)(unsafe.Pointer(bbox)).Feast {
			(*TBBox)(unsafe.Pointer(bbox)).Feast = lng
		}
		// Save the min positive and max negative longitude for
		// use in the transmeridian case
		if lng > float64(0) && lng < minPosLng {
			minPosLng = lng
		}
		if lng < float64(0) && lng > maxNegLng {
			maxNegLng = lng
		}
		// check for arcs > 180 degrees longitude, flagging as transmeridian
		if libc.Xfabs(tls, lng-next.Flng) > 3.14159265358979323846 {
			isTransmeridian = uint8(Dtrue)
		}
	}
	// Swap east and west if transmeridian
	if isTransmeridian != 0 {
		(*TBBox)(unsafe.Pointer(bbox)).Feast = maxNegLng
		(*TBBox)(unsafe.Pointer(bbox)).Fwest = minPosLng
	}
}

// *
// Whether the winding order of a given loop is clockwise, with normalization
// for loops crossing the antimeridian.
// @param loop              The loop to check
// @param isTransmeridian   Whether the loop crosses the antimeridian
// @return                  Whether the loop is clockwise
func isClockwiseNormalizedLinkedGeoLoop(tls *libc.TLS, loop uintptr, isTransmeridian uint8) uint8 { /* polygonAlgos.h:205:13: */
	var sum float64 = float64(0)
	var a TLatLng
	var b TLatLng

	var currentCoord uintptr = uintptr(0)
	var nextCoord uintptr = uintptr(0)
	for 1 != 0 {
		if currentCoord == uintptr(0) {
			currentCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			currentCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		if currentCoord == uintptr(0) {
			break
		}
		a = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fvertex
		if (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext == uintptr(0) {
			nextCoord = (*TLinkedGeoLoop)(unsafe.Pointer(loop)).Ffirst
		} else {
			nextCoord = (*TLinkedLatLng)(unsafe.Pointer(currentCoord)).Fnext
		}
		b = (*TLinkedLatLng)(unsafe.Pointer(nextCoord)).Fvertex
		// If we identify a transmeridian arc (> 180 degrees longitude),
		// start over with the transmeridian flag set
		if !(isTransmeridian != 0) && libc.Xfabs(tls, a.Flng-b.Flng) > 3.14159265358979323846 {
			return isClockwiseNormalizedLinkedGeoLoop(tls, loop, uint8(Dtrue))
		}
		sum = sum + (func() float64 {
			if isTransmeridian != 0 && b.Flng < float64(0) {
				return b.Flng + 6.28318530717958647692528676655900576839433
			}
			return b.Flng
		}()-func() float64 {
			if isTransmeridian != 0 && a.Flng < float64(0) {
				return a.Flng + 6.28318530717958647692528676655900576839433
			}
			return a.Flng
		}())*(b.Flat+a.Flat)
	}

	return uint8(libc.Bool32(sum > float64(0)))
}

// *
// Whether the winding order of a given loop is clockwise. In GeoJSON,
// clockwise loops are always inner loops (holes).
// @param loop  The loop to check
// @return      Whether the loop is clockwise
func XisClockwiseLinkedGeoLoop(tls *libc.TLS, loop uintptr) uint8 { /* polygonAlgos.h:233:6: */
	return isClockwiseNormalizedLinkedGeoLoop(tls, loop, uint8(Dfalse))
}

// *
// Origin leading digit -> index leading digit -> rotations 60 cw
// Either being 1 (K axis) is invalid.
// No good default at 0.
var XPENTAGON_ROTATIONS = [7][7]int32{
	{0, -1, 0, 0, 0, 0, 0},       // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, -1, 0, 0, 0, 1, 0},       // 2
	{0, -1, 0, 0, 1, 1, 0},       // 3
	{0, -1, 0, 5, 0, 0, 0},       // 4
	{0, -1, 5, 5, 0, 0, 0},       // 5
	{0, -1, 0, 0, 0, 0, 0},       // 6
} /* localij.c:39:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when
// the origin is on a pentagon (regardless of the base cell of the index.)
var XPENTAGON_ROTATIONS_REVERSE = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 0, 0, 0, 0, 0},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 5, 0, 0, 0, 0, 0},        // 4
	{0, 5, 0, 5, 0, 0, 0},        // 5
	{0, 0, 0, 0, 0, 0, 0},        // 6
} /* localij.c:53:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when the index is
// on a pentagon and the origin is not.
var XPENTAGON_ROTATIONS_REVERSE_NONPOLAR = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 0, 0, 0, 0, 0},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 5, 0, 0, 0, 0, 0},        // 4
	{0, 1, 0, 5, 1, 1, 0},        // 5
	{0, 0, 0, 0, 0, 0, 0},        // 6
} /* localij.c:67:11 */
// *
// Reverse base cell direction -> leading index digit -> rotations 60 ccw.
// For reversing the rotation introduced in PENTAGON_ROTATIONS when the index is
// on a polar pentagon and the origin is not.
var XPENTAGON_ROTATIONS_REVERSE_POLAR = [7][7]int32{
	{0, 0, 0, 0, 0, 0, 0},        // 0
	{-1, -1, -1, -1, -1, -1, -1}, // 1
	{0, 1, 1, 1, 1, 1, 1},        // 2
	{0, 1, 0, 0, 0, 1, 0},        // 3
	{0, 1, 0, 0, 1, 1, 1},        // 4
	{0, 1, 0, 5, 1, 1, 0},        // 5
	{0, 1, 1, 0, 1, 1, 1},        // 6
} /* localij.c:81:11 */

// *
// Prohibited directions when unfolding a pentagon.
//
// Indexes by two directions, both relative to the pentagon base cell. The first
// is the direction of the origin index and the second is the direction of the
// index to unfold. Direction refers to the direction from base cell to base
// cell if the indexes are on different base cells, or the leading digit if
// within the pentagon base cell.
//
// This previously included a Class II/Class III check but these were removed
// due to failure cases. It's possible this could be restricted to a narrower
// set of a failure cases. Currently, the logic is any unfolding across more
// than one icosahedron face is not permitted.
var XFAILED_DIRECTIONS = [7][7]uint8{
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)}, // 0
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)}, // 1
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dtrue), uint8(Dfalse)},   // 2
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dtrue)},   // 3
	{uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dtrue), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse)},   // 4
	{uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue)},   // 5
	{uint8(Dfalse), uint8(Dfalse), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse), uint8(Dtrue), uint8(Dfalse)},   // 6
} /* localij.c:105:12 */

// *
// Produces ijk+ coordinates for an index anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Coordinates are only comparable if they come from the same
// origin index.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// @param origin An anchoring index for the ijk+ coordinate system.
// @param index Index to find the coordinates of
// @param out ijk+ coordinates of the index will be placed here on success
// @return 0 on success, or another value on failure.
func XcellToLocalIjk(tls *libc.TLS, origin uint64, h3 uint64, out uintptr) uint32 { /* localij.c:132:9: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var res int32 = int32(origin & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	if res != int32(h3&(uint64(15)<<DH3_RES_OFFSET)>>DH3_RES_OFFSET) {
		return E_RES_MISMATCH
	}

	var originBaseCell int32 = int32(origin & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	var baseCell int32 = int32(h3 & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)

	if func() int32 {
		if originBaseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+1418, int32(142), uintptr(unsafe.Pointer(&__func__20)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || originBaseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return E_CELL_INVALID
	}
	if func() int32 {
		if baseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+1418, int32(146), uintptr(unsafe.Pointer(&__func__20)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || baseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return E_CELL_INVALID
	}

	// Direction from origin base cell to index base cell
	var dir uint32 = CENTER_DIGIT
	var revDir uint32 = CENTER_DIGIT
	if originBaseCell != baseCell {
		dir = X_getBaseCellDirection(tls, originBaseCell, baseCell)
		if dir == INVALID_DIGIT {
			// Base cells are not neighbors, can't unfold.
			return E_FAILED
		}
		revDir = X_getBaseCellDirection(tls, baseCell, originBaseCell)
		if revDir != INVALID_DIGIT {
		} else {
			libc.X__assert_fail(tls, ts+1442, ts+1418, int32(161), uintptr(unsafe.Pointer(&__func__20)))
		}
	}

	var originOnPent int32 = X_isBaseCellPentagon(tls, originBaseCell)
	var indexOnPent int32 = X_isBaseCellPentagon(tls, baseCell)

	*(*TFaceIJK)(unsafe.Pointer(bp /* indexFijk */)) = TFaceIJK{}
	if dir != CENTER_DIGIT {
		// Rotate index into the orientation of the origin base cell.
		// cw because we are undoing the rotation into that base cell.
		var baseCellRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(originBaseCell)*28 + uintptr(dir)*4))
		if indexOnPent != 0 {
			{
				var i int32 = 0
				for ; i < baseCellRotations; i++ {
					h3 = X_h3RotatePent60cw(tls, h3)

					revDir = X_rotate60cw(tls, revDir)
					if revDir == K_AXES_DIGIT {
						revDir = X_rotate60cw(tls, revDir)
					}
				}
			}
		} else {
			{
				var i int32 = 0
				for ; i < baseCellRotations; i++ {
					h3 = X_h3Rotate60cw(tls, h3)

					revDir = X_rotate60cw(tls, revDir)
				}
			}
		}
	}
	// Face is unused. This produces coordinates in base cell coordinate space.
	X_h3ToFaceIjkWithInitializedFijk(tls, h3, bp)

	if dir != CENTER_DIGIT {
		if baseCell != originBaseCell {
		} else {
			libc.X__assert_fail(tls, ts+1466, ts+1418, int32(191), uintptr(unsafe.Pointer(&__func__20)))
		}
		if !(originOnPent != 0 && indexOnPent != 0) {
		} else {
			libc.X__assert_fail(tls, ts+1493, ts+1418, int32(192), uintptr(unsafe.Pointer(&__func__20)))
		}

		var pentagonRotations int32 = 0
		var directionRotations int32 = 0

		if originOnPent != 0 {
			var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))

			if originLeadingDigit == INVALID_DIGIT {
				return E_CELL_INVALID
			}
			if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(originLeadingDigit)*7 + uintptr(dir))) != 0 {
				// TODO: We may be unfolding the pentagon incorrectly in this
				// case; return an error code until this is guaranteed to be
				// correct.
				return E_FAILED
			}

			directionRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(originLeadingDigit)*28 + uintptr(dir)*4))
			pentagonRotations = directionRotations
		} else if indexOnPent != 0 {
			var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, h3))

			if indexLeadingDigit == INVALID_DIGIT {
				return E_CELL_INVALID
			}
			if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(indexLeadingDigit)*7 + uintptr(revDir))) != 0 {
				// TODO: We may be unfolding the pentagon incorrectly in this
				// case; return an error code until this is guaranteed to be
				// correct.
				return E_FAILED
			}

			pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
		}

		if pentagonRotations < 0 || directionRotations < 0 {
			// This occurs when an invalid K axis digit is present
			return E_CELL_INVALID
		}

		{
			var i int32 = 0
			for ; i < pentagonRotations; i++ {
				X_ijkRotate60cw(tls, bp+4)
			}
		}

		*(*TCoordIJK)(unsafe.Pointer(bp + 16 /* offset */)) = TCoordIJK{}
		X_neighbor(tls, bp+16, dir)
		// Scale offset based on resolution
		{
			var r int32 = res - 1
			for ; r >= 0; r-- {
				if XisResolutionClassIII(tls, r+1) != 0 {
					// rotate ccw
					X_downAp7(tls, bp+16)
				} else {
					// rotate cw
					X_downAp7r(tls, bp+16)
				}
			}
		}

		{
			var i1 int32 = 0
			for ; i1 < directionRotations; i1++ {
				X_ijkRotate60cw(tls, bp+16)
			}
		}

		// Perform necessary translation
		X_ijkAdd(tls, bp+4, bp+16, bp+4)
		X_ijkNormalize(tls, bp+4)
	} else if originOnPent != 0 && indexOnPent != 0 {
		// If the origin and index are on pentagon, and we checked that the base
		// cells are the same or neighboring, then they must be the same base
		// cell.
		if baseCell == originBaseCell {
		} else {
			libc.X__assert_fail(tls, ts+1524, ts+1418, int32(261), uintptr(unsafe.Pointer(&__func__20)))
		}

		var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))
		var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, h3))

		if originLeadingDigit == INVALID_DIGIT || indexLeadingDigit == INVALID_DIGIT {
			return E_CELL_INVALID
		}
		if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&XFAILED_DIRECTIONS)) + uintptr(originLeadingDigit)*7 + uintptr(indexLeadingDigit))) != 0 {
			// TODO: We may be unfolding the pentagon incorrectly in this case;
			// return an error code until this is guaranteed to be correct.
			return E_FAILED
		}

		var withinPentagonRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS)) + uintptr(originLeadingDigit)*28 + uintptr(indexLeadingDigit)*4))

		{
			var i int32 = 0
			for ; i < withinPentagonRotations; i++ {
				X_ijkRotate60cw(tls, bp+4)
			}
		}
	}

	*(*TCoordIJK)(unsafe.Pointer(out)) = (*TFaceIJK)(unsafe.Pointer(bp /* &indexFijk */)).Fcoord
	return E_SUCCESS
}

var __func__20 = *(*[15]int8)(unsafe.Pointer(ts + 1551)) /* localij.c:132:67 */

// *
// Produces an index for ijk+ coordinates anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Failure may occur if the coordinates are too far away from the origin
// or if the index is on the other side of a pentagon.
//
// @param origin An anchoring index for the ijk+ coordinate system.
// @param ijk IJK+ Coordinates to find the index of
// @param out The index will be placed here on success
// @return 0 on success, or another value on failure.
func XlocalIjkToCell(tls *libc.TLS, origin uint64, ijk uintptr, out uintptr) uint32 { /* localij.c:302:9: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var res int32 = int32(origin & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	var originBaseCell int32 = int32(origin & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
	if func() int32 {
		if originBaseCell < 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+1418, int32(305), uintptr(unsafe.Pointer(&__func__21)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 || originBaseCell >= DNUM_BASE_CELLS {
		// Base cells less than zero can not be represented in an index
		return E_CELL_INVALID
	}
	var originOnPent int32 = X_isBaseCellPentagon(tls, originBaseCell)

	// This logic is very similar to faceIjkToH3
	// initialize the index
	*(*uint64)(unsafe.Pointer(out)) = 35184372088831
	*(*uint64)(unsafe.Pointer(out)) = *(*uint64)(unsafe.Pointer(out))&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	*(*uint64)(unsafe.Pointer(out)) = *(*uint64)(unsafe.Pointer(out))&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | uint64(res)<<DH3_RES_OFFSET

	// check for res 0/base cell
	if res == 0 {
		var dir uint32 = X_unitIjkToDigit(tls, ijk)
		if dir == INVALID_DIGIT {
			// out of range input - not a unit vector or zero vector
			return E_FAILED
		}

		var newBaseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
		if newBaseCell == DINVALID_BASE_CELL {
			// Moving in an invalid direction off a pentagon.
			return E_FAILED
		}
		*(*uint64)(unsafe.Pointer(out)) = *(*uint64)(unsafe.Pointer(out))&libc.CplUint64(uint64(uint64(127))<<DH3_BC_OFFSET) | uint64(newBaseCell)<<DH3_BC_OFFSET
		return E_SUCCESS
	}

	// we need to find the correct base cell offset (if any) for this H3 index;
	// start with the passed in base cell and resolution res ijk coordinates
	// in that base cell's coordinate system
	*(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */)) = *(*TCoordIJK)(unsafe.Pointer(ijk))

	// build the H3Index from finest res up
	// adjust r for the fact that the res 0 base cell offsets the indexing
	// digits
	{
		var r int32 = res - 1
		for ; r >= 0; r-- {
			*(*TCoordIJK)(unsafe.Pointer(bp + 24 /* lastIJK */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
			// var lastCenter TCoordIJK at bp+12, 12

			if XisResolutionClassIII(tls, r+1) != 0 {
				// rotate ccw
				var upAp7Error uint32 = X_upAp7Checked(tls, bp)
				if upAp7Error != 0 {
					return upAp7Error
				}
				*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
				X_downAp7(tls, bp+12)
			} else {
				// rotate cw
				var upAp7rError uint32 = X_upAp7rChecked(tls, bp)
				if upAp7rError != 0 {
					return upAp7rError
				}
				*(*TCoordIJK)(unsafe.Pointer(bp + 12 /* lastCenter */)) = *(*TCoordIJK)(unsafe.Pointer(bp /* ijkCopy */))
				X_downAp7r(tls, bp+12)
			}
			// var diff TCoordIJK at bp+36, 12

			X_ijkSub(tls, bp+24, bp+12, bp+36)
			X_ijkNormalize(tls, bp+36)

			*(*uint64)(unsafe.Pointer(out)) = *(*uint64)(unsafe.Pointer(out)) & ^(uint64(uint64(7))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)) | uint64(X_unitIjkToDigit(tls, bp+36))<<((DMAX_H3_RES-(r+1))*DH3_PER_DIGIT_OFFSET)
		}
	}

	// ijkCopy should now hold the IJK of the base cell in the
	// coordinate system of the current base cell

	if (*TCoordIJK)(unsafe.Pointer(bp)).Fi > 1 || (*TCoordIJK)(unsafe.Pointer(bp)).Fj > 1 || (*TCoordIJK)(unsafe.Pointer(bp)).Fk > 1 {
		// out of range input
		return E_FAILED
	}

	// lookup the correct base cell
	var dir uint32 = X_unitIjkToDigit(tls, bp)
	var baseCell int32 = X_getBaseCellNeighbor(tls, originBaseCell, dir)
	// If baseCell is invalid, it must be because the origin base cell is a
	// pentagon, and because pentagon base cells do not border each other,
	// baseCell must not be a pentagon.
	var indexOnPent int32 = func() int32 {
		if baseCell == DINVALID_BASE_CELL {
			return 0
		}
		return X_isBaseCellPentagon(tls, baseCell)
	}()

	if dir != CENTER_DIGIT {
		// If the index is in a warped direction, we need to unwarp the base
		// cell direction. There may be further need to rotate the index digits.
		var pentagonRotations int32 = 0
		if originOnPent != 0 {
			var originLeadingDigit uint32 = X_h3LeadingNonZeroDigit(tls, origin)
			if originLeadingDigit == INVALID_DIGIT {
				return E_CELL_INVALID
			}
			pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE)) + uintptr(originLeadingDigit)*28 + uintptr(dir)*4))
			{
				var i int32 = 0
				for ; i < pentagonRotations; i++ {
					dir = X_rotate60ccw(tls, dir)
				}
			}
			// The pentagon rotations are being chosen so that dir is not the
			// deleted direction. If it still happens, it means we're moving
			// into a deleted subsequence, so there is no index here.
			if dir == K_AXES_DIGIT {
				return E_PENTAGON
			}
			baseCell = X_getBaseCellNeighbor(tls, originBaseCell, dir)

			// indexOnPent does not need to be checked again since no pentagon
			// base cells border each other.
			if baseCell != DINVALID_BASE_CELL {
			} else {
				libc.X__assert_fail(tls, ts+1566, ts+1418, int32(411), uintptr(unsafe.Pointer(&__func__21)))
			}
			if !(X_isBaseCellPentagon(tls, baseCell) != 0) {
			} else {
				libc.X__assert_fail(tls, ts+1596, ts+1418, int32(412), uintptr(unsafe.Pointer(&__func__21)))
			}
		}

		// Now we can determine the relation between the origin and target base
		// cell.
		var baseCellRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XbaseCellNeighbor60CCWRots)) + uintptr(originBaseCell)*28 + uintptr(dir)*4))
		if baseCellRotations >= 0 {
		} else {
			libc.X__assert_fail(tls, ts+1627, ts+1418, int32(419), uintptr(unsafe.Pointer(&__func__21)))
		}

		// Adjust for pentagon warping within the base cell. The base cell
		// should be in the right location, so now we need to rotate the index
		// back. We might not need to check for errors since we would just be
		// double mapping.
		if indexOnPent != 0 {
			var revDir uint32 = X_getBaseCellDirection(tls, baseCell, originBaseCell)
			if revDir != INVALID_DIGIT {
			} else {
				libc.X__assert_fail(tls, ts+1442, ts+1418, int32(428), uintptr(unsafe.Pointer(&__func__21)))
			}

			// Adjust for the different coordinate space in the two base cells.
			// This is done first because we need to do the pentagon rotations
			// based on the leading digit in the pentagon's coordinate system.
			{
				var i int32 = 0
				for ; i < baseCellRotations; i++ {
					*(*uint64)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*uint64)(unsafe.Pointer(out)))
				}
			}

			var indexLeadingDigit uint32 = X_h3LeadingNonZeroDigit(tls, *(*uint64)(unsafe.Pointer(out)))
			// This case should be unreachable because this function is building
			// *out, and should never generate an invalid digit, above.
			if func() int32 {
				if indexLeadingDigit == INVALID_DIGIT {
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+1418, int32(440), uintptr(unsafe.Pointer(&__func__21)))
						}
						return 1
					}()
				}
				return 0
			}() != 0 {
				return E_CELL_INVALID
			}
			if X_isBaseCellPolarPentagon(tls, baseCell) != 0 {
				pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE_POLAR)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
			} else {
				pentagonRotations = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE_NONPOLAR)) + uintptr(revDir)*28 + uintptr(indexLeadingDigit)*4))
			}
			// For this to occur, revDir would need to be 1. Since revDir is
			// from the index base cell (which is a pentagon) towards the
			// origin, this should never be the case.
			if func() int32 {
				if pentagonRotations < 0 {
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+1418, int32(454), uintptr(unsafe.Pointer(&__func__21)))
						}
						return 1
					}()
				}
				return 0
			}() != 0 {
				return E_CELL_INVALID
			}

			{
				var i1 int32 = 0
				for ; i1 < pentagonRotations; i1++ {
					*(*uint64)(unsafe.Pointer(out)) = X_h3RotatePent60ccw(tls, *(*uint64)(unsafe.Pointer(out)))
				}
			}
		} else {
			if pentagonRotations < 0 {
				return E_CELL_INVALID
			}
			{
				var i int32 = 0
				for ; i < pentagonRotations; i++ {
					*(*uint64)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*uint64)(unsafe.Pointer(out)))
				}
			}

			// Adjust for the different coordinate space in the two base cells.
			{
				var i1 int32 = 0
				for ; i1 < baseCellRotations; i1++ {
					*(*uint64)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*uint64)(unsafe.Pointer(out)))
				}
			}
		}
	} else if originOnPent != 0 && indexOnPent != 0 {
		var originLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, origin))
		var indexLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, *(*uint64)(unsafe.Pointer(out))))

		if originLeadingDigit == INVALID_DIGIT || indexLeadingDigit == INVALID_DIGIT {
			return E_CELL_INVALID
		}
		var withinPentagonRotations int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&XPENTAGON_ROTATIONS_REVERSE)) + uintptr(originLeadingDigit)*28 + uintptr(indexLeadingDigit)*4))
		if withinPentagonRotations < 0 {
			// This occurs when an invalid K axis digit is present
			return E_CELL_INVALID
		}

		{
			var i int32 = 0
			for ; i < withinPentagonRotations; i++ {
				*(*uint64)(unsafe.Pointer(out)) = X_h3Rotate60ccw(tls, *(*uint64)(unsafe.Pointer(out)))
			}
		}
	}

	if indexOnPent != 0 {
		// TODO: There are cases in cellToLocalIjk which are failed but not
		// accounted for here - instead just fail if the recovered index is
		// invalid.
		if X_h3LeadingNonZeroDigit(tls, *(*uint64)(unsafe.Pointer(out))) == K_AXES_DIGIT {
			return E_PENTAGON
		}
	}

	*(*uint64)(unsafe.Pointer(out)) = *(*uint64)(unsafe.Pointer(out))&libc.CplUint64(uint64(uint64(127))<<DH3_BC_OFFSET) | uint64(baseCell)<<DH3_BC_OFFSET
	return E_SUCCESS
}

var __func__21 = *(*[15]int8)(unsafe.Pointer(ts + 1650)) /* localij.c:302:75 */

// *
// Produces ij coordinates for an index anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Coordinates are only comparable if they come from the same
// origin index.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// This function's output is not guaranteed
// to be compatible across different versions of H3.
//
// @param origin An anchoring index for the ij coordinate system.
// @param index Index to find the coordinates of
// @param mode Mode, must be 0
// @param out ij coordinates of the index will be placed here on success
// @return 0 on success, or another value on failure.
func XcellToLocalIj(tls *libc.TLS, origin uint64, h3 uint64, mode uint32, out uintptr) uint32 { /* localij.c:528:9: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	if mode != uint32(0) {
		return E_OPTION_INVALID
	}
	// var ijk TCoordIJK at bp, 12

	var failed uint32 = XcellToLocalIjk(tls, origin, h3, bp)
	if failed != 0 {
		return failed
	}

	XijkToIj(tls, bp, out)

	return E_SUCCESS
}

// *
// Produces an index for ij coordinates anchored by an origin.
//
// The coordinate space used by this function may have deleted
// regions or warping due to pentagonal distortion.
//
// Failure may occur if the index is too far away from the origin
// or if the index is on the other side of a pentagon.
//
// This function's output is not guaranteed
// to be compatible across different versions of H3.
//
// @param origin An anchoring index for the ij coordinate system.
// @param out ij coordinates to index.
// @param mode Mode, must be 0
// @param index Index will be placed here on success.
// @return 0 on success, or another value on failure.
func XlocalIjToCell(tls *libc.TLS, origin uint64, ij uintptr, mode uint32, out uintptr) uint32 { /* localij.c:562:9: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	if mode != uint32(0) {
		return E_OPTION_INVALID
	}
	// var ijk TCoordIJK at bp, 12

	var ijToIjkError uint32 = XijToIjk(tls, ij, bp)
	if ijToIjkError != 0 {
		return ijToIjkError
	}

	return XlocalIjkToCell(tls, origin, bp, out)
}

// *
// Produces the grid distance between the two indexes.
//
// This function may fail to find the distance between two indexes, for
// example if they are very far apart. It may also fail when finding
// distances for indexes on opposite sides of a pentagon.
//
// @param origin Index to find the distance from.
// @param index Index to find the distance to.
// @return The distance, or a negative number if the library could not
// compute the distance.
func XgridDistance(tls *libc.TLS, origin uint64, h3 uint64, out uintptr) uint32 { /* localij.c:588:9: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var originIjk TCoordIJK at bp, 12

	// var h3Ijk TCoordIJK at bp+12, 12

	var originError uint32 = XcellToLocalIjk(tls, origin, origin, bp)
	if originError != 0 {
		return originError
	}
	var destError uint32 = XcellToLocalIjk(tls, origin, h3, bp+12)
	if destError != 0 {
		return destError
	}

	*(*int64)(unsafe.Pointer(out)) = int64(XijkDistance(tls, bp, bp+12))
	return E_SUCCESS
}

// *
// Number of indexes in a line from the start index to the end index,
// to be used for allocating memory. Returns a negative number if the
// line cannot be computed.
//
// @param start Start index of the line
// @param end End index of the line
// @param size Size of the line
// @returns 0 on success, or another value on error
func XgridPathCellsSize(tls *libc.TLS, start uint64, end uint64, size uintptr) uint32 { /* localij.c:613:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var distance int64 at bp, 8

	var distanceError uint32 = XgridDistance(tls, start, end, bp)
	if distanceError != 0 {
		return distanceError
	}
	*(*int64)(unsafe.Pointer(size)) = *(*int64)(unsafe.Pointer(bp)) + int64(1)
	return E_SUCCESS
}

// *
// Given cube coords as doubles, round to valid integer coordinates. Algorithm
// from https://www.redblobgames.com/grids/hexagons/#rounding
// @param i   Floating-point I coord
// @param j   Floating-point J coord
// @param k   Floating-point K coord
// @param ijk IJK coord struct, modified in place
func cubeRound(tls *libc.TLS, i float64, j float64, k float64, ijk uintptr) { /* localij.c:632:13: */
	var ri int32 = libc.Int32FromFloat64(libc.Xround(tls, i))
	var rj int32 = libc.Int32FromFloat64(libc.Xround(tls, j))
	var rk int32 = libc.Int32FromFloat64(libc.Xround(tls, k))

	var iDiff float64 = libc.Xfabs(tls, float64(ri)-i)
	var jDiff float64 = libc.Xfabs(tls, float64(rj)-j)
	var kDiff float64 = libc.Xfabs(tls, float64(rk)-k)

	// Round, maintaining valid cube coords
	if iDiff > jDiff && iDiff > kDiff {
		ri = -rj - rk
	} else if jDiff > kDiff {
		rj = -ri - rk
	} else {
		rk = -ri - rj
	}

	(*TCoordIJK)(unsafe.Pointer(ijk)).Fi = ri
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fj = rj
	(*TCoordIJK)(unsafe.Pointer(ijk)).Fk = rk
}

// *
// Given two H3 indexes, return the line of indexes between them (inclusive).
//
// This function may fail to find the line between two indexes, for
// example if they are very far apart. It may also fail when finding
// distances for indexes on opposite sides of a pentagon.
//
// Notes:
//
//   - The specific output of this function should not be considered stable
//     across library versions. The only guarantees the library provides are
//     that the line length will be `gridDistance(start, end) + 1` and that
//     every index in the line will be a neighbor of the preceding index.
//   - Lines are drawn in grid space, and may not correspond exactly to either
//     Cartesian lines or great arcs.
//
// @param start Start index of the line
// @param end End index of the line
// @param out Output array, which must be of size gridPathCellsSize(start, end)
// @return 0 on success, or another value on failure.
func XgridPathCells(tls *libc.TLS, start uint64, end uint64, out uintptr) uint32 { /* localij.c:676:9: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var distance int64 at bp, 8

	var distanceError uint32 = XgridDistance(tls, start, end, bp)
	// Early exit if we can't calculate the line
	if distanceError != 0 {
		return distanceError
	}

	// Get IJK coords for the start and end. We've already confirmed
	// that these can be calculated with the distance check above.
	*(*TCoordIJK)(unsafe.Pointer(bp + 8 /* startIjk */)) = TCoordIJK{}
	*(*TCoordIJK)(unsafe.Pointer(bp + 20 /* endIjk */)) = TCoordIJK{}

	// Convert H3 addresses to IJK coords
	var startError uint32 = XcellToLocalIjk(tls, start, start, bp+8)
	if func() int32 {
		if startError != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+1418, int32(691), uintptr(unsafe.Pointer(&__func__22)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// Unreachable because this was called as part of gridDistance
		return startError
	}
	var endError uint32 = XcellToLocalIjk(tls, start, end, bp+20)
	if func() int32 {
		if endError != 0 {
			return func() int32 {
				if 0 != 0 {
				} else {
					libc.X__assert_fail(tls, ts, ts+1418, int32(696), uintptr(unsafe.Pointer(&__func__22)))
				}
				return 1
			}()
		}
		return 0
	}() != 0 {
		// Unreachable because this was called as part of gridDistance
		return endError
	}

	// Convert IJK to cube coordinates suitable for linear interpolation
	XijkToCube(tls, bp+8)
	XijkToCube(tls, bp+20)

	var invDistance float64
	if *(*int64)(unsafe.Pointer(bp)) != 0 {
		invDistance = 1.0 / float64(*(*int64)(unsafe.Pointer(bp)))
	} else {
		invDistance = float64(0)
	}
	var iStep float64 = float64((*TCoordIJK)(unsafe.Pointer(bp+20)).Fi-(*TCoordIJK)(unsafe.Pointer(bp+8)).Fi) * invDistance
	var jStep float64 = float64((*TCoordIJK)(unsafe.Pointer(bp+20)).Fj-(*TCoordIJK)(unsafe.Pointer(bp+8)).Fj) * invDistance
	var kStep float64 = float64((*TCoordIJK)(unsafe.Pointer(bp+20)).Fk-(*TCoordIJK)(unsafe.Pointer(bp+8)).Fk) * invDistance

	*(*TCoordIJK)(unsafe.Pointer(bp + 32 /* currentIjk */)) = TCoordIJK{Fi: (*TCoordIJK)(unsafe.Pointer(bp + 8 /* &startIjk */)).Fi, Fj: (*TCoordIJK)(unsafe.Pointer(bp + 8 /* &startIjk */)).Fj, Fk: (*TCoordIJK)(unsafe.Pointer(bp + 8 /* &startIjk */)).Fk}
	{
		var n int64 = int64(0)
		for ; n <= *(*int64)(unsafe.Pointer(bp)); n++ {
			cubeRound(tls, float64((*TCoordIJK)(unsafe.Pointer(bp+8)).Fi)+iStep*float64(n),
				float64((*TCoordIJK)(unsafe.Pointer(bp+8)).Fj)+jStep*float64(n),
				float64((*TCoordIJK)(unsafe.Pointer(bp+8)).Fk)+kStep*float64(n), bp+32)
			// Convert cube -> ijk -> h3 index
			XcubeToIjk(tls, bp+32)
			var currentError uint32 = XlocalIjkToCell(tls, start, bp+32, out+uintptr(n)*8)
			if currentError != 0 {
				// The cells between `start` and `end` may fall in pentagon
				// distortion.
				return currentError
			}
		}
	}

	return E_SUCCESS
}

var __func__22 = *(*[14]int8)(unsafe.Pointer(ts + 1665)) /* localij.c:676:76 */

// *
// _ipow does integer exponentiation efficiently. Taken from StackOverflow.
//
// @param base the integer base (can be positive or negative)
// @param exp the integer exponent (should be nonnegative)
//
// @return the exponentiated value
func X_ipow(tls *libc.TLS, base int64, exp int64) int64 { /* mathExtensions.c:30:9: */
	var result int64 = int64(1)
	for exp != 0 {
		if exp&int64(1) != 0 {
			result = result * base
		}
		exp >>= 1
		base = base * base
	}

	return result
}

// *
// IterCellsPolygonCompact: struct for iterating through all the cells
// within a given polygon, outputting a compact set.
//
// Constructors:
//
// Initialize with `iterInitPolygon`. This will save a reference to the
// input polygon and allocate memory for data structures used in the
// iteration. Iterators initialized in this way must be destroyed by
// `iterDestroyPolygon` to free allocated memory.
//
// Iteration:
//
// Step iterator with `iterStepPolygonCompact`.
// During the lifetime of the `iterCellsPolygonCompact`, the current iterate
// is accessed via the `iterCellsPolygonCompact.cell` member. When the iterator
// is exhausted  or if there was an error in initialization or iteration,
// `iterCellsPolygonCompact.cell` will be `H3_NULL` after calling
// `iterStepChild`. It is the responsibiliy of the caller to check
// `iterCellsPolygonCompact.error` when `H3_NULL` is received.
//
// Cleanup:
//
// Destroy the iterator and free allocated memory with `iterDestroyPolygon`.
type TIterCellsPolygonCompact = struct {
	Fcell        uint64
	Ferror       uint32
	F_res        int32
	F_flags      uint32
	F__ccgo_pad1 [4]byte
	F_polygon    uintptr
	F_bboxes     uintptr
	F_started    uint8
	F__ccgo_pad2 [7]byte
} /* polyfill.h:62:3 */

type TIterCellsPolygon = struct {
	Fcell        uint64
	Ferror       uint32
	F__ccgo_pad1 [4]byte
	F_cellIter   TIterCellsPolygonCompact
	F_childIter  TIterCellsChildren
} /* polyfill.h:74:3 */

// Factor by which to scale the cell bounding box to include all cells.
// This was determined empirically by finding the smallest factor that
// passed exhaustive tests.

// Factor by which to scale the cell bounding box to include all children.
// This was determined empirically by finding the smallest factor that
// passed exhaustive tests.

// *
// Max cell edge length, in radians, for each resolution. This was computed
// by taking the max exact edge length for cells at the center of each base
// cell at that resolution.
var sMAX_EDGE_LENGTH_RADS = [16]float64{
	0.21577206265130, 0.08308767068495, 0.03148970436439, 0.01190662871439,
	0.00450053330908, 0.00170105523619, 0.00064293917678, 0.00024300820659,
	0.00009184847087, 0.00003471545901, 0.00001312121017, 0.00000495935129,
	0.00000187445860, 0.00000070847876, 0.00000026777980, 0.00000010121125} /* polyfill.c:47:15 */

// * All cells that contain the north pole, by res
var sNORTH_POLE_CELLS = [16]uint64{
	uint64(0x8001fffffffffff), uint64(0x81033ffffffffff), uint64(0x820327fffffffff), uint64(0x830326fffffffff),
	uint64(0x8403263ffffffff), uint64(0x85032623fffffff), uint64(0x860326237ffffff), uint64(0x870326233ffffff),
	uint64(0x880326233bfffff), uint64(0x890326233abffff), uint64(0x8a0326233ab7fff), uint64(0x8b0326233ab0fff),
	uint64(0x8c0326233ab03ff), uint64(0x8d0326233ab03bf), uint64(0x8e0326233ab039f), uint64(0x8f0326233ab0399)} /* polyfill.c:54:16 */

// * All cells that contain the south pole, by res
var sSOUTH_POLE_CELLS = [16]uint64{
	uint64(0x80f3fffffffffff), uint64(0x81f2bffffffffff), uint64(0x82f297fffffffff), uint64(0x83f293fffffffff),
	uint64(0x84f2939ffffffff), uint64(0x85f29383fffffff), uint64(0x86f29380fffffff), uint64(0x87f29380effffff),
	uint64(0x88f29380e1fffff), uint64(0x89f29380e0fffff), uint64(0x8af29380e0d7fff), uint64(0x8bf29380e0d0fff),
	uint64(0x8cf29380e0d0dff), uint64(0x8df29380e0d0cff), uint64(0x8ef29380e0d0cc7), uint64(0x8ff29380e0d0cc4)} /* polyfill.c:61:16 */

// * Pre-calculated bounding boxes for all res 0 cells
var sRES0_BBOXES = [122]TBBox{
	{Fnorth: 1.52480158339146, Fsouth: 1.20305471830087, Feast: -0.60664883654036, Fwest: 0.00568297271999},
	{Fnorth: 1.52480158339146, Fsouth: 1.17872424267511, Feast: -0.60664883654036, Fwest: 2.54046980298264},
	{Fnorth: 1.52480158339146, Fsouth: 1.09069387298096, Feast: -2.85286053297673, Fwest: 1.64310689027893},
	{Fnorth: 1.41845302535151, Fsouth: 1.01285145697208, Feast: 0.00568297271999, Fwest: -1.16770379632602},
	{Fnorth: 1.27950477868453, Fsouth: 0.97226652536306, Feast: 0.55556064983494, Fwest: -0.18229924845326},
	{Fnorth: 1.32929586572429, Fsouth: 0.91898920750071, Feast: 2.05622344943192, Fwest: 1.08813154278274},
	{Fnorth: 1.32899086063916, Fsouth: 0.94271815376360, Feast: -2.29875289606378, Fwest: 3.01700008041993},
	{Fnorth: 1.26020983864103, Fsouth: 0.84291228415618, Feast: -0.89971867664861, Fwest: -1.75967359310997},
	{Fnorth: 1.21114673854945, Fsouth: 0.86170600921069, Feast: 1.19129757609455, Fwest: 0.43777608996454},
	{Fnorth: 1.21075831414294, Fsouth: 0.83795331049498, Feast: -1.72022875779891, Fwest: -2.43793861727138},
	{Fnorth: 1.15546530929588, Fsouth: 0.78982455384253, Feast: 2.53659412229266, Fwest: 1.85709133451243},
	{Fnorth: 1.15528445067052, Fsouth: 0.76641428724335, Feast: -3.06738507202411, Fwest: 2.53646110244042},
	{Fnorth: 1.10121643537669, Fsouth: 0.71330093663066, Feast: 0.09640581900154, Fwest: -0.52154514518248},
	{Fnorth: 1.07042472765165, Fsouth: 0.67603948819406, Feast: -0.47984202840088, Fwest: -1.10306159603090},
	{Fnorth: 1.03270228748960, Fsouth: 0.72356358827215, Feast: -2.24990138725146, Fwest: -2.74510220919157},
	{Fnorth: 1.01929924623886, Fsouth: 0.65491232835426, Feast: 0.63035574240731, Fwest: 0.03537030096470},
	{Fnorth: 1.01786037568858, Fsouth: 0.58827636737638, Feast: 1.53192721817065, Fwest: 0.93672682511233},
	{Fnorth: 0.98081434136020, Fsouth: 0.61076063532947, Feast: -2.67100636598529, Fwest: 3.06516463008733},
	{Fnorth: 0.98106023192774, Fsouth: 0.58679836571570, Feast: 2.02829766214461, Fwest: 1.51334374970280},
	{Fnorth: 0.96374551790056, Fsouth: 0.55186491737474, Feast: -1.42976721313659, Fwest: -1.96852202530104},
	{Fnorth: 0.87536136210723, Fsouth: 0.50008952762292, Feast: -1.92435613571430, Fwest: -2.41641343219793},
	{Fnorth: 0.88611243445554, Fsouth: 0.52742963716774, Feast: -0.95781946324194, Fwest: -1.47628966305930},
	{Fnorth: 0.86881343251986, Fsouth: 0.50770567021439, Feast: 1.03236795495839, Fwest: 0.50347284027426},
	{Fnorth: 0.89235638181782, Fsouth: 0.48781264892508, Feast: 2.76430302119150, Fwest: 2.29989716697031},
	{Fnorth: 0.82570569254601, Fsouth: 0.52173101741059, Feast: 2.30921681461428, Fwest: 1.93198541828980},
	{Fnorth: 0.80599330438546, Fsouth: 0.40150819579319, Feast: -3.06417559403240, Fwest: 2.70079300784409},
	{Fnorth: 0.81612079704781, Fsouth: 0.38396800633226, Feast: -0.21614378891839, Fwest: -0.70420149722178},
	{Fnorth: 0.75822779851431, Fsouth: 0.39943555383751, Feast: -2.34059978084699, Fwest: -2.82127373822444},
	{Fnorth: 0.78861390967531, Fsouth: 0.38742018303868, Feast: 0.23115687731652, Fwest: -0.22599491086066},
	{Fnorth: 0.71515840341957, Fsouth: 0.33012478438475, Feast: -0.64847976163163, Fwest: -1.08249728121219},
	{Fnorth: 0.70359051048414, Fsouth: 0.29148673180722, Feast: 1.71441081857246, Fwest: 1.28443348381696},
	{Fnorth: 0.69190629544818, Fsouth: 0.28808313184381, Feast: 0.64863909244647, Fwest: 0.16372369282557},
	{Fnorth: 0.64863235654749, Fsouth: 0.26290420067147, Feast: 2.10318098268379, Fwest: 1.69556122548344},
	{Fnorth: 0.65722892279906, Fsouth: 0.28222653310929, Feast: 1.30918693285466, Fwest: 0.87594416271685},
	{Fnorth: 0.64750997738584, Fsouth: 0.24149865709850, Feast: -1.30272192474556, Fwest: -1.68708570163242},
	{Fnorth: 0.62380174028378, Fsouth: 0.25522080363509, Feast: -2.72428423026826, Fwest: 3.10401473237630},
	{Fnorth: 0.64228460410023, Fsouth: 0.21206753429148, Feast: -1.67639240992071, Fwest: -2.11772366767341},
	{Fnorth: 0.59919175361146, Fsouth: 0.21620460836570, Feast: 2.48592868387690, Fwest: 2.07350353893591},
	{Fnorth: 0.55637406851384, Fsouth: 0.25276557437230, Feast: -0.99885388505694, Fwest: -1.32642489358939},
	{Fnorth: 0.55648013300665, Fsouth: 0.15187401321019, Feast: 2.87032088421324, Fwest: 2.44642320475367},
	{Fnorth: 0.54603687970450, Fsouth: 0.15589091511369, Feast: -2.06789866067060, Fwest: -2.49091419631961},
	{Fnorth: 0.51206347752697, Fsouth: 0.15522020377124, Feast: 0.95446767315996, Fwest: 0.54443262110414},
	{Fnorth: 0.49767951537101, Fsouth: 0.10944898890579, Feast: -0.04335162263358, Fwest: -0.42900268178569},
	{Fnorth: 0.46538045483671, Fsouth: 0.06029968637720, Feast: -0.41240613713421, Fwest: -0.80603623808166},
	{Fnorth: 0.44686891066946, Fsouth: 0.06926857458503, Feast: 0.32053284794952, Fwest: -0.07005748900849},
	{Fnorth: 0.43208958202064, Fsouth: 0.07796440938140, Feast: -3.06232453079660, Fwest: 2.80602499990282},
	{Fnorth: 0.43103892586713, Fsouth: 0.02927431919853, Feast: -2.41589238618422, Fwest: -2.85735809951951},
	{Fnorth: 0.38073727558986, Fsouth: -0.00297016159959, Feast: -0.77039553861218, Fwest: -1.14788248745028},
	{Fnorth: 0.39113816687141, Fsouth: -0.01518764903038, Feast: 1.49130246958290, Fwest: 1.14714731736311},
	{Fnorth: 0.33421063142418, Fsouth: 0.02526613430348, Feast: 1.15141032578749, Fwest: 0.85000706261644},
	{Fnorth: 0.38915669778582, Fsouth: -0.04371359825454, Feast: 1.88046353933242, Fwest: 1.48230231380717},
	{Fnorth: 0.33787520825987, Fsouth: -0.04835090128296, Feast: -1.12274014380603, Fwest: -1.49454408844749},
	{Fnorth: 0.33601418932337, Fsouth: -0.06675068178541, Feast: 2.23792354204464, Fwest: 1.85723423013211},
	{Fnorth: 0.31838318078049, Fsouth: -0.05821955623722, Feast: 0.66058854060373, Fwest: 0.25452572938783},
	{Fnorth: 0.33630761471457, Fsouth: -0.07589541031521, Feast: -1.47957331741818, Fwest: -1.85981735718264},
	{Fnorth: 0.28924817322870, Fsouth: -0.09150638064667, Feast: -1.83561930288569, Fwest: -2.21855897384292},
	{Fnorth: 0.26678632252475, Fsouth: -0.10058088990867, Feast: -2.76808651991421, Fwest: 3.12792953247061},
	{Fnorth: 0.29285254112587, Fsouth: -0.13483165093783, Feast: 2.61406468380434, Fwest: 2.20466422911705},
	{Fnorth: 0.20150342788824, Fsouth: -0.10279852729762, Feast: 0.06881896344365, Fwest: -0.23925229432978},
	{Fnorth: 0.21283813275258, Fsouth: -0.18626835417891, Feast: 2.93800440256577, Fwest: 2.57470747655623},
	{Fnorth: 0.19587614179884, Fsouth: -0.17237030304155, Feast: -2.16941795427335, Fwest: -2.55405165906601},
	{Fnorth: 0.17237030304155, Fsouth: -0.19587614179884, Feast: 0.97217469931645, Fwest: 0.58754099452378},
	{Fnorth: 0.18626835417891, Fsouth: -0.21283813275258, Feast: -0.20358825102402, Fwest: -0.56688517703356},
	{Fnorth: 0.10279852729762, Fsouth: -0.20150342788824, Feast: -3.07277369014614, Fwest: 2.90234035926002},
	{Fnorth: 0.13483165093783, Fsouth: -0.29285254112587, Feast: -0.52752796978545, Fwest: -0.93692842447275},
	{Fnorth: 0.10058088990867, Fsouth: -0.26678632252475, Feast: 0.37350613367558, Fwest: -0.01366312111919},
	{Fnorth: 0.09150638064667, Fsouth: -0.28924817322870, Feast: 1.30597335070410, Fwest: 0.92303367974687},
	{Fnorth: 0.07589541031521, Fsouth: -0.33630761471457, Feast: 1.66201933617161, Fwest: 1.28177529640715},
	{Fnorth: 0.05821955623722, Fsouth: -0.31838318078049, Feast: -2.48100411298606, Fwest: -2.88706692420196},
	{Fnorth: 0.06675068178541, Fsouth: -0.33601418932337, Feast: -0.90366911154516, Fwest: -1.28435842345769},
	{Fnorth: 0.04835090128296, Fsouth: -0.33787520825987, Feast: 2.01885250978376, Fwest: 1.64704856514230},
	{Fnorth: 0.04371359825454, Fsouth: -0.38915669778582, Feast: -1.26112911425737, Fwest: -1.65929033978262},
	{Fnorth: -0.02526613430348, Fsouth: -0.33421063142418, Feast: -1.99018232780231,
		Fwest: -2.29158559097336},
	{Fnorth: 0.01518764903038, Fsouth: -0.39113816687140, Feast: -1.65029018400690, Fwest: -1.99444533622668},
	{Fnorth: 0.00297016159959, Fsouth: -0.38073727558986, Feast: 2.37119711497761, Fwest: 1.99371016613951},
	{Fnorth: -0.02927431919853, Fsouth: -0.43103892586713, Feast: 0.72570026740558, Fwest: 0.28423455407029},
	{Fnorth: -0.07796440938140, Fsouth: -0.43208958202064, Feast: 0.07926812279319, Fwest: -0.33556765368697},
	{Fnorth: -0.06926857458503, Fsouth: -0.44686891066946, Feast: -2.82105980564027, Fwest: 3.07153516458131},
	{Fnorth: -0.06029968637720, Fsouth: -0.46538045483671, Feast: 2.72918651645558, Fwest: 2.33555641550814},
	{Fnorth: -0.10944898890579, Fsouth: -0.49767951537101, Feast: 3.09824103095621, Fwest: 2.71258997180410},
	{Fnorth: -0.15522020377124, Fsouth: -0.51206347752697, Feast: -2.18712498042983,
		Fwest: -2.59716003248565},
	{Fnorth: -0.15589091511369, Fsouth: -0.54603687970450, Feast: 1.07369399291919, Fwest: 0.65067845727018},
	{Fnorth: -0.15187401321019, Fsouth: -0.55648013300665, Feast: -0.27127176937655,
		Fwest: -0.69516944883612},
	{Fnorth: -0.25276557437230, Fsouth: -0.55637406851385, Feast: 2.14273876853285, Fwest: 1.81516776000041},
	{Fnorth: -0.21620460836570, Fsouth: -0.59919175361146, Feast: -0.65566396971290,
		Fwest: -1.06808911465388},
	{Fnorth: -0.21206753429148, Fsouth: -0.64228460410023, Feast: 1.46520024366909, Fwest: 1.02386898591638},
	{Fnorth: -0.25522080363509, Fsouth: -0.62380174028378, Feast: 0.41730842332153, Fwest: -0.03757792121350},
	{Fnorth: -0.24149865709850, Fsouth: -0.64750997738584, Feast: 1.83887072884423, Fwest: 1.45450695195737},
	{Fnorth: -0.28222653310929, Fsouth: -0.65722892279906, Feast: -1.83240572073513,
		Fwest: -2.26564849087294},
	{Fnorth: -0.26290420067147, Fsouth: -0.64863235654749, Feast: -1.03841167090601,
		Fwest: -1.44603142810635},
	{Fnorth: -0.28808313184381, Fsouth: -0.69190629544818, Feast: -2.49295356114332,
		Fwest: -2.97786896076422},
	{Fnorth: -0.29148673180722, Fsouth: -0.70359051048414, Feast: -1.42718183501734,
		Fwest: -1.85715916977284},
	{Fnorth: -0.33012478438475, Fsouth: -0.71515840341957, Feast: 2.49311289195816, Fwest: 2.05909537237761},
	{Fnorth: -0.38742018303868, Fsouth: -0.78861390967531, Feast: -2.91043577627328, Fwest: 2.91559774272914},
	{Fnorth: -0.39943555383751, Fsouth: -0.75822779851431, Feast: 0.80099287274280, Fwest: 0.32031891536535},
	{Fnorth: -0.38396800633226, Fsouth: -0.81612079704781, Feast: 2.92544886467140, Fwest: 2.43739115636801},
	{Fnorth: -0.40150819579319, Fsouth: -0.80599330438546, Feast: 0.07741705955739, Fwest: -0.44079964574570},
	{Fnorth: -0.52173101741059, Fsouth: -0.82570569254601, Feast: -0.83237583897551,
		Fwest: -1.20960723529999},
	{Fnorth: -0.48781264892508, Fsouth: -0.89235638181782, Feast: -0.37728963239830,
		Fwest: -0.84169548661948},
	{Fnorth: -0.50770567021439, Fsouth: -0.86881343251986, Feast: -2.10922469863141,
		Fwest: -2.63811981331554},
	{Fnorth: -0.52742963716774, Fsouth: -0.88611243445554, Feast: 2.18377319034785, Fwest: 1.66530299053050},
	{Fnorth: -0.50008952762292, Fsouth: -0.87536136210723, Feast: 1.21723651787549, Fwest: 0.72517922139186},
	{Fnorth: -0.55186491737474, Fsouth: -0.96374551790056, Feast: 1.71182544045320, Fwest: 1.17307062828876},
	{Fnorth: -0.58679836571570, Fsouth: -0.98106023192774, Feast: -1.11329499144518,
		Fwest: -1.62824890388699},
	{Fnorth: -0.61076063532947, Fsouth: -0.98081434136020, Feast: 0.47058628760450, Fwest: -0.07642802350246},
	{Fnorth: -0.58827636737638, Fsouth: -1.01786037568858, Feast: -1.60966543541914,
		Fwest: -2.20486582847747},
	{Fnorth: -0.65491232835426, Fsouth: -1.01929924623886, Feast: -2.51123691118248,
		Fwest: -3.10622235262510},
	{Fnorth: -0.72356358827215, Fsouth: -1.03270228748960, Feast: 0.89169126633833, Fwest: 0.39649044439822},
	{Fnorth: -0.67603948819406, Fsouth: -1.07042472765165, Feast: 2.66175062518892, Fwest: 2.03853105755889},
	{Fnorth: -0.71330093663066, Fsouth: -1.10121643537669, Feast: -3.04518683458825, Fwest: 2.62004750840731},
	{Fnorth: -0.76641428724335, Fsouth: -1.15528445067052, Feast: 0.07420758156568, Fwest: -0.60513155114938},
	{Fnorth: -0.78982455384253, Fsouth: -1.15546530929588, Feast: -0.60499853129713,
		Fwest: -1.28450131907736},
	{Fnorth: -0.83795331049498, Fsouth: -1.21075831414294, Feast: 1.42136389579088, Fwest: 0.70365403631841},
	{Fnorth: -0.86170600921069, Fsouth: -1.21114673854945, Feast: -1.95029507749525,
		Fwest: -2.70381656362525},
	{Fnorth: -0.84291228415618, Fsouth: -1.26020983864103, Feast: 2.24187397694118, Fwest: 1.38191906047983},
	{Fnorth: -0.94271815376360, Fsouth: -1.32899086063916, Feast: 0.84283975752601, Fwest: -0.12459257316986},
	{Fnorth: -0.91898920750071, Fsouth: -1.32929586572429, Feast: -1.08536920415787,
		Fwest: -2.05346111080706},
	{Fnorth: -0.97226652536306, Fsouth: -1.27950477868453, Feast: -2.58603200375485, Fwest: 2.95929340513654},
	{Fnorth: -1.01285145697208, Fsouth: -1.41845302535151, Feast: -3.13590968086981, Fwest: 1.97388885726377},
	{Fnorth: -1.09069387298096, Fsouth: -1.52480158339146, Feast: 0.28873212061306, Fwest: -1.49848576331087},
	{Fnorth: -1.17872424267511, Fsouth: -1.52480158339146, Feast: 2.53494381704943, Fwest: -0.60112285060716},
	{Fnorth: -1.20305471830087, Fsouth: -1.52480158339146, Feast: -0.60112285060716,
		Fwest: 2.53494381704943}} /* polyfill.c:68:13 */

var sVALID_RANGE_BBOX = TBBox{Fnorth: 1.57079632679489661923, Fsouth: -1.57079632679489661923, Feast: 3.14159265358979323846, Fwest: -3.14159265358979323846} /* polyfill.c:210:13 */

// *
// For a given cell, return its bounding box. If coverChildren is true, the bbox
// will be guaranteed to contain its children at any finer resolution. Note that
// no guarantee is provided as to the level of accuracy, and the bounding box
// may have a significant margin of error.
// @param cell Cell to calculate bbox for
// @param out  BBox to hold output
// @param coverChildren Whether the bounding box should cover all children
func XcellToBBox(tls *libc.TLS, cell uint64, out uintptr, coverChildren uint8) uint32 { /* polyfill.c:221:9: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// Adjust the BBox to handle poles, if needed
	var res int32 = int32(cell & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	if res == 0 {
		var baseCell int32 = int32(cell & (uint64(uint64(127)) << DH3_BC_OFFSET) >> DH3_BC_OFFSET)
		if func() int32 {
			if baseCell < 0 {
				return func() int32 {
					if 0 != 0 {
					} else {
						libc.X__assert_fail(tls, ts, ts+1679, int32(227), uintptr(unsafe.Pointer(&__func__23)))
					}
					return 1
				}()
			}
			return 0
		}() != 0 || baseCell >= DNUM_BASE_CELLS {
			return E_CELL_INVALID
		}
		*(*TBBox)(unsafe.Pointer(out)) = sRES0_BBOXES[baseCell]
	} else {
		// var center TLatLng at bp, 16

		var centerErr uint32 = XcellToLatLng(tls, cell, bp)
		if centerErr != E_SUCCESS {
			return centerErr
		}
		var lngRatio float64 = float64(1) / libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(bp)).Flat)
		(*TBBox)(unsafe.Pointer(out)).Fnorth = (*TLatLng)(unsafe.Pointer(bp)).Flat + sMAX_EDGE_LENGTH_RADS[res]
		(*TBBox)(unsafe.Pointer(out)).Fsouth = (*TLatLng)(unsafe.Pointer(bp)).Flat - sMAX_EDGE_LENGTH_RADS[res]
		(*TBBox)(unsafe.Pointer(out)).Feast = (*TLatLng)(unsafe.Pointer(bp)).Flng + sMAX_EDGE_LENGTH_RADS[res]*lngRatio
		(*TBBox)(unsafe.Pointer(out)).Fwest = (*TLatLng)(unsafe.Pointer(bp)).Flng - sMAX_EDGE_LENGTH_RADS[res]*lngRatio
	}

	// Buffer the bounding box to cover children. Call this even if no buffering
	// is required in order to normalize the bbox to lat/lng bounds
	XscaleBBox(tls, out, func() float64 {
		if coverChildren != 0 {
			return 1.4
		}
		return 1.1
	}())

	// Cell that contains the north pole
	if cell == sNORTH_POLE_CELLS[res] {
		(*TBBox)(unsafe.Pointer(out)).Fnorth = 1.57079632679489661923
	}

	// Cell that contains the south pole
	if cell == sSOUTH_POLE_CELLS[res] {
		(*TBBox)(unsafe.Pointer(out)).Fsouth = -1.57079632679489661923
	}

	// If we contain a pole, expand the longitude to include the full domain,
	// effectively making the bbox a circle around the pole.
	if (*TBBox)(unsafe.Pointer(out)).Fnorth == 1.57079632679489661923 || (*TBBox)(unsafe.Pointer(out)).Fsouth == -1.57079632679489661923 {
		(*TBBox)(unsafe.Pointer(out)).Feast = 3.14159265358979323846
		(*TBBox)(unsafe.Pointer(out)).Fwest = -3.14159265358979323846
	}

	return E_SUCCESS
}

var __func__23 = *(*[11]int8)(unsafe.Pointer(ts + 1704)) /* polyfill.c:221:65 */

// *
// Get a base cell by number, or H3_NULL if out of bounds
func XbaseCellNumToCell(tls *libc.TLS, baseCellNum int32) uint64 { /* polyfill.c:271:9: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if baseCellNum < 0 || baseCellNum >= DNUM_BASE_CELLS {
		return uint64(DH3_NULL)
	}
	// var baseCell uint64 at bp, 8

	XsetH3Index(tls, bp, 0, baseCellNum, uint32(0))
	return *(*uint64)(unsafe.Pointer(bp /* baseCell */))
}

func iterErrorPolygonCompact(tls *libc.TLS, iter uintptr, error uint32) { /* polyfill.c:280:13: */
	XiterDestroyPolygonCompact(tls, iter)
	(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Ferror = error
}

// *
// Given a cell, find the next cell in the sequence of all cells
// to check in the iteration.
func nextCell(tls *libc.TLS, cell uint64) uint64 { /* polyfill.c:290:16: */
	var res int32 = int32(cell & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)
	for 1 != 0 {
		// If this is a base cell, set to next base cell (or H3_NULL if done)
		if res == 0 {
			return XbaseCellNumToCell(tls, int32(cell&(uint64(uint64(127))<<DH3_BC_OFFSET)>>DH3_BC_OFFSET)+1)
		}

		// Faster cellToParent when we know the resolution is valid
		// and we're only moving up one level
		var parent uint64 = cell
		parent = parent&libc.CplUint64(uint64(15)<<DH3_RES_OFFSET) | uint64(res-1)<<DH3_RES_OFFSET
		parent = parent & ^(uint64(uint64(7))<<((DMAX_H3_RES-res)*DH3_PER_DIGIT_OFFSET)) | uint64(uint64(7))<<((DMAX_H3_RES-res)*DH3_PER_DIGIT_OFFSET)

		// If not the last sibling of parent, return next sibling
		var digit uint32 = uint32(cell >> ((DMAX_H3_RES - res) * DH3_PER_DIGIT_OFFSET) & uint64(7))
		if digit < uint32(INVALID_DIGIT-1) {
			cell = cell & ^(uint64(uint64(7))<<((DMAX_H3_RES-res)*DH3_PER_DIGIT_OFFSET)) | uint64(digit+func() uint32 {
				if XisPentagon(tls, parent) != 0 && digit == CENTER_DIGIT {
					return uint32(2)
				}
				return uint32(1)
			}())<<((DMAX_H3_RES-res)*DH3_PER_DIGIT_OFFSET)
			return cell
		}
		// Move up to the parent for the next loop iteration
		res--
		cell = parent
	}
	return uint64(0)
}

// *
// Internal function - initialize the iterator without stepping to the first
// value
func _iterInitPolygonCompact(tls *libc.TLS, polygon uintptr, res int32, flags uint32) TIterCellsPolygonCompact { /* polyfill.c:324:32: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* iter */)) = TIterCellsPolygonCompact{Fcell: XbaseCellNumToCell(tls, 0), F_res: res, F_flags: flags, F_polygon: polygon}

	if res < 0 || res > DMAX_H3_RES {
		iterErrorPolygonCompact(tls, bp, E_RES_DOMAIN)
		return *(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* iter */))
	}

	var flagErr uint32 = XvalidatePolygonFlags(tls, flags)
	if flagErr != 0 {
		iterErrorPolygonCompact(tls, bp, flagErr)
		return *(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* iter */))
	}

	// Initialize bounding boxes for polygon and any holes. Memory allocated
	// here must be released through iterDestroyPolygonCompact
	(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* &iter */)).F_bboxes = libc.Xcalloc(tls, uint64((*TGeoPolygon)(unsafe.Pointer(polygon)).FnumHoles+1), uint64(unsafe.Sizeof(TBBox{})))
	if !(int32((*TIterCellsPolygonCompact)(unsafe.Pointer(bp)).F_bboxes) != 0) {
		iterErrorPolygonCompact(tls, bp, E_MEMORY_ALLOC)
		return *(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* iter */))
	}
	XbboxesFromGeoPolygon(tls, polygon, (*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* &iter */)).F_bboxes)

	return *(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* iter */))
}

// *
// Initialize a IterCellsPolygonCompact struct representing the sequence of
// compact cells within the target polygon. The test for including edge cells is
// defined by the polyfill mode passed in the `flags` argument.
//
// Initialization of this object may fail, in which case the `error` property
// will be set and all iteration will return H3_NULL. It is the responsibility
// of the caller to check the error property after initialization.
//
// At any point in the iteration, starting once the struct is initialized, the
// output value can be accessed through the `cell` property.
//
// Note that initializing the iterator allocates memory. If an iterator is
// exhausted or returns an error that memory is released; otherwise it must be
// released manually with iterDestroyPolygonCompact.
//
// @param  polygon Polygon to fill with compact cells
// @param  res     Finest resolution for output cells
// @param  flags   Bit mask of option flags
// @return         Initialized iterator, with the first value available
func XiterInitPolygonCompact(tls *libc.TLS, polygon uintptr, res int32, flags uint32) TIterCellsPolygonCompact { /* polyfill.c:381:25: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* iter */)) = _iterInitPolygonCompact(tls, polygon, res, flags)

	// Start the iterator by taking the first step.
	// This is necessary to have a valid value after initialization.
	XiterStepPolygonCompact(tls, bp)

	return *(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* iter */))
}

// *
// Increment the polyfill iterator, running the polygon to cells algorithm.
//
// Briefly, the algorithm checks every cell in the global grid hierarchically,
// starting with the base cells. Cells coarser than the target resolution are
// checked for complete child inclusion using a bounding box guaranteed to
// contain all children.
// - If the bounding box is contained by the polygon, output is set to the cell
// - If the bounding box intersects, recurse into the first child
// - Otherwise, continue with the next cell in sequence
//
// For cells at the target resolution, a finer-grained check is used according
// to the inclusion criteria set in flags.
//
// @param  iter Iterator to increment
func XiterStepPolygonCompact(tls *libc.TLS, iter uintptr) { /* polyfill.c:408:6: */
	bp := tls.Alloc(648)
	defer tls.Free(648)

	var cell uint64 = (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Fcell

	// once the cell is H3_NULL, the iterator returns an infinite sequence of
	// H3_NULL
	if cell == uint64(DH3_NULL) {
		return
	}

	// For the first step, we need to evaluate the current cell; after that, we
	// should start with the next cell.
	if (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_started != 0 {
		cell = nextCell(tls, cell)
	} else {
		(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_started = uint8(Dtrue)
	}

	// Short-circuit iteration for 0-vert polygon
	if (*TGeoPolygon)(unsafe.Pointer((*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon)).Fgeoloop.FnumVerts == 0 {
		XiterDestroyPolygonCompact(tls, iter)
		return
	}

	var mode uint32 = (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_flags & uint32(15)

	for cell != 0 {
		var cellRes int32 = int32(cell & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

		// Target res: Do a fine-grained check
		if cellRes == (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_res {
			if mode == CONTAINMENT_CENTER || mode == CONTAINMENT_OVERLAPPING || mode == CONTAINMENT_OVERLAPPING_BBOX {
				// Check if the cell center is inside the polygon
				// var center TLatLng at bp, 16

				var centerErr uint32 = XcellToLatLng(tls, cell, bp)
				if centerErr != E_SUCCESS {
					iterErrorPolygonCompact(tls, iter, centerErr)
					return
				}
				if XpointInsidePolygon(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes,
					bp) != 0 {
					// Set to next output
					(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Fcell = cell
					return
				}
			}
			if mode == CONTAINMENT_OVERLAPPING || mode == CONTAINMENT_OVERLAPPING_BBOX {
				// For overlapping, we need to do a quick check to determine
				// whether the polygon is wholly contained by the cell. We
				// check the first polygon vertex, which if it is contained
				// could also mean we simply intersect.

				// Deferencing verts[0] is safe because we check numVerts above
				*(*TLatLng)(unsafe.Pointer(bp + 16 /* firstVertex */)) = *(*TLatLng)(unsafe.Pointer((*TGeoPolygon)(unsafe.Pointer((*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon)).Fgeoloop.Fverts))

				// We have to check whether the point is in the expected range
				// first, because out-of-bounds values will yield false
				// positives with latLngToCell
				if XbboxContains(tls, uintptr(unsafe.Pointer(&sVALID_RANGE_BBOX)), bp+16) != 0 {
					// var polygonCell uint64 at bp+32, 8

					var polygonCellErr uint32 = XlatLngToCell(tls,
						(*TGeoPolygon)(unsafe.Pointer((*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon)).Fgeoloop.Fverts, cellRes,
						bp+32)
					if func() int32 {
						if polygonCellErr != E_SUCCESS {
							return func() int32 {
								if 0 != 0 {
								} else {
									libc.X__assert_fail(tls, ts, ts+1679, int32(470), uintptr(unsafe.Pointer(&__func__24)))
								}
								return 1
							}()
						}
						return 0
					}() != 0 {
						// This should be unreachable with the bbox check
						iterErrorPolygonCompact(tls, iter, polygonCellErr)
						return
					}
					if *(*uint64)(unsafe.Pointer(bp + 32)) == cell {
						// Set to next output
						(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Fcell = cell
						return
					}
				}
			}
			if mode == CONTAINMENT_FULL || mode == CONTAINMENT_OVERLAPPING || mode == CONTAINMENT_OVERLAPPING_BBOX {
				// var boundary TCellBoundary at bp+40, 168

				var boundaryErr uint32 = XcellToBoundary(tls, cell, bp+40)
				if boundaryErr != E_SUCCESS {
					iterErrorPolygonCompact(tls, iter, boundaryErr)
					return
				}
				// var bbox TBBox at bp+208, 32

				var bboxErr uint32 = XcellToBBox(tls, cell, bp+208, uint8(Dfalse))
				if func() int32 {
					if bboxErr != E_SUCCESS {
						return func() int32 {
							if 0 != 0 {
							} else {
								libc.X__assert_fail(tls, ts, ts+1679, int32(493), uintptr(unsafe.Pointer(&__func__24)))
							}
							return 1
						}()
					}
					return 0
				}() != 0 {
					// Should be unreachable - invalid cells would be caught in
					// the previous boundaryErr
					iterErrorPolygonCompact(tls, iter, bboxErr)
					return
				}
				// Check if the cell is fully contained by the polygon
				if (mode == CONTAINMENT_FULL || mode == CONTAINMENT_OVERLAPPING_BBOX) && XcellBoundaryInsidePolygon(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes,
					bp+40, bp+208) != 0 {
					// Set to next output
					(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Fcell = cell
					return
				} else if (mode == CONTAINMENT_OVERLAPPING || mode == CONTAINMENT_OVERLAPPING_BBOX) && XcellBoundaryCrossesPolygon(tls,
					(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes, bp+40, bp+208) != 0 {
					// Set to next output
					(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Fcell = cell
					return
				}
			}
			if mode == CONTAINMENT_OVERLAPPING_BBOX {
				// Get a bounding box containing all the cell's children, so
				// this can work for the max size calculation
				// var bbox TBBox at bp+240, 32

				var bboxErr uint32 = XcellToBBox(tls, cell, bp+240, uint8(Dtrue))
				if bboxErr != 0 {
					iterErrorPolygonCompact(tls, iter, bboxErr)
					return
				}
				if XbboxOverlapsBBox(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes, bp+240) != 0 {
					*(*TCellBoundary)(unsafe.Pointer(bp + 272 /* bboxBoundary */)) = XbboxToCellBoundary(tls, bp+240)
					if XbboxContainsBBox(tls, bp+240, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes) != 0 || XpointInsidePolygon(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes,
						bp+272+8) != 0 || XcellBoundaryCrossesPolygon(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon,
						(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes, bp+272,
						bp+240) != 0 {
						(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Fcell = cell
						return
					}
				}
			}
		}

		// Coarser cell: Check the bounding box
		if cellRes < (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_res {
			// Get a bounding box for all of the cell's children
			// var bbox TBBox at bp+440, 32

			var bboxErr uint32 = XcellToBBox(tls, cell, bp+440, uint8(Dtrue))
			if bboxErr != 0 {
				iterErrorPolygonCompact(tls, iter, bboxErr)
				return
			}
			if XbboxOverlapsBBox(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes, bp+440) != 0 {
				// Quick check for possible containment
				if XbboxContainsBBox(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes, bp+440) != 0 {
					*(*TCellBoundary)(unsafe.Pointer(bp + 472 /* bboxBoundary */)) = XbboxToCellBoundary(tls, bp+440)
					// Do a fine-grained, more expensive check on the polygon
					if XcellBoundaryInsidePolygon(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes,
						bp+472, bp+440) != 0 {
						// Bounding box is fully contained, so all children are
						// included. Set to next output.
						(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Fcell = cell
						return
					}
				}
				// Otherwise, the intersecting bbox means we need to test all
				// children, starting with the first child
				// var child uint64 at bp+640, 8

				var childErr uint32 = XcellToCenterChild(tls, cell, cellRes+1, bp+640)
				if childErr != 0 {
					iterErrorPolygonCompact(tls, iter, childErr)
					return
				}
				// Restart the loop with the child cell
				cell = *(*uint64)(unsafe.Pointer(bp + 640 /* child */))
				continue
			}
		}

		// Find the next cell in the sequence of all cells and continue
		cell = nextCell(tls, cell)
	}
	// If we make it out of the loop, we're done
	XiterDestroyPolygonCompact(tls, iter)
}

var __func__24 = *(*[23]int8)(unsafe.Pointer(ts + 1715)) /* polyfill.c:408:60 */

// *
// Destroy an iterator, releasing any allocated memory. Iterators destroyed in
// this manner are safe to use but will always return H3_NULL.
// @param  iter Iterator to destroy
func XiterDestroyPolygonCompact(tls *libc.TLS, iter uintptr) { /* polyfill.c:597:6: */
	if (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes != 0 {
		libc.Xfree(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes)
	}
	(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Fcell = uint64(DH3_NULL)
	(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).Ferror = E_SUCCESS
	(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_polygon = uintptr(0)
	(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_res = -1
	(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_flags = uint32(0)
	(*TIterCellsPolygonCompact)(unsafe.Pointer(iter)).F_bboxes = uintptr(0)
}

// *
// Initialize a IterCellsPolygon struct representing the sequence of
// cells within the target polygon. The test for including edge cells is defined
// by the polyfill mode passed in the `flags` argument.
//
// Initialization of this object may fail, in which case the `error` property
// will be set and all iteration will return H3_NULL. It is the responsibility
// of the caller to check the error property after initialization.
//
// At any point in the iteration, starting once the struct is initialized, the
// output value can be accessed through the `cell` property.
//
// Note that initializing the iterator allocates memory. If an iterator is
// exhausted or returns an error that memory is released; otherwise it must be
// released manually with iterDestroyPolygon.
//
// @param  polygon Polygon to fill with cells
// @param  res     Resolution for output cells
// @param  flags   Bit mask of option flags
// @return         Initialized iterator, with the first value available
func XiterInitPolygon(tls *libc.TLS, polygon uintptr, res int32, flags uint32) TIterCellsPolygon { /* polyfill.c:630:18: */
	// Create the sub-iterator for compact cells
	var cellIter = XiterInitPolygonCompact(tls, polygon, res, flags)
	// Create the sub-iterator for children
	var childIter = XiterInitParent(tls, cellIter.Fcell, res)

	var iter = TIterCellsPolygon{Fcell: childIter.Fh, Ferror: cellIter.Ferror, F_cellIter: cellIter, F_childIter: childIter}
	return iter
}

// *
// Increment the polyfill iterator, outputting the latest cell at the
// desired resolution.
//
// @param  iter Iterator to increment
func XiterStepPolygon(tls *libc.TLS, iter uintptr) { /* polyfill.c:651:6: */
	if (*TIterCellsPolygon)(unsafe.Pointer(iter)).Fcell == uint64(DH3_NULL) {
		return
	}

	// See if there are more children to output
	XiterStepChild(tls, iter+64)
	if (*TIterCellsPolygon)(unsafe.Pointer(iter)).F_childIter.Fh != 0 {
		(*TIterCellsPolygon)(unsafe.Pointer(iter)).Fcell = (*TIterCellsPolygon)(unsafe.Pointer(iter)).F_childIter.Fh
		return
	}

	// Otherwise, increment the polyfill iterator
	XiterStepPolygonCompact(tls, iter+16)
	if (*TIterCellsPolygon)(unsafe.Pointer(iter)).F_cellIter.Fcell != 0 {
		X_iterInitParent(tls, (*TIterCellsPolygon)(unsafe.Pointer(iter)).F_cellIter.Fcell, (*TIterCellsPolygon)(unsafe.Pointer(iter)).F_cellIter.F_res,
			iter+64)
		(*TIterCellsPolygon)(unsafe.Pointer(iter)).Fcell = (*TIterCellsPolygon)(unsafe.Pointer(iter)).F_childIter.Fh
		return
	}

	// All done, set to null and report errors if any
	(*TIterCellsPolygon)(unsafe.Pointer(iter)).Fcell = uint64(DH3_NULL)
	(*TIterCellsPolygon)(unsafe.Pointer(iter)).Ferror = (*TIterCellsPolygon)(unsafe.Pointer(iter)).F_cellIter.Ferror
}

// *
// Destroy an iterator, releasing any allocated memory. Iterators destroyed in
// this manner are safe to use but will always return H3_NULL.
// @param  iter Iterator to destroy
func XiterDestroyPolygon(tls *libc.TLS, iter uintptr) { /* polyfill.c:680:6: */
	XiterDestroyPolygonCompact(tls, iter+16)
	// null out the child iterator by passing H3_NULL
	X_iterInitParent(tls, uint64(DH3_NULL), 0, iter+64)
	(*TIterCellsPolygon)(unsafe.Pointer(iter)).Fcell = uint64(DH3_NULL)
	(*TIterCellsPolygon)(unsafe.Pointer(iter)).Ferror = E_SUCCESS
}

// *
// polygonToCells takes a given GeoJSON-like data structure and preallocated,
// zeroed memory, and fills it with the hexagons that are contained by
// the GeoJSON-like data structure. Polygons are considered in Cartesian space.
//
// @param geoPolygon The geoloop and holes defining the relevant area
// @param res The Hexagon resolution (0-15)
// @param out The slab of zeroed memory to write to. Assumed to be big enough.
func XpolygonToCellsExperimental(tls *libc.TLS, polygon uintptr, res int32, flags uint32, out uintptr) uint32 { /* polyfill.c:697:9: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	*(*TIterCellsPolygon)(unsafe.Pointer(bp /* iter */)) = XiterInitPolygon(tls, polygon, res, flags)
	var i int64 = int64(0)
	for ; (*TIterCellsPolygon)(unsafe.Pointer(bp)).Fcell != 0; XiterStepPolygon(tls, bp) {
		*(*uint64)(unsafe.Pointer(out + uintptr(libc.PostIncInt64(&i, 1))*8)) = (*TIterCellsPolygon)(unsafe.Pointer(bp /* &iter */)).Fcell
	}
	return (*TIterCellsPolygon)(unsafe.Pointer(bp /* &iter */)).Ferror
}

var sMAX_SIZE_CELL_THRESHOLD int32 = 10 /* polyfill.c:726:12 */

func getAverageCellArea(tls *libc.TLS, res int32) float64 { /* polyfill.c:728:15: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var hexAreaKm2 float64 at bp, 8

	XgetHexagonAreaAvgKm2(tls, res, bp)
	return *(*float64)(unsafe.Pointer(bp /* hexAreaKm2 */))
}

// *
// maxPolygonToCellsSize returns the number of cells to allocate space for
// when performing a polygonToCells on the given GeoJSON-like data structure.
// @param geoPolygon A GeoJSON-like data structure indicating the poly to fill
// @param res Hexagon resolution (0-15)
// @param out number of cells to allocate for
// @return 0 (E_SUCCESS) on success.
func XmaxPolygonToCellsSizeExperimental(tls *libc.TLS, polygon uintptr, res int32, flags uint32, out uintptr) uint32 { /* polyfill.c:742:9: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// Special case: 0-vertex polygon
	if (*TGeoPolygon)(unsafe.Pointer(polygon)).Fgeoloop.FnumVerts == 0 {
		*(*int64)(unsafe.Pointer(out)) = int64(0)
		return E_SUCCESS
	}

	// Initialize the iterator without stepping, so we can adjust the res and
	// flags (after they are validated by the initialization) before we start
	*(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* iter */)) = _iterInitPolygonCompact(tls, polygon, res, flags)

	if (*TIterCellsPolygonCompact)(unsafe.Pointer(bp)).Ferror != 0 {
		return (*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* &iter */)).Ferror
	}

	// Ignore the requested flags and use the faster overlapping-bbox mode
	(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* &iter */)).F_flags = CONTAINMENT_OVERLAPPING_BBOX

	// Get a (very) rough area of the polygon bounding box
	var polygonBBox uintptr = (*TIterCellsPolygonCompact)(unsafe.Pointer(bp)).F_bboxes
	var polygonBBoxAreaKm2 float64 = XbboxHeightRads(tls, polygonBBox) * XbboxWidthRads(tls, polygonBBox) / libc.Xcos(tls, Xfmin(tls, libc.Xfabs(tls, (*TBBox)(unsafe.Pointer(polygonBBox)).Fnorth), libc.Xfabs(tls, (*TBBox)(unsafe.Pointer(polygonBBox)).Fsouth))) * 6371.007180918475 * 6371.007180918475

	// Determine the res for the size estimate, based on a (very) rough estimate
	// of the number of cells at various resolutions that would fit in the
	// polygon. All we need here is a general order of magnitude.
	for (*TIterCellsPolygonCompact)(unsafe.Pointer(bp)).F_res > 0 && polygonBBoxAreaKm2/getAverageCellArea(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(bp)).F_res-1) > float64(sMAX_SIZE_CELL_THRESHOLD) {
		(*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* &iter */)).F_res--
	}

	// Now run the polyfill, counting the output in the target res.
	// We have to take the first step outside the loop, to get the first
	// valid output cell
	XiterStepPolygonCompact(tls, bp)

	*(*int64)(unsafe.Pointer(out)) = int64(0)
	// var childrenSize int64 at bp+48, 8

	for ; (*TIterCellsPolygonCompact)(unsafe.Pointer(bp)).Fcell != 0; XiterStepPolygonCompact(tls, bp) {
		XcellToChildrenSize(tls, (*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* &iter */)).Fcell, res, bp+48)
		*(*int64)(unsafe.Pointer(out)) += *(*int64)(unsafe.Pointer(bp + 48))
	}

	return (*TIterCellsPolygonCompact)(unsafe.Pointer(bp /* &iter */)).Ferror
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright 2016-2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright 2016-2017, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2017-2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file linkedGeo.h
// @brief   Linked data structure for geo data

// Define macros used in polygon algos for GeoLoop

// Copyright 2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file
// @brief Include file for poylgon algorithms. This includes the core
//        logic for algorithms acting over loops of coordinates,
//        allowing them to be reused for both GeoLoop and
//        LinkegGeoLoop structures. This file is intended to be
//        included inline in a file that defines the type-specific
//        macros required for iteration.

// Copyright (C) 2002-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  5.2.4.2.2  Characteristics of floating types <float.h>

// Declarations for math functions.
//    Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.12 Mathematics	<math.h>

// Copyright (C) 1998-2021 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.16  Boolean type and values  <stdbool.h>

// Copyright 2016-2017, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file bbox.h
// @brief   Geographic bounding box functions

// Copyright 2016-2017, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file constants.h
// @brief   Constants used by more than one source code file.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// Copyright 2017-2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file linkedGeo.h
// @brief   Linked data structure for geo data

// Copyright 2018, 2020-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file polygon.h
// @brief Polygon algorithms

//* Macro: Normalize longitude, dealing with transmeridian arcs

// *
// pointInside is the core loop of the point-in-poly algorithm
// @param loop  The loop to check
// @param bbox  The bbox for the loop being tested
// @param coord The coordinate to check
// @return      Whether the point is contained
func XpointInsideGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr, coord uintptr) uint8 { /* polygonAlgos.h:67:6: */
	// fail fast if we're outside the bounding box
	if !(XbboxContains(tls, bbox, coord) != 0) {
		return uint8(Dfalse)
	}
	var isTransmeridian uint8 = XbboxIsTransmeridian(tls, bbox)
	var contains uint8 = uint8(Dfalse)

	var lat float64 = (*TLatLng)(unsafe.Pointer(coord)).Flat
	var lng float64 = func() float64 {
		if isTransmeridian != 0 && (*TLatLng)(unsafe.Pointer(coord)).Flng < float64(0) {
			return (*TLatLng)(unsafe.Pointer(coord)).Flng + 6.28318530717958647692528676655900576839433
		}
		return (*TLatLng)(unsafe.Pointer(coord)).Flng
	}()
	var a TLatLng
	var b TLatLng

	var loopIndex int32 = -1

	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		a = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		b = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts)*16))

		// Ray casting algo requires the second point to always be higher
		// than the first, so swap if needed
		if a.Flat > b.Flat {
			var tmp = a
			a = b
			b = tmp
		}

		// If the latitude matches exactly, we'll hit an edge case where
		// the ray passes through the vertex twice on successive segment
		// checks. To avoid this, adjust the latiude northward if needed.
		//
		// NOTE: This currently means that a point at the north pole cannot
		// be contained in any polygon. This is acceptable in current usage,
		// because the point we test in this function at present is always
		// a cell center or vertex, and no cell has a center or vertex on the
		// north pole. If we need to expand this algo to more generic uses we
		// might need to handle this edge case.
		if lat == a.Flat || lat == b.Flat {
			lat = lat + 2.22044604925031308084726333618164062e-16
		}

		// If we're totally above or below the latitude ranges, the test
		// ray cannot intersect the line segment, so let's move on
		if lat < a.Flat || lat > b.Flat {
			continue
		}

		var aLng float64 = func() float64 {
			if isTransmeridian != 0 && a.Flng < float64(0) {
				return a.Flng + 6.28318530717958647692528676655900576839433
			}
			return a.Flng
		}()
		var bLng float64 = func() float64 {
			if isTransmeridian != 0 && b.Flng < float64(0) {
				return b.Flng + 6.28318530717958647692528676655900576839433
			}
			return b.Flng
		}()

		// Rays are cast in the longitudinal direction, in case a point
		// exactly matches, to decide tiebreakers, bias westerly
		if aLng == lng || bLng == lng {
			lng = lng - 2.22044604925031308084726333618164062e-16
		}

		// For the latitude of the point, compute the longitude of the
		// point that lies on the line segment defined by a and b
		// This is done by computing the percent above a the lat is,
		// and traversing the same percent in the longitudinal direction
		// of a to b
		var ratio float64 = (lat - a.Flat) / (b.Flat - a.Flat)
		var testLng float64 = func() float64 {
			if isTransmeridian != 0 && aLng+(bLng-aLng)*ratio < float64(0) {
				return aLng + (bLng-aLng)*ratio + 6.28318530717958647692528676655900576839433
			}
			return aLng + (bLng-aLng)*ratio
		}()

		// Intersection of the ray
		if testLng > lng {
			contains = libc.BoolUint8(!(contains != 0))
		}
	}

	return contains
}

// *
// Create a bounding box from a simple polygon loop.
// Known limitations:
//   - Does not support polygons with two adjacent points > 180 degrees of
//     longitude apart. These will be interpreted as crossing the antimeridian.
//   - Does not currently support polygons containing a pole.
//
// @param loop     Loop of coordinates
// @param bbox     Output bbox
func XbboxFromGeoLoop(tls *libc.TLS, loop uintptr, bbox uintptr) { /* polygonAlgos.h:151:6: */
	// Early exit if there are no vertices
	if (*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts == 0 {
		*(*TBBox)(unsafe.Pointer(bbox)) = TBBox{}
		return
	}

	(*TBBox)(unsafe.Pointer(bbox)).Fsouth = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fwest = 1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Fnorth = -1.79769313486231570814527423731704357e+308
	(*TBBox)(unsafe.Pointer(bbox)).Feast = -1.79769313486231570814527423731704357e+308
	var minPosLng float64 = 1.79769313486231570814527423731704357e+308
	var maxNegLng float64 = -1.79769313486231570814527423731704357e+308
	var isTransmeridian uint8 = uint8(Dfalse)
	var lat float64
	var lng float64
	var coord TLatLng
	var next TLatLng

	var loopIndex int32 = -1

	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		coord = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		next = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts)*16))

		lat = coord.Flat
		lng = coord.Flng
		if lat < (*TBBox)(unsafe.Pointer(bbox)).Fsouth {
			(*TBBox)(unsafe.Pointer(bbox)).Fsouth = lat
		}
		if lng < (*TBBox)(unsafe.Pointer(bbox)).Fwest {
			(*TBBox)(unsafe.Pointer(bbox)).Fwest = lng
		}
		if lat > (*TBBox)(unsafe.Pointer(bbox)).Fnorth {
			(*TBBox)(unsafe.Pointer(bbox)).Fnorth = lat
		}
		if lng > (*TBBox)(unsafe.Pointer(bbox)).Feast {
			(*TBBox)(unsafe.Pointer(bbox)).Feast = lng
		}
		// Save the min positive and max negative longitude for
		// use in the transmeridian case
		if lng > float64(0) && lng < minPosLng {
			minPosLng = lng
		}
		if lng < float64(0) && lng > maxNegLng {
			maxNegLng = lng
		}
		// check for arcs > 180 degrees longitude, flagging as transmeridian
		if libc.Xfabs(tls, lng-next.Flng) > 3.14159265358979323846 {
			isTransmeridian = uint8(Dtrue)
		}
	}
	// Swap east and west if transmeridian
	if isTransmeridian != 0 {
		(*TBBox)(unsafe.Pointer(bbox)).Feast = maxNegLng
		(*TBBox)(unsafe.Pointer(bbox)).Fwest = minPosLng
	}
}

// *
// Whether the winding order of a given loop is clockwise, with normalization
// for loops crossing the antimeridian.
// @param loop              The loop to check
// @param isTransmeridian   Whether the loop crosses the antimeridian
// @return                  Whether the loop is clockwise
func isClockwiseNormalizedGeoLoop(tls *libc.TLS, loop uintptr, isTransmeridian uint8) uint8 { /* polygonAlgos.h:205:13: */
	var sum float64 = float64(0)
	var a TLatLng
	var b TLatLng

	var loopIndex int32 = -1
	for 1 != 0 {
		if libc.PreIncInt32(&loopIndex, 1) >= (*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts {
			break
		}
		a = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr(loopIndex)*16))
		b = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(loop)).Fverts + uintptr((loopIndex+1)%(*TGeoLoop)(unsafe.Pointer(loop)).FnumVerts)*16))
		// If we identify a transmeridian arc (> 180 degrees longitude),
		// start over with the transmeridian flag set
		if !(isTransmeridian != 0) && libc.Xfabs(tls, a.Flng-b.Flng) > 3.14159265358979323846 {
			return isClockwiseNormalizedGeoLoop(tls, loop, uint8(Dtrue))
		}
		sum = sum + (func() float64 {
			if isTransmeridian != 0 && b.Flng < float64(0) {
				return b.Flng + 6.28318530717958647692528676655900576839433
			}
			return b.Flng
		}()-func() float64 {
			if isTransmeridian != 0 && a.Flng < float64(0) {
				return a.Flng + 6.28318530717958647692528676655900576839433
			}
			return a.Flng
		}())*(b.Flat+a.Flat)
	}

	return uint8(libc.Bool32(sum > float64(0)))
}

// *
// Whether the winding order of a given loop is clockwise. In GeoJSON,
// clockwise loops are always inner loops (holes).
// @param loop  The loop to check
// @return      Whether the loop is clockwise
func XisClockwiseGeoLoop(tls *libc.TLS, loop uintptr) uint8 { /* polygonAlgos.h:233:6: */
	return isClockwiseNormalizedGeoLoop(tls, loop, uint8(Dfalse))
}

// *
// Whether the flags for the polyfill operation are valid
// TODO: Move to polyfill.c when the old algo is removed
// @param  flags Flags to validate
// @return       Whether the flags are valid
func XvalidatePolygonFlags(tls *libc.TLS, flags uint32) uint32 { /* polygon.c:51:9: */
	if flags&libc.CplUint32(uint32(15)) != 0 || flags&uint32(15) >= CONTAINMENT_INVALID {
		return E_OPTION_INVALID
	}
	return E_SUCCESS
}

// *
// Create a bounding box from a GeoPolygon
// @param polygon Input GeoPolygon
// @param bboxes  Output bboxes, one for the outer loop and one for each hole
func XbboxesFromGeoPolygon(tls *libc.TLS, polygon uintptr, bboxes uintptr) { /* polygon.c:64:6: */
	XbboxFromGeoLoop(tls, polygon, bboxes)
	{
		var i int32 = 0
		for ; i < (*TGeoPolygon)(unsafe.Pointer(polygon)).FnumHoles; i++ {
			XbboxFromGeoLoop(tls, (*TGeoPolygon)(unsafe.Pointer(polygon)).Fholes+uintptr(i)*16, bboxes+uintptr(i+1)*32)
		}
	}
}

// *
// pointInsidePolygon takes a given GeoPolygon data structure and
// checks if it contains a given geo coordinate.
//
// @param geoPolygon The geoloop and holes defining the relevant area
// @param bboxes     The bboxes for the main geoloop and each of its holes
// @param coord      The coordinate to check
// @return           Whether the point is contained
func XpointInsidePolygon(tls *libc.TLS, geoPolygon uintptr, bboxes uintptr, coord uintptr) uint8 { /* polygon.c:80:6: */
	// Start with contains state of primary geoloop
	var contains uint8 = XpointInsideGeoLoop(tls, geoPolygon, bboxes, coord)

	// If the point is contained in the primary geoloop, but there are holes in
	// the geoloop iterate through all holes and return false if the point is
	// contained in any hole
	if contains != 0 && (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles > 0 {
		{
			var i int32 = 0
			for ; i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles; i++ {
				if XpointInsideGeoLoop(tls, (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16, bboxes+uintptr(i+1)*32,
					coord) != 0 {
					return uint8(Dfalse)
				}
			}
		}
	}

	return contains
}

// *
// Whether a cell boundary is completely contained by a polygon.
// @param  geoPolygon The polygon to test
// @param  bboxes     The bboxes for the main geoloop and each of its holes
// @param  boundary   The cell boundary to test
// @return            Whether the cell boundary is contained
func XcellBoundaryInsidePolygon(tls *libc.TLS, geoPolygon uintptr, bboxes uintptr, boundary uintptr, boundaryBBox uintptr) uint8 { /* polygon.c:108:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// First test a single point. Note that this fails fast if point is outside
	// bounding box.
	if !(XpointInsidePolygon(tls, geoPolygon, bboxes, boundary+8) != 0) {
		return uint8(Dfalse)
	}

	// If a point is contained, check for any line intersections
	if XcellBoundaryCrossesGeoLoop(tls, geoPolygon, bboxes, boundary,
		boundaryBBox) != 0 {
		return uint8(Dfalse)
	}

	// Convert boundary to geoloop for point-inside check
	*(*TGeoLoop)(unsafe.Pointer(bp /* boundaryLoop */)) = TGeoLoop{FnumVerts: (*TCellBoundary)(unsafe.Pointer(boundary)).FnumVerts, Fverts: boundary + 8 /* &.verts */}

	// Check for line intersections with, or containment of, any hole
	{
		var i int32 = 0
		for ; i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles; i++ {
			// If the hole has no verts, it is not possible to intersect with it.
			if (*TGeoLoop)(unsafe.Pointer((*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16)).FnumVerts > 0 && (XpointInsideGeoLoop(tls, bp, boundaryBBox,
				(*TGeoLoop)(unsafe.Pointer((*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16)).Fverts) != 0 || XcellBoundaryCrossesGeoLoop(tls, (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16, bboxes+uintptr(i+1)*32,
				boundary, boundaryBBox) != 0) {
				return uint8(Dfalse)
			}
		}
	}
	return uint8(Dtrue)
}

// *
// Whether any part of a cell boundary crosses a polygon. Crossing in this case
// means whether any line segments intersect; it does not include containment.
// @param  geoPolygon The polygon to test
// @param  bboxes     The bboxes for the main geoloop and each of its holes
// @param  boundary   The cell boundary to test
// @return            Whether the cell boundary is contained
func XcellBoundaryCrossesPolygon(tls *libc.TLS, geoPolygon uintptr, bboxes uintptr, boundary uintptr, boundaryBBox uintptr) uint8 { /* polygon.c:153:6: */
	// Check for line intersections with outer loop
	if XcellBoundaryCrossesGeoLoop(tls, geoPolygon, bboxes, boundary,
		boundaryBBox) != 0 {
		return uint8(Dtrue)
	}
	// Check for line intersections with any hole
	{
		var i int32 = 0
		for ; i < (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).FnumHoles; i++ {
			if XcellBoundaryCrossesGeoLoop(tls, (*TGeoPolygon)(unsafe.Pointer(geoPolygon)).Fholes+uintptr(i)*16, bboxes+uintptr(i+1)*32,
				boundary, boundaryBBox) != 0 {
				return uint8(Dtrue)
			}
		}
	}
	return uint8(Dfalse)
}

// *
// Whether a cell boundary crosses a geo loop. Crossing in this case means
// whether any line segments intersect; it does not include containment.
// @param  geoloop  Geo loop to test
// @param  boundary Cell boundary to test
// @return          Whether any line segments in the boundary intersect any line
// segments in the geo loop
func XcellBoundaryCrossesGeoLoop(tls *libc.TLS, geoloop uintptr, loopBBox uintptr, boundary uintptr, boundaryBBox uintptr) uint8 { /* polygon.c:180:6: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	if !(XbboxOverlapsBBox(tls, loopBBox, boundaryBBox) != 0) {
		return uint8(Dfalse)
	}
	// var loopNormalization uint32 at bp, 4

	// var boundaryNormalization uint32 at bp+4, 4

	XbboxNormalization(tls, loopBBox, boundaryBBox, bp,
		bp+4)

	*(*TCellBoundary)(unsafe.Pointer(bp + 8 /* normalBoundary */)) = *(*TCellBoundary)(unsafe.Pointer(boundary))
	{
		var i int32 = 0
		for ; i < (*TCellBoundary)(unsafe.Pointer(boundary)).FnumVerts; i++ {
			(*TLatLng)(unsafe.Pointer(bp + 8 + 8 + uintptr(i)*16)).Flng = XnormalizeLng(tls, (*TLatLng)(unsafe.Pointer(bp+8+8+uintptr(i)*16)).Flng, *(*uint32)(unsafe.Pointer(bp + 4 /* boundaryNormalization */)))
		}
	}

	var normalBoundaryBBox = TBBox{Fnorth: (*TBBox)(unsafe.Pointer(boundaryBBox)).Fnorth, Fsouth: (*TBBox)(unsafe.Pointer(boundaryBBox)).Fsouth, Feast: XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(boundaryBBox)).Feast, *(*uint32)(unsafe.Pointer(bp + 4 /* boundaryNormalization */))), Fwest: XnormalizeLng(tls, (*TBBox)(unsafe.Pointer(boundaryBBox)).Fwest, *(*uint32)(unsafe.Pointer(bp + 4 /* boundaryNormalization */)))}
	// var loop1 TLatLng at bp+176, 16

	// var loop2 TLatLng at bp+192, 16

	{
		var i1 int32 = 0
		for ; i1 < (*TGeoLoop)(unsafe.Pointer(geoloop)).FnumVerts; i1++ {
			*(*TLatLng)(unsafe.Pointer(bp + 176 /* loop1 */)) = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(geoloop)).Fverts + uintptr(i1)*16))
			(*TLatLng)(unsafe.Pointer(bp + 176 /* &loop1 */)).Flng = XnormalizeLng(tls, (*TLatLng)(unsafe.Pointer(bp+176 /* &loop1 */)).Flng, *(*uint32)(unsafe.Pointer(bp /* loopNormalization */)))
			*(*TLatLng)(unsafe.Pointer(bp + 192 /* loop2 */)) = *(*TLatLng)(unsafe.Pointer((*TGeoLoop)(unsafe.Pointer(geoloop)).Fverts + uintptr((i1+1)%(*TGeoLoop)(unsafe.Pointer(geoloop)).FnumVerts)*16))
			(*TLatLng)(unsafe.Pointer(bp + 192 /* &loop2 */)).Flng = XnormalizeLng(tls, (*TLatLng)(unsafe.Pointer(bp+192 /* &loop2 */)).Flng, *(*uint32)(unsafe.Pointer(bp /* loopNormalization */)))

			// Quick check if the line segment overlaps our bbox
			if (*TLatLng)(unsafe.Pointer(bp+176)).Flat >= normalBoundaryBBox.Fnorth && (*TLatLng)(unsafe.Pointer(bp+192)).Flat >= normalBoundaryBBox.Fnorth || (*TLatLng)(unsafe.Pointer(bp+176)).Flat <= normalBoundaryBBox.Fsouth && (*TLatLng)(unsafe.Pointer(bp+192)).Flat <= normalBoundaryBBox.Fsouth || (*TLatLng)(unsafe.Pointer(bp+176)).Flng <= normalBoundaryBBox.Fwest && (*TLatLng)(unsafe.Pointer(bp+192)).Flng <= normalBoundaryBBox.Fwest || (*TLatLng)(unsafe.Pointer(bp+176)).Flng >= normalBoundaryBBox.Feast && (*TLatLng)(unsafe.Pointer(bp+192)).Flng >= normalBoundaryBBox.Feast {
				continue
			}

			{
				var j int32 = 0
				for ; j < (*TCellBoundary)(unsafe.Pointer(bp+8)).FnumVerts; j++ {
					if XlineCrossesLine(tls,
						bp+176, bp+192, bp+8+8+uintptr(j)*16,
						bp+8+8+uintptr((j+1)%(*TCellBoundary)(unsafe.Pointer(bp+8)).FnumVerts)*16) != 0 {
						return uint8(Dtrue)
					}
				}
			}
		}
	}
	return uint8(Dfalse)
}

// *
// Whether two lines intersect. This is a purely Cartesian implementation
// and does not consider anti-meridian wrapping, poles, etc. Based on
// http://www.jeffreythompson.org/collision-detection/line-line.php
// @param  a1 Start of line A
// @param  a2 End of line A
// @param  b1 Start of line B
// @param  b2 End of line B
// @return    Whether the lines intersect
func XlineCrossesLine(tls *libc.TLS, a1 uintptr, a2 uintptr, b1 uintptr, b2 uintptr) uint8 { /* polygon.c:244:6: */
	var denom float64 = ((*TLatLng)(unsafe.Pointer(b2)).Flng-(*TLatLng)(unsafe.Pointer(b1)).Flng)*((*TLatLng)(unsafe.Pointer(a2)).Flat-(*TLatLng)(unsafe.Pointer(a1)).Flat) - ((*TLatLng)(unsafe.Pointer(b2)).Flat-(*TLatLng)(unsafe.Pointer(b1)).Flat)*((*TLatLng)(unsafe.Pointer(a2)).Flng-(*TLatLng)(unsafe.Pointer(a1)).Flng)
	if !(denom != 0) {
		return uint8(Dfalse)
	}
	var test float64
	test = (((*TLatLng)(unsafe.Pointer(b2)).Flat-(*TLatLng)(unsafe.Pointer(b1)).Flat)*((*TLatLng)(unsafe.Pointer(a1)).Flng-(*TLatLng)(unsafe.Pointer(b1)).Flng) - ((*TLatLng)(unsafe.Pointer(b2)).Flng-(*TLatLng)(unsafe.Pointer(b1)).Flng)*((*TLatLng)(unsafe.Pointer(a1)).Flat-(*TLatLng)(unsafe.Pointer(b1)).Flat)) / denom
	if test < float64(0) || test > float64(1) {
		return uint8(Dfalse)
	}

	test = (((*TLatLng)(unsafe.Pointer(a2)).Flat-(*TLatLng)(unsafe.Pointer(a1)).Flat)*((*TLatLng)(unsafe.Pointer(a1)).Flng-(*TLatLng)(unsafe.Pointer(b1)).Flng) - ((*TLatLng)(unsafe.Pointer(a2)).Flng-(*TLatLng)(unsafe.Pointer(a1)).Flng)*((*TLatLng)(unsafe.Pointer(a1)).Flat-(*TLatLng)(unsafe.Pointer(b1)).Flat)) / denom
	return uint8(libc.Bool32(test >= float64(0) && test <= float64(1)))
}

// If we are compiling with optimizing read this file.  It contains
//    several optimizing inline functions and macros.

// Macros to control TS 18661-3 glibc features on x86.
//    Copyright (C) 2017-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// *
// Calculates the magnitude of a 2D cartesian vector.
// @param v The 2D cartesian vector.
// @return The magnitude of the vector.
func X_v2dMag(tls *libc.TLS, v uintptr) float64 { /* vec2d.c:31:8: */
	return libc.Xsqrt(tls, (*TVec2d)(unsafe.Pointer(v)).Fx*(*TVec2d)(unsafe.Pointer(v)).Fx+(*TVec2d)(unsafe.Pointer(v)).Fy*(*TVec2d)(unsafe.Pointer(v)).Fy)
}

// *
// Finds the intersection between two lines. Assumes that the lines intersect
// and that the intersection is not at an endpoint of either line.
// @param p0 The first endpoint of the first line.
// @param p1 The second endpoint of the first line.
// @param p2 The first endpoint of the second line.
// @param p3 The second endpoint of the second line.
// @param inter The intersection point.
func X_v2dIntersect(tls *libc.TLS, p0 uintptr, p1 uintptr, p2 uintptr, p3 uintptr, inter uintptr) { /* vec2d.c:42:6: */
	var s1 TVec2d
	var s2 TVec2d
	s1.Fx = (*TVec2d)(unsafe.Pointer(p1)).Fx - (*TVec2d)(unsafe.Pointer(p0)).Fx
	s1.Fy = (*TVec2d)(unsafe.Pointer(p1)).Fy - (*TVec2d)(unsafe.Pointer(p0)).Fy
	s2.Fx = (*TVec2d)(unsafe.Pointer(p3)).Fx - (*TVec2d)(unsafe.Pointer(p2)).Fx
	s2.Fy = (*TVec2d)(unsafe.Pointer(p3)).Fy - (*TVec2d)(unsafe.Pointer(p2)).Fy
	var t float64
	t = (s2.Fx*((*TVec2d)(unsafe.Pointer(p0)).Fy-(*TVec2d)(unsafe.Pointer(p2)).Fy) - s2.Fy*((*TVec2d)(unsafe.Pointer(p0)).Fx-(*TVec2d)(unsafe.Pointer(p2)).Fx)) / (-s2.Fx*s1.Fy + s1.Fx*s2.Fy)

	(*TVec2d)(unsafe.Pointer(inter)).Fx = (*TVec2d)(unsafe.Pointer(p0)).Fx + t*s1.Fx
	(*TVec2d)(unsafe.Pointer(inter)).Fy = (*TVec2d)(unsafe.Pointer(p0)).Fy + t*s1.Fy
}

// *
// Whether two 2D vectors are almost equal, within some threshold
// @param v1 First vector to compare
// @param v2 Second vector to compare
// @return Whether the vectors are almost equal
func X_v2dAlmostEquals(tls *libc.TLS, v1 uintptr, v2 uintptr) uint8 { /* vec2d.c:64:6: */
	return uint8(libc.Bool32(libc.Xfabs(tls, (*TVec2d)(unsafe.Pointer(v1)).Fx-(*TVec2d)(unsafe.Pointer(v2)).Fx) < 1.19209289550781250000000000000000000e-7 && libc.Xfabs(tls, (*TVec2d)(unsafe.Pointer(v1)).Fy-(*TVec2d)(unsafe.Pointer(v2)).Fy) < 1.19209289550781250000000000000000000e-7))
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// *
// Square of a number
//
// @param x The input number.
// @return The square of the input number.
func X_square(tls *libc.TLS, x float64) float64 { /* vec3d.c:30:8: */
	return x * x
}

// *
// Calculate the square of the distance between two 3D coordinates.
//
// @param v1 The first 3D coordinate.
// @param v2 The second 3D coordinate.
// @return The square of the distance between the given points.
func X_pointSquareDist(tls *libc.TLS, v1 uintptr, v2 uintptr) float64 { /* vec3d.c:39:8: */
	return X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fx-(*TVec3d)(unsafe.Pointer(v2)).Fx) + X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fy-(*TVec3d)(unsafe.Pointer(v2)).Fy) + X_square(tls, (*TVec3d)(unsafe.Pointer(v1)).Fz-(*TVec3d)(unsafe.Pointer(v2)).Fz)
}

// *
// Calculate the 3D coordinate on unit sphere from the latitude and longitude.
//
// @param geo The latitude and longitude of the point.
// @param v The 3D coordinate of the point.
func X_geoToVec3d(tls *libc.TLS, geo uintptr, v uintptr) { /* vec3d.c:50:6: */
	var r float64 = libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(geo)).Flat)

	(*TVec3d)(unsafe.Pointer(v)).Fz = libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(geo)).Flat)
	(*TVec3d)(unsafe.Pointer(v)).Fx = libc.Xcos(tls, (*TLatLng)(unsafe.Pointer(geo)).Flng) * r
	(*TVec3d)(unsafe.Pointer(v)).Fy = libc.Xsin(tls, (*TLatLng)(unsafe.Pointer(geo)).Flng) * r
}

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file faceijk.h
// @brief   FaceIJK functions including conversion to/from lat/lng.
//
//  References the Vec2d cartesian coordinate systems hex2d: local face-centered
//     coordinate system scaled a specific H3 grid resolution unit length and
//     with x-axes aligned with the local i-axes

// Copyright 2022 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3Assert.h
// @brief   Support code for unit testing and assertions
//
// This file defines macros needed for defensive programming in the H3 core
// library. H3 strives to have complete code and branch coverage, but this is
// not feasible if some branches cannot be reached because they are defensive -
// that is, we do not know of a test case that would exercise the branch but we
// do have an opinion of how to recover from such an error. These defensive
// branches are excluded from coverage.
//
// In other testing, such as unit tests or fuzzer testing, they trigger
// assertions if the conditions fail.
//
// Adapted from https://www.sqlite.org/testing.html and
// https://www.sqlite.org/assert.html
//
// Used under the terms of the SQLite3 project, reproduced below:
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.2 Diagnostics	<assert.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

// void assert (int expression);
//
//    If NDEBUG is defined, do nothing.
//    If not, and EXPRESSION is zero, print an error message and abort.

// When possible, define assert so that it does not add extra
//    parentheses around EXPR.  Otherwise, those added parentheses would
//    suppress warnings we'd expect to be detected by gcc's -Wparentheses.
// The first occurrence of EXPR is not evaluated due to the sizeof,
//    but will trigger any pedantic warnings masked by the __extension__
//    for the second occurrence.  The ternary operator is required to
//    support function pointers and bit fields in this context, and to
//    suppress the evaluation of variable length arrays.

// Version 2.4 and later of GCC define a magical variable `__PRETTY_FUNCTION__'
//    which contains the name of the function currently being defined.
//    This is broken in G++ before version 2.6.
//    C9x has a similar variable called __func__, but prefer the GCC one since
//    it demangles C++ function names.

// The testcase() macro is used to aid in coverage testing.  When
// doing coverage testing, the condition inside the argument to
// testcase() must be evaluated both true and false in order to
// get full branch coverage.  The testcase() macro is inserted
// to help ensure adequate test coverage in places where simple
// condition/decision coverage is inadequate.  For example, testcase()
// can be used to make sure boundary values are tested.  For
// bitmask tests, testcase() can be used to make sure each bit
// is significant and used at least once.  On switch statements
// where multiple cases go to the same block of code, testcase()
// can insure that all cases are evaluated.

// Disable ALWAYS() and NEVER() (make them pass-throughs) for coverage
// and mutation testing

// The TESTONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within testcase() and assert() macros.

// The DEFENSEONLY macro is used to enclose variable declarations or
// other bits of code that are needed to support the arguments
// within ALWAYS() or NEVER() macros.

// The ALWAYS and NEVER macros surround boolean expressions which
// are intended to always be true or false, respectively.  Such
// expressions could be omitted from the code completely.  But they
// are included in a few cases in order to enhance the resilience
// of the H3 library to unexpected behavior - to make the code "self-healing"
// or "ductile" rather than being "brittle" and crashing at the first
// hint of unplanned behavior.
//
// In other words, ALWAYS and NEVER are added for defensive code.
//
// When doing coverage testing ALWAYS and NEVER are hard-coded to
// be true and false so that the unreachable code they specify will
// not be counted as untested code.

// Copyright 2016-2018, 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3Index.h
// @brief   H3Index functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// * @brief Table of direction-to-face mapping for each pentagon
//
// Note that faces are in directional order, starting at J_AXES_DIGIT.
// This table is generated by the generatePentagonDirectionFaces script.
var pentagonDirectionFaces = [12]TPentagonDirectionFaces{
	{FbaseCell: 4, Ffaces: [5]int32{4, 0, 2, 1, 3}}, {FbaseCell: 14, Ffaces: [5]int32{6, 11, 2, 7, 1}},
	{FbaseCell: 24, Ffaces: [5]int32{5, 10, 1, 6, 0}}, {FbaseCell: 38, Ffaces: [5]int32{7, 12, 3, 8, 2}},
	{FbaseCell: 49, Ffaces: [5]int32{9, 14, 0, 5, 4}}, {FbaseCell: 58, Ffaces: [5]int32{8, 13, 4, 9, 3}},
	{FbaseCell: 63, Ffaces: [5]int32{11, 6, 15, 10, 16}}, {FbaseCell: 72, Ffaces: [5]int32{12, 7, 16, 11, 17}},
	{FbaseCell: 83, Ffaces: [5]int32{10, 5, 19, 14, 15}}, {FbaseCell: 97, Ffaces: [5]int32{13, 8, 17, 12, 18}},
	{FbaseCell: 107, Ffaces: [5]int32{14, 9, 18, 13, 19}}, {FbaseCell: 117, Ffaces: [5]int32{15, 19, 17, 18, 16}},
} /* vertex.c:39:37 */

// *
// Get the number of CCW rotations of the cell's vertex numbers
// compared to the directional layout of its neighbors.
// @param out Number of CCW rotations for the cell
func vertexRotations(tls *libc.TLS, cell uint64, out uintptr) uint32 { /* vertex.c:53:16: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// Get the face and other info for the origin
	// var fijk TFaceIJK at bp, 16

	var err uint32 = X_h3ToFaceIjk(tls, cell, bp)
	if err != 0 {
		return err
	}
	var baseCell int32 = XgetBaseCellNumber(tls, cell)
	var cellLeadingDigit int32 = int32(X_h3LeadingNonZeroDigit(tls, cell))

	// get the base cell face
	// var baseFijk TFaceIJK at bp+16, 16

	X_baseCellToFaceIjk(tls, baseCell, bp+16)

	var ccwRot60 int32 = X_baseCellToCCWrot60(tls, baseCell, (*TFaceIJK)(unsafe.Pointer(bp /* &fijk */)).Fface)

	if X_isBaseCellPentagon(tls, baseCell) != 0 {
		// Find the appropriate direction-to-face mapping
		// var dirFaces TPentagonDirectionFaces at bp+32, 24

		// We never hit the end condition
		var p int32 = 0
		for ; p < DNUM_PENTAGONS; p++ {
			if pentagonDirectionFaces[p].FbaseCell == baseCell {
				*(*TPentagonDirectionFaces)(unsafe.Pointer(bp + 32 /* dirFaces */)) = pentagonDirectionFaces[p]
				break
			}
		}
		if p == DNUM_PENTAGONS {
			return E_FAILED
		}

		// additional CCW rotation for polar neighbors or IK neighbors
		if (*TFaceIJK)(unsafe.Pointer(bp)).Fface != (*TFaceIJK)(unsafe.Pointer(bp+16)).Fface && (X_isBaseCellPolarPentagon(tls, baseCell) != 0 || (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 3*4))) {
			ccwRot60 = (ccwRot60 + 1) % 6
		}

		// Check whether the cell crosses a deleted pentagon subsequence
		if cellLeadingDigit == JK_AXES_DIGIT && (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 3*4)) {
			// Crosses from JK to IK: Rotate CW
			ccwRot60 = (ccwRot60 + 5) % 6
		} else if cellLeadingDigit == IK_AXES_DIGIT && (*TFaceIJK)(unsafe.Pointer(bp)).Fface == *(*int32)(unsafe.Pointer(bp + 32 + 4 + 1*4)) {
			// Crosses from IK to JK: Rotate CCW
			ccwRot60 = (ccwRot60 + 1) % 6
		}
	}
	*(*int32)(unsafe.Pointer(out)) = ccwRot60
	return E_SUCCESS
}

//   - @brief Hexagon direction to vertex number relationships (same face).
//     Note that we don't use direction 0 (center).
var directionToVertexNumHex = [7]int32{
	INVALID_DIGIT, 3, 1, 2, 5, 4, 0} /* vertex.c:112:18 */

//   - @brief Pentagon direction to vertex number relationships (same face).
//     Note that we don't use directions 0 (center) or 1 (deleted K axis).
var directionToVertexNumPent = [7]int32{
	INVALID_DIGIT, INVALID_DIGIT, 1, 2, 4, 3, 0} /* vertex.c:118:18 */

// *
// Get the first vertex number for a given direction. The neighbor in this
// direction is located between this vertex number and the next number in
// sequence.
// @returns The number for the first topological vertex, or INVALID_VERTEX_NUM
//
//	if the direction is not valid for this cell
func XvertexNumForDirection(tls *libc.TLS, origin uint64, direction uint32) int32 { /* vertex.c:128:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var isPent int32 = XisPentagon(tls, origin)
	// Check for invalid directions
	if direction == CENTER_DIGIT || direction >= INVALID_DIGIT || isPent != 0 && direction == K_AXES_DIGIT {
		return -1
	}

	// Determine the vertex rotations for this cell
	// var rotations int32 at bp, 4

	var err uint32 = vertexRotations(tls, origin, bp)
	if err != 0 {
		return -1
	}

	// Find the appropriate vertex, rotating CCW if necessary
	if isPent != 0 {
		return (directionToVertexNumPent[direction] + DNUM_PENT_VERTS - *(*int32)(unsafe.Pointer(bp))) % DNUM_PENT_VERTS
	} else {
		return (directionToVertexNumHex[direction] + DNUM_HEX_VERTS - *(*int32)(unsafe.Pointer(bp))) % DNUM_HEX_VERTS
	}
	return int32(0)
}

// * @brief Vertex number to hexagon direction relationships (same face).
var vertexNumToDirectionHex = [6]uint32{
	IJ_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT,
	K_AXES_DIGIT, IK_AXES_DIGIT, I_AXES_DIGIT} /* vertex.c:156:24 */

// * @brief Vertex number to pentagon direction relationships (same face).
var vertexNumToDirectionPent = [5]uint32{
	IJ_AXES_DIGIT, J_AXES_DIGIT, JK_AXES_DIGIT, IK_AXES_DIGIT, I_AXES_DIGIT} /* vertex.c:162:24 */

// *
// Get the direction for a given vertex number. This returns the direction for
// the neighbor between the given vertex number and the next number in sequence.
// @returns The direction for this vertex, or INVALID_DIGIT if the vertex
// number is invalid.
func XdirectionForVertexNum(tls *libc.TLS, origin uint64, vertexNum int32) uint32 { /* vertex.c:171:11: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var isPent int32 = XisPentagon(tls, origin)
	// Check for invalid vertexes
	if vertexNum < 0 || vertexNum > func() int32 {
		if isPent != 0 {
			return DNUM_PENT_VERTS
		}
		return DNUM_HEX_VERTS
	}()-1 {
		return INVALID_DIGIT
	}

	// Determine the vertex rotations for this cell
	// var rotations int32 at bp, 4

	var err uint32 = vertexRotations(tls, origin, bp)
	if err != 0 {
		return INVALID_DIGIT
	}

	// Find the appropriate direction, rotating CW if necessary
	if isPent != 0 {
		return vertexNumToDirectionPent[(vertexNum+*(*int32)(unsafe.Pointer(bp)))%DNUM_PENT_VERTS]
	}
	return vertexNumToDirectionHex[(vertexNum+*(*int32)(unsafe.Pointer(bp)))%DNUM_HEX_VERTS]
}

// * @brief Directions in CCW order
var sDIRECTIONS1 = [6]uint32{
	J_AXES_DIGIT, JK_AXES_DIGIT, K_AXES_DIGIT,
	IK_AXES_DIGIT, I_AXES_DIGIT, IJ_AXES_DIGIT} /* vertex.c:193:24 */

//   - @brief Reverse direction from neighbor in each direction,
//     given as an index into DIRECTIONS to facilitate rotation
var revNeighborDirectionsHex = [7]int32{
	INVALID_DIGIT, 5, 3, 4, 1, 0, 2} /* vertex.c:200:18 */

// *
// Get a single vertex for a given cell, as an H3 index, or
// H3_NULL if the vertex is invalid
// @param cell    Cell to get the vertex for
// @param vertexNum Number (index) of the vertex to calculate
func XcellToVertex(tls *libc.TLS, cell uint64, vertexNum int32, out uintptr) uint32 { /* vertex.c:209:9: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var cellIsPentagon int32 = XisPentagon(tls, cell)
	var cellNumVerts int32
	if cellIsPentagon != 0 {
		cellNumVerts = DNUM_PENT_VERTS
	} else {
		cellNumVerts = DNUM_HEX_VERTS
	}
	var res int32 = int32(cell & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	// Check for invalid vertexes
	if vertexNum < 0 || vertexNum > cellNumVerts-1 {
		return E_DOMAIN
	}

	// Default the owner and vertex number to the input cell
	var owner uint64 = cell
	var ownerVertexNum int32 = vertexNum

	// Determine the owner, looking at the three cells that share the vertex.
	// By convention, the owner is the cell with the lowest numerical index.

	// If the cell is the center child of its parent, it will always have
	// the lowest index of any neighbor, so we can skip determining the owner
	if res == 0 || int32(cell>>((DMAX_H3_RES-res)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != CENTER_DIGIT {
		// Get the left neighbor of the vertex, with its rotations
		var left uint32 = XdirectionForVertexNum(tls, cell, vertexNum)
		if left == INVALID_DIGIT {
			return E_FAILED
		}
		*(*int32)(unsafe.Pointer(bp /* lRotations */)) = 0
		// var leftNeighbor uint64 at bp+8, 8

		var leftNeighborError uint32 = Xh3NeighborRotations(tls, cell, left, bp, bp+8)
		if leftNeighborError != 0 {
			return leftNeighborError
		}
		// Set to owner if lowest index
		if *(*uint64)(unsafe.Pointer(bp + 8)) < owner {
			owner = *(*uint64)(unsafe.Pointer(bp + 8 /* leftNeighbor */))
		}

		// As above, skip the right neighbor if the left is known lowest
		if res == 0 || int32(*(*uint64)(unsafe.Pointer(bp + 8))>>((DMAX_H3_RES-res)*DH3_PER_DIGIT_OFFSET)&uint64(7)) != CENTER_DIGIT {
			// Get the right neighbor of the vertex, with its rotations
			// Note that vertex - 1 is the right side, as vertex numbers are CCW
			var right uint32 = XdirectionForVertexNum(tls,
				cell, (vertexNum-1+cellNumVerts)%cellNumVerts)
			// This case should be unreachable; invalid verts fail earlier
			if func() int32 {
				if right == INVALID_DIGIT {
					return func() int32 {
						if 0 != 0 {
						} else {
							libc.X__assert_fail(tls, ts, ts+1738, int32(245), uintptr(unsafe.Pointer(&__func__25)))
						}
						return 1
					}()
				}
				return 0
			}() != 0 {
				return E_FAILED
			}
			*(*int32)(unsafe.Pointer(bp + 16 /* rRotations */)) = 0
			// var rightNeighbor uint64 at bp+24, 8

			var rightNeighborError uint32 = Xh3NeighborRotations(tls, cell, right, bp+16, bp+24)
			if rightNeighborError != 0 {
				return rightNeighborError
			}
			// Set to owner if lowest index
			if *(*uint64)(unsafe.Pointer(bp + 24)) < owner {
				owner = *(*uint64)(unsafe.Pointer(bp + 24 /* rightNeighbor */))
				var dir uint32
				if XisPentagon(tls, owner) != 0 {
					dir = XdirectionForNeighbor(tls, owner, cell)
				} else {
					dir = sDIRECTIONS1[(revNeighborDirectionsHex[right]+*(*int32)(unsafe.Pointer(bp + 16)))%DNUM_HEX_VERTS]
				}
				ownerVertexNum = XvertexNumForDirection(tls, owner, dir)
			}
		}

		// Determine the vertex number for the left neighbor
		if owner == *(*uint64)(unsafe.Pointer(bp + 8)) {
			var ownerIsPentagon int32 = XisPentagon(tls, owner)
			var dir uint32
			if ownerIsPentagon != 0 {
				dir = XdirectionForNeighbor(tls, owner, cell)
			} else {
				dir = sDIRECTIONS1[(revNeighborDirectionsHex[left]+*(*int32)(unsafe.Pointer(bp)))%DNUM_HEX_VERTS]
			}

			// For the left neighbor, we need the second vertex of the
			// edge, which may involve looping around the vertex nums
			ownerVertexNum = XvertexNumForDirection(tls, owner, dir) + 1
			if ownerVertexNum == DNUM_HEX_VERTS || ownerIsPentagon != 0 && ownerVertexNum == DNUM_PENT_VERTS {
				ownerVertexNum = 0
			}
		}
	}

	// Create the vertex index
	var vertex uint64 = owner
	vertex = vertex&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_VERTEX_MODE))<<DH3_MODE_OFFSET
	vertex = vertex&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET) | uint64(ownerVertexNum)<<DH3_RESERVED_OFFSET
	*(*uint64)(unsafe.Pointer(out)) = vertex

	return E_SUCCESS
}

var __func__25 = *(*[13]int8)(unsafe.Pointer(ts + 1761)) /* vertex.c:209:76 */

// *
// Get all vertexes for the given cell
// @param cell      Cell to get the vertexes for
// @param vertexes  Array to hold vertex output. Must have length >= 6.
func XcellToVertexes(tls *libc.TLS, cell uint64, vertexes uintptr) uint32 { /* vertex.c:297:9: */
	// Get all vertexes. If the cell is a pentagon, will fill the final slot
	// with H3_NULL.
	var isPent uint8 = uint8(XisPentagon(tls, cell))
	{
		var i int32 = 0
		for ; i < DNUM_HEX_VERTS; i++ {
			if i == 5 && isPent != 0 {
				*(*uint64)(unsafe.Pointer(vertexes + uintptr(i)*8)) = uint64(DH3_NULL)
			} else {
				var cellError uint32 = XcellToVertex(tls, cell, i, vertexes+uintptr(i)*8)
				if cellError != 0 {
					return cellError
				}
			}
		}
	}
	return E_SUCCESS
}

// *
// Get the geocoordinates of an H3 vertex
// @param vertex H3 index describing a vertex
// @param coord  Output geo coordinate
func XvertexToLatLng(tls *libc.TLS, vertex uint64, coord uintptr) uint32 { /* vertex.c:319:9: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	// Get the vertex number and owner from the vertex
	var vertexNum int32 = int32(vertex & (uint64(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET)
	var owner uint64 = vertex
	owner = owner&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	owner = owner&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET) | uint64(uint64(0))<<DH3_RESERVED_OFFSET

	// Get the single vertex from the boundary
	// var gb TCellBoundary at bp+16, 168

	// var fijk TFaceIJK at bp, 16

	var fijkError uint32 = X_h3ToFaceIjk(tls, owner, bp)
	if fijkError != 0 {
		return fijkError
	}
	var res int32 = int32(owner & (uint64(15) << DH3_RES_OFFSET) >> DH3_RES_OFFSET)

	if XisPentagon(tls, owner) != 0 {
		X_faceIjkPentToCellBoundary(tls, bp, res, vertexNum, 1, bp+16)
	} else {
		X_faceIjkToCellBoundary(tls, bp, res, vertexNum, 1, bp+16)
	}

	// Copy from boundary to output coord
	*(*TLatLng)(unsafe.Pointer(coord)) = *(*TLatLng)(unsafe.Pointer(bp + 16 + 8))
	return E_SUCCESS
}

// *
// Whether the input is a valid H3 vertex
// @param  vertex H3 index possibly describing a vertex
// @return        Whether the input is valid
func XisValidVertex(tls *libc.TLS, vertex uint64) int32 { /* vertex.c:351:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if int32(vertex&(uint64(uint64(15))<<DH3_MODE_OFFSET)>>DH3_MODE_OFFSET) != DH3_VERTEX_MODE {
		return 0
	}

	var vertexNum int32 = int32(vertex & (uint64(uint64(7)) << DH3_RESERVED_OFFSET) >> DH3_RESERVED_OFFSET)
	var owner uint64 = vertex
	owner = owner&libc.CplUint64(uint64(uint64(15))<<DH3_MODE_OFFSET) | uint64(uint64(DH3_CELL_MODE))<<DH3_MODE_OFFSET
	owner = owner&libc.CplUint64(uint64(uint64(7))<<DH3_RESERVED_OFFSET) | uint64(uint64(0))<<DH3_RESERVED_OFFSET

	if !(XisValidCell(tls, owner) != 0) {
		return 0
	}

	// The easiest way to ensure that the owner + vertex number is valid,
	// and that the vertex is canonical, is to recreate and compare.
	// var canonical uint64 at bp, 8

	if XcellToVertex(tls, owner, vertexNum, bp) != 0 {
		return 0
	}

	if vertex == *(*uint64)(unsafe.Pointer(bp)) {
		return 1
	}
	return 0
}

// GCC bug 66462 means we cannot use the math builtins with -fsignaling-nan,
//    so disable builtins if this is enabled.  When fixed in a newer GCC,
//    the __SUPPORT_SNAN__ check may be skipped for those versions.

// Return number of classification appropriate for X.
// The check for __cplusplus allows the use of the builtin, even
// 	when optimization for size is on.  This is provided for
// 	libstdc++, only to let its configure test work when it is built
// 	with -Os.  No further use of this definition of fpclassify is
// 	expected in C++ mode, since libstdc++ provides its own version
// 	of fpclassify in cmath (which undefines fpclassify).

// Return nonzero value if sign of X is negative.

// Return nonzero value if X is not +-Inf or NaN.

// Return nonzero value if X is neither zero, subnormal, Inf, nor NaN.

// Return nonzero value if X is a NaN.  We could use `fpclassify' but
//    we already have this functions `__isnan' and it is faster.

// Return nonzero value if X is positive or negative infinity.

// Bitmasks for the math_errhandling macro.

// By default all math functions support both errno and exception handling
//    (except for soft floating point implementations which may only support
//    errno handling).  If errno handling is disabled, exceptions are still
//    supported by GLIBC.  Set math_errhandling to 0 with -ffast-math (this is
//    nonconforming but it is more useful than leaving it undefined).

// Some useful constants.

// GNU extension to provide float constants with similar names.

// The above constants are not adequate for computation using `long double's.
//    Therefore we provide as an extension constants with similar names as a
//    GNU extension.  Provide enough digits for the 128-bit IEEE quad.

// ISO C99 defines some macros to compare number while taking care for
//    unordered numbers.  Many FPUs provide special instructions to support
//    these operations.  Generic support in GCC for these as builtins went
//    in 2.97, but not all cpus added their patterns until 3.1.  Therefore
//    we enable the builtins from 3.1 onwards and use a generic implementation
//    othwerwise.

// Define ISO C stdio on top of C++ iostreams.
//    Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.19 Input/output	<stdio.h>

// Copyright (C) 1991-2022 Free Software Foundation, Inc.
//    Copyright The GNU Toolchain Authors.
//    This file is part of the GNU C Library.
//
//    The GNU C Library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Lesser General Public
//    License as published by the Free Software Foundation; either
//    version 2.1 of the License, or (at your option) any later version.
//
//    The GNU C Library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public
//    License along with the GNU C Library; if not, see
//    <https://www.gnu.org/licenses/>.

//	ISO C99 Standard: 7.20 General utilities	<stdlib.h>

// Copyright 2020 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file alloc.h
// @brief   Memory management functions
//
// This file contains macros and the necessary declarations to be able
// to point H3 at different memory management functions than the standard
// malloc/free/etc functions.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file h3api.h
// @brief   Primary H3 core library entry points.
//
// This file defines the public API of the H3 library. Incompatible changes to
// these functions require the library's major version be increased.

// Copyright 2016-2021 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//         http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// * @file latLng.h
// @brief   Geodetic (lat/lng) functions.

// *
// Initialize a new VertexGraph
// @param graph       Graph to initialize
// @param  numBuckets Number of buckets to include in the graph
// @param  res        Resolution of the hexagons whose vertices we're storing
func XinitVertexGraph(tls *libc.TLS, graph uintptr, numBuckets int32, res int32) { /* vertexGraph.c:37:6: */
	if numBuckets > 0 {
		(*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets = libc.Xcalloc(tls, uint64(numBuckets), uint64(unsafe.Sizeof(uintptr(0))))
		if (*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets != uintptr(0) {
		} else {
			libc.X__assert_fail(tls, ts+1774, ts+1797, int32(40), uintptr(unsafe.Pointer(&__func__26)))
		}
	} else {
		(*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets = uintptr(0)
	}
	(*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets = numBuckets
	(*TVertexGraph)(unsafe.Pointer(graph)).Fsize = 0
	(*TVertexGraph)(unsafe.Pointer(graph)).Fres = res
}

var __func__26 = *(*[16]int8)(unsafe.Pointer(ts + 1825)) /* vertexGraph.c:37:67 */

// *
// Destroy a VertexGraph's sub-objects, freeing their memory. The caller is
// responsible for freeing memory allocated to the VertexGraph struct itself.
// @param graph Graph to destroy
func XdestroyVertexGraph(tls *libc.TLS, graph uintptr) { /* vertexGraph.c:54:6: */
	var node uintptr
	for libc.AssignUintptr(&node, XfirstVertexNode(tls, graph)) != uintptr(0) {
		XremoveVertexNode(tls, graph, node)
	}
	libc.Xfree(tls, (*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets)
}

// *
// Get an integer hash for a lat/lng point, at a precision determined
// by the current hexagon resolution.
// TODO: Light testing suggests this might not be sufficient at resolutions
// finer than 10. Design a better hash function if performance and collisions
// seem to be an issue here.
// @param  vertex     Lat/lng vertex to hash
// @param  res        Resolution of the hexagon the vertex belongs to
// @param  numBuckets Number of buckets in the graph
// @return            Integer hash
func X_hashVertex(tls *libc.TLS, vertex uintptr, res int32, numBuckets int32) uint32 { /* vertexGraph.c:73:10: */
	// Simple hash: Take the sum of the lat and lng with a precision level
	// determined by the resolution, converted to int, modulo bucket count.
	return libc.Uint32FromFloat64(libc.Xfmod(tls, libc.Xfabs(tls, ((*TLatLng)(unsafe.Pointer(vertex)).Flat+(*TLatLng)(unsafe.Pointer(vertex)).Flng)*libc.Xpow(tls, float64(10), float64(15-res))),
		float64(numBuckets)))
}

func X_initVertexNode(tls *libc.TLS, node uintptr, fromVtx uintptr, toVtx uintptr) { /* vertexGraph.c:80:6: */
	(*TVertexNode)(unsafe.Pointer(node)).Ffrom = *(*TLatLng)(unsafe.Pointer(fromVtx))
	(*TVertexNode)(unsafe.Pointer(node)).Fto = *(*TLatLng)(unsafe.Pointer(toVtx))
	(*TVertexNode)(unsafe.Pointer(node)).Fnext = uintptr(0)
}

// *
// Add a edge to the graph
// @param graph   Graph to add node to
// @param fromVtx Start vertex
// @param toVtx   End vertex
// @return        Pointer to the new node
func XaddVertexNode(tls *libc.TLS, graph uintptr, fromVtx uintptr, toVtx uintptr) uintptr { /* vertexGraph.c:94:12: */
	// Make the new node
	var node uintptr = libc.Xmalloc(tls, uint64(unsafe.Sizeof(TVertexNode{})))
	if node != uintptr(0) {
	} else {
		libc.X__assert_fail(tls, ts+1841, ts+1797, int32(98), uintptr(unsafe.Pointer(&__func__27)))
	}
	X_initVertexNode(tls, node, fromVtx, toVtx)
	// Determine location
	var index uint32 = X_hashVertex(tls, fromVtx, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	// Check whether there's an existing node in that spot
	var currentNode uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	if currentNode == uintptr(0) {
		// Set bucket to the new node
		*(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8)) = node
	} else {
		// Find the end of the list
		for __ccgo := true; __ccgo; __ccgo = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
			// Check the the edge we're adding doesn't already exist
			if XgeoAlmostEqual(tls, currentNode, fromVtx) != 0 && XgeoAlmostEqual(tls, currentNode+16, toVtx) != 0 {
				// already exists, bail
				libc.Xfree(tls, node)
				return currentNode
			}
			if (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
				currentNode = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext
			}
		}
		// Add the new node to the end of the list
		(*TVertexNode)(unsafe.Pointer(currentNode)).Fnext = node
	}
	(*TVertexGraph)(unsafe.Pointer(graph)).Fsize++
	return node
}

var __func__27 = *(*[14]int8)(unsafe.Pointer(ts + 1854)) /* vertexGraph.c:95:48 */

// *
// Remove a node from the graph. The input node will be freed, and should
// not be used after removal.
// @param graph Graph to mutate
// @param node  Node to remove
// @return      0 on success, 1 on failure (node not found)
func XremoveVertexNode(tls *libc.TLS, graph uintptr, node uintptr) int32 { /* vertexGraph.c:135:5: */
	// Determine location
	var index uint32 = X_hashVertex(tls, node, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	var currentNode uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	var found int32 = 0
	if currentNode != uintptr(0) {
		if currentNode == node {
			*(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8)) = (*TVertexNode)(unsafe.Pointer(node)).Fnext
			found = 1
		}
		// Look through the list
		for !(found != 0) && (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext != uintptr(0) {
			if (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext == node {
				// splice the node out
				(*TVertexNode)(unsafe.Pointer(currentNode)).Fnext = (*TVertexNode)(unsafe.Pointer(node)).Fnext
				found = 1
			}
			currentNode = (*TVertexNode)(unsafe.Pointer(currentNode)).Fnext
		}
	}
	if found != 0 {
		libc.Xfree(tls, node)
		(*TVertexGraph)(unsafe.Pointer(graph)).Fsize--
		return 0
	}
	// Failed to find the node
	return 1
}

// *
// Find the Vertex node for a given edge, if it exists
// @param  graph   Graph to look in
// @param  fromVtx Start vertex
// @param  toVtx   End vertex, or NULL if we don't care
// @return         Pointer to the vertex node, if found
func XfindNodeForEdge(tls *libc.TLS, graph uintptr, fromVtx uintptr, toVtx uintptr) uintptr { /* vertexGraph.c:171:12: */
	// Determine location
	var index uint32 = X_hashVertex(tls, fromVtx, (*TVertexGraph)(unsafe.Pointer(graph)).Fres, (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets)
	// Check whether there's an existing node in that spot
	var node uintptr = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(index)*8))
	if node != uintptr(0) {
		// Look through the list and see if we find the edge
		for __ccgo := true; __ccgo; __ccgo = node != uintptr(0) {
			if XgeoAlmostEqual(tls, node, fromVtx) != 0 && (toVtx == uintptr(0) || XgeoAlmostEqual(tls, node+16, toVtx) != 0) {
				return node
			}
			node = (*TVertexNode)(unsafe.Pointer(node)).Fnext
		}
	}
	// Iteration lookup fail
	return uintptr(0)
}

// *
// Find a Vertex node starting at the given vertex
// @param  graph   Graph to look in
// @param  fromVtx Start vertex
// @return         Pointer to the vertex node, if found
func XfindNodeForVertex(tls *libc.TLS, graph uintptr, fromVtx uintptr) uintptr { /* vertexGraph.c:197:12: */
	return XfindNodeForEdge(tls, graph, fromVtx, uintptr(0))
}

// *
// Get the next vertex node in the graph.
// @param  graph Graph to iterate
// @return       Vertex node, or NULL if at the end
func XfirstVertexNode(tls *libc.TLS, graph uintptr) uintptr { /* vertexGraph.c:206:12: */
	var node uintptr = uintptr(0)
	var currentIndex int32 = 0
	for node == uintptr(0) {
		if currentIndex < (*TVertexGraph)(unsafe.Pointer(graph)).FnumBuckets {
			// find the first node in the next bucket
			node = *(*uintptr)(unsafe.Pointer((*TVertexGraph)(unsafe.Pointer(graph)).Fbuckets + uintptr(currentIndex)*8))
		} else {
			// end of iteration
			return uintptr(0)
		}
		currentIndex++
	}
	return node
}

var ts1 = "0\x00src/h3lib/lib/algos.c\x00h3NeighborRotations\x00src/h3lib/lib/coordijk.c\x00_upAp7Checked\x00_upAp7rChecked\x00src/h3lib/lib/directedEdge.c\x00directedEdgeToBoundary\x00adjacentFaceDir[tmpFijk.face][fijk.face] == KI\x00src/h3lib/lib/faceijk.c\x00_faceIjkPentToCellBoundary\x00adjacentFaceDir[centerIJK.face][face2] == KI\x00_faceIjkToCellBoundary\x00Success\x00The operation failed but a more specific error is not available\x00Argument was outside of acceptable range\x00Latitude or longitude arguments were outside of acceptable range\x00Resolution argument was outside of acceptable range\x00Cell argument was not valid\x00Directed edge argument was not valid\x00Undirected edge argument was not valid\x00Vertex argument was not valid\x00Pentagon distortion was encountered\x00Duplicate input\x00Cell arguments were not neighbors\x00Cell arguments had incompatible resolutions\x00Memory allocation failed\x00Bounds of provided memory were insufficient\x00Mode or flags argument was not valid\x00Invalid error code\x00%lx\x00src/h3lib/lib/h3Index.c\x00isValidCell\x00compactCells\x00latLngToCell\x00_h3ToFaceIjk\x00getIcosahedronFaces\x00validateChildPos\x00cellToChildPos\x00src/h3lib/lib/latLng.c\x00cellAreaRads2\x00polygon->next == NULL\x00src/h3lib/lib/linkedGeo.c\x00next != NULL\x00addNewLinkedPolygon\x00loop != NULL\x00addNewLinkedLoop\x00polygon->first == NULL\x00addLinkedLoop\x00coord != NULL\x00loop->first == NULL\x00addLinkedCoord\x00candidates != NULL\x00candidateBBoxes != NULL\x00findPolygonForHole\x00innerLoops != NULL\x00bboxes != NULL\x00normalizeMultiPolygon\x00src/h3lib/lib/localij.c\x00revDir != INVALID_DIGIT\x00baseCell != originBaseCell\x00!(originOnPent && indexOnPent)\x00baseCell == originBaseCell\x00cellToLocalIjk\x00baseCell != INVALID_BASE_CELL\x00!_isBaseCellPentagon(baseCell)\x00baseCellRotations >= 0\x00localIjkToCell\x00gridPathCells\x00src/h3lib/lib/polyfill.c\x00cellToBBox\x00iterStepPolygonCompact\x00src/h3lib/lib/vertex.c\x00cellToVertex\x00graph->buckets != NULL\x00src/h3lib/lib/vertexGraph.c\x00initVertexGraph\x00node != NULL\x00addVertexNode\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
